This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-31T02:22:50.329Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
main/java/io.github.minemon/audio/config/AudioConfig.java
main/java/io.github.minemon/audio/model/SoundEffect.java
main/java/io.github.minemon/audio/model/WeatherSoundEffect.java
main/java/io.github.minemon/audio/service/AudioService.java
main/java/io.github.minemon/audio/service/impl/AudioServiceImpl.java
main/java/io.github.minemon/chat/commands/Command.java
main/java/io.github.minemon/chat/commands/SpawnCommand.java
main/java/io.github.minemon/chat/config/ChatConfig.java
main/java/io.github.minemon/chat/event/ChatListener.java
main/java/io.github.minemon/chat/event/ChatMessageReceivedEvent.java
main/java/io.github.minemon/chat/model/ChatMessage.java
main/java/io.github.minemon/chat/service/ChatService.java
main/java/io.github.minemon/chat/service/CommandService.java
main/java/io.github.minemon/chat/service/impl/ChatServiceImpl.java
main/java/io.github.minemon/chat/service/impl/CommandServiceImpl.java
main/java/io.github.minemon/chat/ui/ChatTable.java
main/java/io.github.minemon/core/config/GameConfig.java
main/java/io.github.minemon/core/config/GameSettings.java
main/java/io.github.minemon/core/config/ScreenConfig.java
main/java/io.github.minemon/core/screen/GameScreen.java
main/java/io.github.minemon/core/screen/LoginScreen.java
main/java/io.github.minemon/core/screen/ModeSelectionScreen.java
main/java/io.github.minemon/core/screen/ServerListView.java
main/java/io.github.minemon/core/screen/SettingsScreen.java
main/java/io.github.minemon/core/screen/WorldSelectionScreen.java
main/java/io.github.minemon/core/service/BackgroundService.java
main/java/io.github.minemon/core/service/FileAccessService.java
main/java/io.github.minemon/core/service/impl/LocalFileAccessService.java
main/java/io.github.minemon/core/service/impl/ScreenManagerImpl.java
main/java/io.github.minemon/core/service/impl/SpringFileAccessService.java
main/java/io.github.minemon/core/service/ScreenManager.java
main/java/io.github.minemon/core/service/SettingsService.java
main/java/io.github.minemon/core/service/UiService.java
main/java/io.github.minemon/core/ui/DialogFactory.java
main/java/io.github.minemon/core/ui/ServerConfigDialog.java
main/java/io.github.minemon/core/ui/StyleFactory.java
main/java/io.github.minemon/event/Event.java
main/java/io.github.minemon/event/EventBus.java
main/java/io.github.minemon/event/EventListener.java
main/java/io.github.minemon/input/InputConfiguration.java
main/java/io.github.minemon/input/InputService.java
main/java/io.github.minemon/multiplayer/config/MultiplayerConfig.java
main/java/io.github.minemon/multiplayer/model/ChunkUpdate.java
main/java/io.github.minemon/multiplayer/model/PlayerSyncData.java
main/java/io.github.minemon/multiplayer/model/ServerConnectionConfig.java
main/java/io.github.minemon/multiplayer/model/User.java
main/java/io.github.minemon/multiplayer/model/WorldObjectUpdate.java
main/java/io.github.minemon/multiplayer/repository/UserRepository.java
main/java/io.github.minemon/multiplayer/service/AuthService.java
main/java/io.github.minemon/multiplayer/service/impl/MultiplayerClientImpl.java
main/java/io.github.minemon/multiplayer/service/impl/MultiplayerServerImpl.java
main/java/io.github.minemon/multiplayer/service/impl/MultiplayerServiceImpl.java
main/java/io.github.minemon/multiplayer/service/impl/ServerCleanupService.java
main/java/io.github.minemon/multiplayer/service/impl/ServerConnectionServiceImpl.java
main/java/io.github.minemon/multiplayer/service/MultiplayerClient.java
main/java/io.github.minemon/multiplayer/service/MultiplayerServer.java
main/java/io.github.minemon/multiplayer/service/MultiplayerService.java
main/java/io.github.minemon/multiplayer/service/ServerConnectionService.java
main/java/io.github.minemon/NetworkProtocol.java
main/java/io.github.minemon/player/config/PlayerConfig.java
main/java/io.github.minemon/player/config/PlayerProperties.java
main/java/io.github.minemon/player/event/PlayerJoinEvent.java
main/java/io.github.minemon/player/event/PlayerLeaveEvent.java
main/java/io.github.minemon/player/event/PlayerMoveEvent.java
main/java/io.github.minemon/player/model/PlayerData.java
main/java/io.github.minemon/player/model/PlayerDirection.java
main/java/io.github.minemon/player/model/PlayerModel.java
main/java/io.github.minemon/player/service/impl/PlayerAnimationServiceImpl.java
main/java/io.github.minemon/player/service/impl/PlayerServiceImpl.java
main/java/io.github.minemon/player/service/PlayerAnimationService.java
main/java/io.github.minemon/player/service/PlayerService.java
main/java/io.github.minemon/plugin/Plugin.java
main/java/io.github.minemon/plugin/PluginManager.java
main/java/io.github.minemon/utils/OpenSimplex2.java
main/java/io.github.minemon/utils/UUIDSerializer.java
main/java/io.github.minemon/weather/config/WeatherConfig.java
main/java/io.github.minemon/weather/model/WeatherType.java
main/java/io.github.minemon/weather/service/WeatherAudioService.java
main/java/io.github.minemon/world/biome/config/BiomeConfig.java
main/java/io.github.minemon/world/biome/config/BiomeConfigurationLoader.java
main/java/io.github.minemon/world/biome/model/Biome.java
main/java/io.github.minemon/world/biome/model/BiomeTransitionResult.java
main/java/io.github.minemon/world/biome/model/BiomeType.java
main/java/io.github.minemon/world/biome/service/BiomeService.java
main/java/io.github.minemon/world/biome/service/impl/BiomeServiceImpl.java
main/java/io.github.minemon/world/config/TileConfig.java
main/java/io.github.minemon/world/config/WorldConfig.java
main/java/io.github.minemon/world/config/WorldConfiguration.java
main/java/io.github.minemon/world/config/WorldObjectConfig.java
main/java/io.github.minemon/world/event/ChunkLoadEvent.java
main/java/io.github.minemon/world/event/WorldObjectRemoveEvent.java
main/java/io.github.minemon/world/event/WorldObjectSpawnEvent.java
main/java/io.github.minemon/world/model/ChunkData.java
main/java/io.github.minemon/world/model/ObjectType.java
main/java/io.github.minemon/world/model/WorldData.java
main/java/io.github.minemon/world/model/WorldMetadata.java
main/java/io.github.minemon/world/model/WorldObject.java
main/java/io.github.minemon/world/model/WorldRenderer.java
main/java/io.github.minemon/world/service/ChunkLoaderService.java
main/java/io.github.minemon/world/service/ChunkPreloaderService.java
main/java/io.github.minemon/world/service/impl/BaseWorldServiceImpl.java
main/java/io.github.minemon/world/service/impl/ChunkCacheManager.java
main/java/io.github.minemon/world/service/impl/ClientTileManagerImpl.java
main/java/io.github.minemon/world/service/impl/ClientWorldServiceImpl.java
main/java/io.github.minemon/world/service/impl/JsonWorldDataService.java
main/java/io.github.minemon/world/service/impl/ObjectTextureManager.java
main/java/io.github.minemon/world/service/impl/ServerTileManagerImpl.java
main/java/io.github.minemon/world/service/impl/ServerWorldObjectManagerImpl.java
main/java/io.github.minemon/world/service/impl/ServerWorldServiceImpl.java
main/java/io.github.minemon/world/service/impl/WorldGeneratorImpl.java
main/java/io.github.minemon/world/service/impl/WorldObjectManagerImpl.java
main/java/io.github.minemon/world/service/TileManager.java
main/java/io.github.minemon/world/service/WorldGenerator.java
main/java/io.github.minemon/world/service/WorldObjectManager.java
main/java/io.github.minemon/world/service/WorldService.java

================================================================
Repository Files
================================================================

================
File: main/java/io.github.minemon/audio/config/AudioConfig.java
================
package io.github.minemon.audio.config;

import io.github.minemon.audio.service.AudioService;
import io.github.minemon.audio.service.impl.AudioServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AudioConfig {

    @Bean
    public AudioService audioService() {
        return new AudioServiceImpl();
    }
}

================
File: main/java/io.github.minemon/audio/model/SoundEffect.java
================
package io.github.minemon.audio.model;

import lombok.Getter;

@Getter
public enum SoundEffect {
    ITEM_PICKUP("sounds/pickup.ogg"),
    MENU_SELECT("sounds/select.ogg"),
    MENU_BACK("sounds/back.ogg"),
    BATTLE_WIN("sounds/battle_win.ogg"),
    CRITICAL_HIT("sounds/critical_hit.ogg"),
    CURSOR_MOVE("sounds/cursor_move.ogg"),
    DAMAGE("sounds/damage.ogg"),
    COLLIDE("sounds/player-bump.ogg"),
    MOVE_SELECT("sounds/move_select.ogg"),
    NOT_EFFECTIVE("sounds/not_effective.ogg"),
    SUPER_EFFECTIVE("sounds/super_effective.ogg"),
    CRAFT("sounds/crafting.ogg"),
    BLOCK_PLACE_0("sounds/block_place_0.ogg"),
    BLOCK_PLACE_1("sounds/block_place_1.ogg"),
    BLOCK_PLACE_2("sounds/block_place_2.ogg"),
    BLOCK_BREAK_WOOD("sounds/break_wood.ogg"),
    TOOL_BREAK("sounds/tool_break.ogg"),
    BLOCK_BREAK_WOOD_HAND("sounds/break_wood_hand.ogg"),
    PUDDLE("sounds/puddle.ogg"),
    CHEST_OPEN("sounds/chest-open.ogg"),
    CHEST_CLOSE("sounds/chest-close.ogg"),
    HOUSE_BUILD("sounds/house_build.ogg");

    private final String path;

    SoundEffect(String path) {
        this.path = path;
    }

}

================
File: main/java/io.github.minemon/audio/model/WeatherSoundEffect.java
================
package io.github.minemon.audio.model;

import lombok.Getter;

@Getter
public enum WeatherSoundEffect {
    LIGHT_RAIN("sounds/weather/rain.ogg"),
    THUNDER("sounds/weather/thunder.ogg"),
    WIND("sounds/weather/wind.ogg"),
    SAND_WIND("sounds/weather/sandwind.ogg");

    private final String path;

    WeatherSoundEffect(String path) {
        this.path = path;
    }

}

================
File: main/java/io.github.minemon/audio/service/AudioService.java
================
package io.github.minemon.audio.service;

import io.github.minemon.audio.model.SoundEffect;
import io.github.minemon.audio.model.WeatherSoundEffect;

public interface AudioService {

    void initAudio();

    void playMenuMusic();
    void stopMenuMusic();
    void fadeOutMenuMusic();
    void update(float delta);

    void playSound(SoundEffect effect);


    
    void playWeatherSound(WeatherSoundEffect effect, float volume, float pitch);

    
    void updateWeatherLoop(WeatherSoundEffect effect, float volume);

    
    void stopWeatherLoop(WeatherSoundEffect effect);

    float getMusicVolume();
    void setMusicVolume(float musicVolume);
    float getSoundVolume();
    void setSoundVolume(float soundVolume);
    boolean isMusicEnabled();
    void setMusicEnabled(boolean musicEnabled);
    boolean isSoundEnabled();
    void setSoundEnabled(boolean soundEnabled);

    void dispose();
}

================
File: main/java/io.github.minemon/audio/service/impl/AudioServiceImpl.java
================
package io.github.minemon.audio.service.impl;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.math.MathUtils;
import io.github.minemon.audio.model.SoundEffect;
import io.github.minemon.audio.model.WeatherSoundEffect;
import io.github.minemon.audio.service.AudioService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
@Primary
public class AudioServiceImpl implements AudioService {
    private static final Logger logger = LoggerFactory.getLogger(AudioServiceImpl.class);

    private final Map<SoundEffect, Sound> sounds = new EnumMap<>(SoundEffect.class);

    private final Map<WeatherSoundEffect, Music> weatherLoops = new EnumMap<>(WeatherSoundEffect.class);
    private final Map<WeatherSoundEffect, Sound> weatherSounds = new EnumMap<>(WeatherSoundEffect.class);

    private List<Music> menuMusicList;
    private Music currentMusic;

    private final float masterVolume = 1.0f;
    private float musicVolume = 0.7f;
    private float soundVolume = 1.0f;
    private boolean musicEnabled = true;
    private boolean soundEnabled = true;

    private static final float MUSIC_FADE_DURATION = 2.0f;
    private static final float FADE_OUT_DURATION = 2f;

    private boolean isFadingOutMusic = false;
    private float fadeOutMusicTimer = 0f;
    private boolean isFadingInMusic = false;
    private float fadeInMusicTimer = 0f;

    public AudioServiceImpl() {
    }

    @Override
    public void initAudio() {
        initializeAudio();
    }

    private void initializeAudio() {

        for (SoundEffect effect : SoundEffect.values()) {
            try {
                Sound sound = Gdx.audio.newSound(Gdx.files.internal("assets/" + effect.getPath()));
                sounds.put(effect, sound);
            } catch (Exception e) {
                logger.error("Failed to load sound: {}", effect.getPath(), e);
            }
        }




        for (WeatherSoundEffect wEffect : WeatherSoundEffect.values()) {
            String path = "assets/" + wEffect.getPath();
            if (wEffect == WeatherSoundEffect.THUNDER) {

                try {
                    Sound wSound = Gdx.audio.newSound(Gdx.files.internal(path));
                    weatherSounds.put(wEffect, wSound);
                } catch (Exception e) {
                    logger.error("Failed to load weather sound: {}", path, e);
                }
            } else {

                try {
                    Music wMusic = Gdx.audio.newMusic(Gdx.files.internal(path));
                    wMusic.setLooping(true);
                    wMusic.setVolume(0f);
                    weatherLoops.put(wEffect, wMusic);
                } catch (Exception e) {
                    logger.error("Failed to load weather loop: {}", path, e);
                }
            }
        }

        menuMusicList = new ArrayList<>();
        loadMenuMusic(Arrays.asList(
                "music/Menu-Music-1.mp3",
                "music/Menu-Music-2.mp3",
                "music/Menu-Music-0.mp3",
                "music/Menu-Music-3.mp3",
                "music/Menu-Music-4.mp3"
        ));
    }

    private void loadMenuMusic(List<String> paths) {
        for (String path : paths) {
            try {
                Music music = Gdx.audio.newMusic(Gdx.files.internal("assets/" + path));
                music.setVolume(musicVolume * masterVolume);
                menuMusicList.add(music);
            } catch (Exception e) {
                logger.error("Failed to load menu music: {}", path, e);
            }
        }
    }

    @Override
    public void playMenuMusic() {
        if (!musicEnabled || menuMusicList == null || menuMusicList.isEmpty()) {
            return;
        }

        if (currentMusic == null || !currentMusic.isPlaying()) {
            stopCurrentMusic();
            int index = MathUtils.random(menuMusicList.size() - 1);
            currentMusic = menuMusicList.get(index);
            currentMusic.setVolume(0f);
            currentMusic.setLooping(false);
            currentMusic.play();
            isFadingInMusic = true;
            fadeInMusicTimer = MUSIC_FADE_DURATION;
            setMusicCompletionListenerForMenu();
        }
    }

    private void setMusicCompletionListenerForMenu() {
        if (currentMusic != null) {
            currentMusic.setOnCompletionListener(music -> playMenuMusic());
        }
    }

    @Override
    public void stopMenuMusic() {
        if (currentMusic != null && currentMusic.isPlaying()) {
            isFadingOutMusic = true;
            fadeOutMusicTimer = MUSIC_FADE_DURATION;
        }
    }

    @Override
    public void fadeOutMenuMusic() {
        if (currentMusic != null && currentMusic.isPlaying()) {
            isFadingOutMusic = true;
            fadeOutMusicTimer = FADE_OUT_DURATION;
        }
    }

    @Override
    public void update(float delta) {
        if (isFadingInMusic && currentMusic != null) {
            fadeInMusicTimer -= delta;
            float progress = 1 - Math.max(0, fadeInMusicTimer / MUSIC_FADE_DURATION);
            float volume = progress * musicVolume * masterVolume;
            currentMusic.setVolume(volume);

            if (fadeInMusicTimer <= 0) {
                isFadingInMusic = false;
                currentMusic.setVolume(musicVolume * masterVolume);
            }
        }

        if (isFadingOutMusic && currentMusic != null) {
            fadeOutMusicTimer -= delta;
            float volume = Math.max(0, (fadeOutMusicTimer / MUSIC_FADE_DURATION) * musicVolume * masterVolume);
            currentMusic.setVolume(volume);

            if (fadeOutMusicTimer <= 0) {
                currentMusic.stop();
                isFadingOutMusic = false;
                currentMusic = null;
            }
        }
    }

    @Override
    public void playSound(SoundEffect effect) {
        if (!soundEnabled) return;
        Sound sound = sounds.get(effect);
        if (sound != null) {
            sound.play(soundVolume * masterVolume);
        }
    }

    @Override
    public void playWeatherSound(WeatherSoundEffect effect, float volume, float pitch) {
        if (!soundEnabled) return;

        Sound wSound = weatherSounds.get(effect);
        if (wSound != null) {
            long id = wSound.play(volume * soundVolume * masterVolume);
            wSound.setPitch(id, pitch);
        } else {
            logger.debug("Weather sound {} not found or not loaded as Sound.", effect);
        }
    }

    @Override
    public void updateWeatherLoop(WeatherSoundEffect effect, float volume) {
        if (!soundEnabled) return;

        Music loop = weatherLoops.get(effect);
        if (loop != null) {
            if (!loop.isPlaying()) {
                loop.play();
            }
            float finalVolume = volume * soundVolume * masterVolume;
            loop.setVolume(finalVolume);

            if (finalVolume <= 0.01f) {
                loop.pause();
            }
        } else {
            logger.debug("Weather loop {} not found or not loaded as Music.", effect);
        }
    }

    @Override
    public void stopWeatherLoop(WeatherSoundEffect effect) {
        Music loop = weatherLoops.get(effect);
        if (loop != null && loop.isPlaying()) {
            loop.stop();
        }
    }

    @Override
    public float getMusicVolume() {
        return musicVolume;
    }

    @Override
    public void setMusicVolume(float musicVolume) {
        this.musicVolume = musicVolume;
        if (currentMusic != null) {
            currentMusic.setVolume(musicVolume * masterVolume);
        }
    }

    @Override
    public float getSoundVolume() {
        return soundVolume;
    }

    @Override
    public void setSoundVolume(float soundVolume) {
        this.soundVolume = soundVolume;

        for (Music loop : weatherLoops.values()) {
            if (loop.isPlaying()) {



                float currentVol = loop.getVolume() / (masterVolume);
                loop.setVolume(currentVol * soundVolume);
            }
        }
    }

    @Override
    public boolean isMusicEnabled() {
        return musicEnabled;
    }

    @Override
    public void setMusicEnabled(boolean musicEnabled) {
        this.musicEnabled = musicEnabled;
        if (currentMusic != null) {
            if (musicEnabled) {
                if (!currentMusic.isPlaying()) {
                    currentMusic.play();
                }
                currentMusic.setVolume(musicVolume * masterVolume);
            } else {
                currentMusic.pause();
            }
        }
    }

    @Override
    public boolean isSoundEnabled() {
        return soundEnabled;
    }

    @Override
    public void setSoundEnabled(boolean soundEnabled) {
        this.soundEnabled = soundEnabled;

        if (!soundEnabled) {
            for (Music loop : weatherLoops.values()) {
                if (loop.isPlaying()) {
                    loop.pause();
                }
            }
        } else {


        }
    }

    private void stopCurrentMusic() {
        if (currentMusic != null) {
            currentMusic.stop();
            currentMusic = null;
        }
    }

    @Override
    public void dispose() {
        for (Sound sound : sounds.values()) {
            sound.dispose();
        }
        sounds.clear();

        if (currentMusic != null) {
            currentMusic.stop();
            currentMusic.dispose();
            currentMusic = null;
        }

        if (menuMusicList != null) {
            for (Music music : menuMusicList) {
                music.dispose();
            }
            menuMusicList.clear();
        }


        for (Sound wSound : weatherSounds.values()) {
            wSound.dispose();
        }
        weatherSounds.clear();

        for (Music loop : weatherLoops.values()) {
            loop.dispose();
        }
        weatherLoops.clear();
    }
}

================
File: main/java/io.github.minemon/chat/commands/Command.java
================
package io.github.minemon.chat.commands;

import io.github.minemon.chat.service.ChatService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.service.PlayerService;

public interface Command {
    String getName();
    String[] getAliases();
    String getDescription();
    String getUsage();
    boolean isMultiplayerOnly();

    
    void execute(String args, PlayerService playerService, ChatService chatService, MultiplayerClient multiplayerClient);
}

================
File: main/java/io.github.minemon/chat/commands/SpawnCommand.java
================
package io.github.minemon.chat.commands;

import io.github.minemon.chat.service.ChatService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.service.PlayerService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class SpawnCommand implements Command {
    @Override
    public String getName() { return "spawn"; }
    @Override
    public String[] getAliases() { return new String[0]; }
    @Override
    public String getDescription() { return "Teleports player to spawn."; }
    @Override
    public String getUsage() { return "/spawn"; }
    @Override
    public boolean isMultiplayerOnly() { return false; }

    @Override
    public void execute(String args, PlayerService playerService, ChatService chatService, MultiplayerClient multiplayerClient) {
        PlayerData player = playerService.getPlayerData();
        if (player == null) {
            chatService.addSystemMessage("Error: Player not found");
            return;
        }
        player.setX(0);
        player.setY(0);
        playerService.setPosition(0,0);

        if (multiplayerClient.isConnected()) {
            multiplayerClient.sendPlayerMove(player.getX(), player.getY(), player.isWantsToRun(), player.isMoving(), player.getDirection().name().toLowerCase());
        }
        chatService.addSystemMessage("Teleported to spawn point!");
    }
}

================
File: main/java/io.github.minemon/chat/config/ChatConfig.java
================
package io.github.minemon.chat.config;

import io.github.minemon.chat.commands.SpawnCommand;
import io.github.minemon.chat.service.CommandService;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ChatConfig {

    @Autowired
    private CommandService commandService;

    @Autowired
    private SpawnCommand spawnCommand;

    @PostConstruct
    public void registerCommands() {
        commandService.registerCommand(spawnCommand);
    }
}

================
File: main/java/io.github.minemon/chat/event/ChatListener.java
================
package io.github.minemon.chat.event;

import io.github.minemon.chat.model.ChatMessage;

public interface ChatListener {
    void onNewMessage(ChatMessage msg);
}

================
File: main/java/io.github.minemon/chat/event/ChatMessageReceivedEvent.java
================
package io.github.minemon.chat.event;

import io.github.minemon.chat.model.ChatMessage;
import lombok.Getter;
import org.springframework.context.ApplicationEvent;

@Getter
public class ChatMessageReceivedEvent extends ApplicationEvent {
    private final ChatMessage chatMessage;

    public ChatMessageReceivedEvent(Object source, ChatMessage chatMessage) {
        super(source);
        this.chatMessage = chatMessage;
    }

}

================
File: main/java/io.github.minemon/chat/model/ChatMessage.java
================
package io.github.minemon.chat.model;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class ChatMessage {
    private String sender;
    private String content;
    private long timestamp;
    private Type type;
    public enum Type {
        NORMAL, SYSTEM
    }
}

================
File: main/java/io.github.minemon/chat/service/ChatService.java
================
package io.github.minemon.chat.service;

import io.github.minemon.chat.model.ChatMessage;
import io.github.minemon.chat.event.ChatListener;

import java.util.List;
import java.util.Queue;

public interface ChatService {
    void sendMessage(String content);
    void addSystemMessage(String message);
    void handleIncomingMessage(ChatMessage message);
    void activateChat();
    void deactivateChat();
    boolean isActive();
    List<ChatMessage> pollMessages();
    Queue<ChatMessage> getMessages();

    String getPreviousHistoryMessage(String currentText);
    String getNextHistoryMessage();

    // **Add the following methods**
    void addListener(ChatListener listener);
    void removeListener(ChatListener listener);
}

================
File: main/java/io.github.minemon/chat/service/CommandService.java
================
package io.github.minemon.chat.service;

import io.github.minemon.chat.commands.Command;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.service.PlayerService;

public interface CommandService {
    void registerCommand(Command command);
    boolean executeCommand(String name, String args, PlayerService playerService, ChatService chatService, MultiplayerClient multiplayerClient);
}

================
File: main/java/io.github.minemon/chat/service/impl/ChatServiceImpl.java
================
package io.github.minemon.chat.service.impl;

import io.github.minemon.chat.event.ChatListener;
import io.github.minemon.chat.event.ChatMessageReceivedEvent;
import io.github.minemon.chat.model.ChatMessage;
import io.github.minemon.chat.service.ChatService;
import io.github.minemon.chat.service.CommandService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.service.PlayerService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;

@Service
@Slf4j
public class ChatServiceImpl implements ChatService {

    private final PlayerService playerService;
    @Autowired
    @Lazy
    private MultiplayerClient multiplayerClient;
    private final CommandService commandService;
    private final ConcurrentLinkedQueue<ChatMessage> messages = new ConcurrentLinkedQueue<>();
    private final List<String> messageHistory = new ArrayList<>();
    private boolean isActive;
    private int messageHistoryIndex = -1;
    private String currentInputBeforeHistory = "";

    private final List<ChatListener> listeners = new CopyOnWriteArrayList<>();

    @Autowired
    public ChatServiceImpl(PlayerService playerService, MultiplayerClient multiplayerClient, CommandService commandService) {
        this.playerService = playerService;
        this.multiplayerClient = multiplayerClient;
        this.commandService = commandService;
    }

    @EventListener 
    public void onChatMessageReceived(ChatMessageReceivedEvent event) {
        ChatMessage chatMessage = event.getChatMessage();
        handleIncomingMessage(chatMessage);
    }

    @Override
    public List<ChatMessage> pollMessages() {
        List<ChatMessage> newMessages = new ArrayList<>();
        ChatMessage msg;
        while ((msg = messages.poll()) != null) {
            newMessages.add(msg);
        }
        return newMessages;
    }

    @Override
    public void sendMessage(String content) {
        if (content.isEmpty()) return;

        if (messageHistory.isEmpty() || !content.equals(messageHistory.get(messageHistory.size() - 1))) {
            messageHistory.add(content);
            messageHistoryIndex = messageHistory.size();
        }

        boolean isMultiplayer = multiplayerClient.isConnected();

        if (content.startsWith("/")) {
            String[] parts = content.substring(1).split(" ", 2);
            String commandName = parts[0].toLowerCase();
            String args = (parts.length > 1) ? parts[1] : "";
            if (!commandService.executeCommand(commandName, args, playerService, this, multiplayerClient)) {
                addSystemMessage("Unknown command: " + commandName);
            }
            return;
        }

        String username = playerService.getPlayerData().getUsername();
        if (username == null || username.isEmpty()) {
            username = "Player";
        }

        ChatMessage msg = new ChatMessage(username, content, System.currentTimeMillis(), ChatMessage.Type.NORMAL);
        handleIncomingMessage(msg);

        if (isMultiplayer) {
            multiplayerClient.sendMessage(msg);
        }
    }

    @Override
    public void addSystemMessage(String message) {
        ChatMessage sysMsg = new ChatMessage("System", message, System.currentTimeMillis(), ChatMessage.Type.SYSTEM);
        handleIncomingMessage(sysMsg);
    }

    @Override
    public void handleIncomingMessage(ChatMessage message) {
        messages.add(message);
        log.info("Received chat message from: {} content: {}", message.getSender(), message.getContent());

        for (ChatListener listener : listeners) {
            listener.onNewMessage(message);
        }
    }

    @Override
    public void activateChat() {
        isActive = true;
        messageHistoryIndex = messageHistory.size();
        currentInputBeforeHistory = "";
    }

    @Override
    public void deactivateChat() {
        isActive = false;
        messageHistoryIndex = messageHistory.size();
        currentInputBeforeHistory = "";
    }

    @Override
    public boolean isActive() {
        return isActive;
    }

    @Override
    public Queue<ChatMessage> getMessages() {
        return messages;
    }

    @Override
    public String getPreviousHistoryMessage(String currentText) {
        if (messageHistoryIndex == messageHistory.size()) {
            currentInputBeforeHistory = currentText;
        }

        if (messageHistory.isEmpty()) {
            return currentText;
        }

        if (messageHistoryIndex > 0) {
            messageHistoryIndex--;
            return messageHistory.get(messageHistoryIndex);
        } else {
            return messageHistory.get(0);
        }
    }

    @Override
    public String getNextHistoryMessage() {
        if (messageHistory.isEmpty()) {
            return "";
        }

        if (messageHistoryIndex < messageHistory.size()) {
            messageHistoryIndex++;
        }

        if (messageHistoryIndex == messageHistory.size()) {
            return currentInputBeforeHistory;
        } else {
            return messageHistory.get(messageHistoryIndex);
        }
    }
    public void addListener(ChatListener listener) {
        listeners.add(listener);
    }


    public void removeListener(ChatListener listener) {
        listeners.remove(listener);
    }
}

================
File: main/java/io.github.minemon/chat/service/impl/CommandServiceImpl.java
================
package io.github.minemon.chat.service.impl;

import io.github.minemon.chat.commands.Command;
import io.github.minemon.chat.service.ChatService;
import io.github.minemon.chat.service.CommandService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.service.PlayerService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;

@Service
@Slf4j
public class CommandServiceImpl implements CommandService {
    private final Map<String, Command> commands = new HashMap<>();

    @Override
    public void registerCommand(Command command) {
        commands.put(command.getName().toLowerCase(), command);
        for (String alias : command.getAliases()) {
            commands.put(alias.toLowerCase(), command);
        }
        log.info("Registered command: {}", command.getName());
    }

    @Override
    public boolean executeCommand(String name, String args, PlayerService playerService, ChatService chatService, MultiplayerClient multiplayerClient) {
        Command cmd = commands.get(name.toLowerCase());
        if (cmd == null) {
            return false;
        }
        try {
            if (cmd.isMultiplayerOnly() && !multiplayerClient.isConnected()) {
                chatService.addSystemMessage("This command can only be used in multiplayer.");
                return true;
            }
            cmd.execute(args, playerService, chatService, multiplayerClient);
            return true;
        } catch (Exception e) {
            log.error("Command execution failed: {}", e.getMessage(), e);
            chatService.addSystemMessage("Error executing command: " + e.getMessage());
            return true;
        }
    }
}

================
File: main/java/io.github.minemon/chat/ui/ChatTable.java
================
package io.github.minemon.chat.ui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import io.github.minemon.chat.event.ChatListener;
import io.github.minemon.chat.model.ChatMessage;
import io.github.minemon.chat.service.ChatService;
import lombok.Getter;

public class ChatTable extends Table implements ChatListener {

    private final ChatService chatService;
    private final Skin skin;
    private final ScrollPane messageScroll;
    private final Table messageTable;
    private final TextField inputField;

    @Getter
    private boolean active;

    public ChatTable(Skin skin, ChatService chatService) {
        super(skin);
        this.skin = skin;
        this.chatService = chatService;

        this.chatService.addListener(this);

        setFillParent(false);
        pad(10);

        messageTable = new Table(skin);
        messageTable.top().left();
        messageScroll = new ScrollPane(messageTable, skin);
        messageScroll.setFadeScrollBars(false);
        messageScroll.setScrollingDisabled(true, false);

        TextField.TextFieldStyle textFieldStyle = new TextField.TextFieldStyle(skin.get(TextField.TextFieldStyle.class));
        inputField = new TextField("", textFieldStyle);
        inputField.setMessageText("Press T to chat...");
        inputField.setFocusTraversal(false);

        inputField.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if (!active) return false;
                if (keycode == Input.Keys.ENTER) {
                    String content = inputField.getText().trim();
                    if (!content.isEmpty()) {
                        chatService.sendMessage(content);
                        inputField.setText("");
                    }
                    deactivate();
                    return true;
                } else if (keycode == Input.Keys.ESCAPE) {
                    deactivate();
                    return true;
                } else if (keycode == Input.Keys.UP) {
                    String previousMessage = chatService.getPreviousHistoryMessage(inputField.getText());
                    inputField.setText(previousMessage);
                    inputField.setCursorPosition(previousMessage.length());
                    return true;
                } else if (keycode == Input.Keys.DOWN) {
                    String nextMessage = chatService.getNextHistoryMessage();
                    inputField.setText(nextMessage);
                    inputField.setCursorPosition(nextMessage.length());
                    return true;
                }
                return false;
            }
        });

        row().expand().fill().padBottom(5);
        add(messageScroll).expand().fill().row();

        add(inputField).expandX().fillX().height(30);

        // Initial call to ensure existing messages are displayed
        updateMessages();
    }

    @Override
    public void onNewMessage(ChatMessage msg) {
        Gdx.app.postRunnable(() -> addMessage(msg));
    }

    private void addMessage(ChatMessage msg) {
        Label nameLabel = new Label(msg.getSender() + ": ", skin);
        Label contentLabel = new Label(msg.getContent(), skin);
        contentLabel.setWrap(true);

        Table msgTable = new Table(skin);
        msgTable.left().top();
        msgTable.add(nameLabel).padRight(5);
        msgTable.add(contentLabel).expandX().fillX();

        messageTable.add(msgTable).expandX().fillX().padBottom(2).row();

        // Scroll to the bottom after adding a new message
        messageScroll.layout();
        messageScroll.scrollTo(0, messageTable.getHeight(), 0, 0);
    }

    public void activate() {
        active = true;
        chatService.activateChat();
        inputField.setVisible(true);

        Gdx.app.postRunnable(() -> {
            Stage stage = getStage();
            if (stage != null) {
                stage.setKeyboardFocus(inputField);
            }
        });
    }

    public void deactivate() {
        active = false;
        chatService.deactivateChat();
        inputField.setText("");
        Stage stage = getStage();
        if (stage != null) {
            stage.unfocus(inputField);
        }
    }

    public void updateMessages() {
    }
}

================
File: main/java/io.github.minemon/core/config/GameConfig.java
================
package io.github.minemon.core.config;

import jakarta.annotation.PostConstruct;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import java.util.ArrayList;
import java.util.List;

@Data
@Configuration
@Primary
@ConfigurationProperties(prefix = "game")
public class GameConfig {
    private List<String> motds;

    @PostConstruct
    public void init() {
        if (motds == null) {
            motds = new ArrayList<>();
            motds.add("Welcome to MineMon - Catch them all in an open world!");
            motds.add("Explore, battle, and collect in a vast world!");
            motds.add("New updates coming soon!");
            motds.add("Can you catch them all?");
            motds.add("Adventure awaits in the world of MineMon!");
            motds.add("Become the ultimate trainer!");
            motds.add("Build, battle, explore!");
        }
    }

    public String getRandomMotd() {
        if (motds == null || motds.isEmpty()) {
            init();
        }
        return motds.get((int) (Math.random() * motds.size()));
    }
}

================
File: main/java/io.github.minemon/core/config/GameSettings.java
================
package io.github.minemon.core.config;

import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
public class GameSettings {
    private float musicVolume = 0.7f;
    private float soundVolume = 1.0f;
    private boolean vSync = true;
    private int renderDistance = 8;
    private boolean particles = true;
    private boolean smoothLighting = true;
}

================
File: main/java/io.github.minemon/core/config/ScreenConfig.java
================
package io.github.minemon.core.config;

import com.badlogic.gdx.Game;
import io.github.minemon.audio.service.AudioService;
import io.github.minemon.chat.service.ChatService;
import io.github.minemon.core.screen.*;
import io.github.minemon.core.service.*;
import io.github.minemon.core.service.impl.ScreenManagerImpl;
import io.github.minemon.input.InputService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.multiplayer.service.ServerConnectionService;
import io.github.minemon.player.service.PlayerAnimationService;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.world.biome.service.BiomeService;
import io.github.minemon.world.model.WorldRenderer;
import io.github.minemon.world.service.ChunkLoaderService;
import io.github.minemon.world.service.ChunkPreloaderService;
import io.github.minemon.world.service.WorldService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ScreenConfig {

    @Bean
    public ScreenManager screenManager(ApplicationContext applicationContext, Game game) {
        return new ScreenManagerImpl(applicationContext, game);
    }

    @Bean
    public ChunkPreloaderService chunkPreloaderService(WorldService worldService) {
        return new ChunkPreloaderService(worldService);
    }

    @Bean
    public WorldSelectionScreen worldSelectionScreen(
            AudioService audioService,
            WorldService worldService,
            PlayerService playerService,
            ScreenManager screenManager) {
        return new WorldSelectionScreen(
                audioService,
                worldService,
                screenManager
        );
    }

    @Bean
    public LoginScreen loginScreen(
            AudioService audioService,
            ScreenManager screenManager,
            ServerConnectionService serverConnectionService,
            MultiplayerClient multiplayerClient,
            UiService uiService) {
        return new LoginScreen(
                audioService,
                screenManager,
                serverConnectionService,
                multiplayerClient,
                uiService
        );
    }

    @Bean
    public GameScreen gameScreen(
            PlayerService playerService,
            WorldService worldService,
            AudioService audioService,
            InputService inputService,
            ScreenManager screenManager,
            ChatService chatService,
            BiomeService biomeService,
            WorldRenderer worldRenderer,
            ChunkLoaderService chunkLoaderService,
            ChunkPreloaderService chunkPreloaderService, PlayerAnimationService animationService, MultiplayerClient client) {
        return new GameScreen(
                playerService,
                worldService,
                audioService,
                inputService,
                screenManager,
                chatService,
                biomeService,
                worldRenderer,
                chunkLoaderService,
                chunkPreloaderService, animationService,
                client);
    }

    @Bean
    public ModeSelectionScreen modeSelectionScreen(
            AudioService audioService,
            ScreenManager screenManager,
            GameConfig gameConfig,
            SettingsService settingsService,
            BackgroundService backgroundService) {
        return new ModeSelectionScreen(
                audioService,
                screenManager,
                settingsService,
                backgroundService
        );
    }

    @Bean
    public SettingsScreen settingsScreen(
            ScreenManager screenManager,
            SettingsService settingsService,
            BackgroundService backgroundService) {
        return new SettingsScreen(
                screenManager,
                settingsService,
                backgroundService
        );
    }

    @Bean
    public BackgroundService backgroundService() {
        return new BackgroundService();
    }
}

================
File: main/java/io.github.minemon/core/screen/GameScreen.java
================
package io.github.minemon.core.screen;

import com.badlogic.gdx.*;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.NinePatch;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.minemon.audio.service.AudioService;
import io.github.minemon.chat.service.ChatService;
import io.github.minemon.chat.ui.ChatTable;
import io.github.minemon.core.service.ScreenManager;
import io.github.minemon.input.InputService;
import io.github.minemon.multiplayer.model.PlayerSyncData;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.model.PlayerDirection;
import io.github.minemon.player.service.PlayerAnimationService;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.world.biome.service.BiomeService;
import io.github.minemon.world.model.WorldRenderer;
import io.github.minemon.world.service.ChunkLoaderService;
import io.github.minemon.world.service.ChunkPreloaderService;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Map;

@Component
@Slf4j
public class GameScreen implements Screen {
    private final float TARGET_VIEWPORT_WIDTH_TILES = 24f;
    private final int TILE_SIZE = 32;
    private final PlayerService playerService;
    private final WorldService worldService;
    private final AudioService audioService;
    private final InputService inputService;
    private final ChatService chatService;
    private final BiomeService biomeService;
    private final WorldRenderer worldRenderer;
    private final ChunkLoaderService chunkLoaderService;
    private final ScreenManager screenManager;
    private final ChunkPreloaderService chunkPreloaderService;
    private final MultiplayerClient multiplayerClient;
    private final PlayerAnimationService animationService;
    private OrthographicCamera camera;
    private SpriteBatch batch;
    private BitmapFont font;
    private Stage pauseStage;
    private Skin pauseSkin;
    private Stage hudStage;
    private Skin hudSkin;
    private ChatTable chatTable;
    private boolean showDebug = false;
    private boolean paused = false;
    private float cameraPosX, cameraPosY;
    private Image pauseOverlay;
    private InputMultiplexer multiplexer;

    @Autowired
    public GameScreen(PlayerService playerService,
                      WorldService worldService,
                      AudioService audioService,
                      InputService inputService,
                      ScreenManager screenManager,
                      ChatService chatService,
                      BiomeService biomeService,
                      WorldRenderer worldRenderer,
                      ChunkLoaderService chunkLoaderService,
                      ChunkPreloaderService chunkPreloaderService, PlayerAnimationService animationService, MultiplayerClient client) {
        this.playerService = playerService;
        this.worldService = worldService;
        this.audioService = audioService;
        this.inputService = inputService;
        this.animationService = animationService;
        this.chatService = chatService;
        this.screenManager = screenManager;
        this.biomeService = biomeService;
        this.worldRenderer = worldRenderer;
        this.chunkLoaderService = chunkLoaderService;
        this.multiplayerClient = client;
        this.chunkPreloaderService = chunkPreloaderService;
    }

    @Override
    public void show() {
        log.debug("GameScreen.show() >> current worldName={}, seed={}",
                worldService.getWorldData().getWorldName(),
                worldService.getWorldData().getSeed());

        // Who is the current player?
        PlayerData pd = playerService.getPlayerData().getUsername() != null
                ? playerService.getPlayerData()
                : null;
        if (pd != null) {
            log.debug("Player data: username={}, x={}, y={}",
                    pd.getUsername(), pd.getX(), pd.getY());
        }
        animationService.initAnimationsIfNeeded();
        if (worldRenderer != null) {
            worldRenderer.initialize();
        }

        float baseWidth = TARGET_VIEWPORT_WIDTH_TILES * TILE_SIZE;
        float aspect = (float) Gdx.graphics.getHeight() / (float) Gdx.graphics.getWidth();
        float baseHeight = baseWidth * aspect;

        camera = new OrthographicCamera();
        camera.setToOrtho(false, baseWidth, baseHeight);
        worldService.setCamera(camera);

        batch = new SpriteBatch();
        font = new BitmapFont();

        audioService.playMenuMusic();
        initializeUI();
        initializePlayerPosition();
    }

    private void initializeUI() {
        pauseStage = new Stage(new ScreenViewport());
        pauseSkin = new Skin(Gdx.files.internal("assets/Skins/uiskin.json"));

        pauseOverlay = new Image(new NinePatch(pauseSkin.getSprite("white"), 0, 0, 0, 0));
        pauseOverlay.setColor(new Color(0, 0, 0, 0.6f));
        pauseOverlay.setFillParent(true);
        pauseOverlay.setVisible(false);
        pauseStage.addActor(pauseOverlay);

        setupPauseMenu();

        hudStage = new Stage(new ScreenViewport());
        hudSkin = new Skin(Gdx.files.internal("assets/Skins/uiskin.json"));

        chatTable = new ChatTable(hudSkin, chatService);
        chatTable.setPosition(10, Gdx.graphics.getHeight() - 210);
        chatTable.setSize(400, 200);
        hudStage.addActor(chatTable);

        multiplexer = new InputMultiplexer();
        multiplexer.addProcessor(hudStage);
        multiplexer.addProcessor(inputService);

        Gdx.input.setInputProcessor(multiplexer);
    }

    private void setupPauseMenu() {
        Window.WindowStyle windowStyle = new Window.WindowStyle();
        windowStyle.titleFont = pauseSkin.getFont("default-font");
        windowStyle.titleFontColor = Color.WHITE;
        windowStyle.background = pauseSkin.newDrawable("white", new Color(0, 0, 0, 0.7f));

        Window pauseWindow = new Window("Paused", windowStyle);
        pauseWindow.setModal(true);
        pauseWindow.setMovable(false);

        TextButton resumeButton = new TextButton("Resume", pauseSkin);
        TextButton settingsButton = new TextButton("Settings", pauseSkin);
        TextButton exitButton = new TextButton("Exit to Menu", pauseSkin);

        resumeButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                togglePause();
            }
        });

        settingsButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                screenManager.showScreen(SettingsScreen.class);
            }
        });

        exitButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                screenManager.showScreen(ModeSelectionScreen.class);
            }
        });

        pauseWindow.row().pad(10);
        pauseWindow.add(resumeButton).width(180).height(40).pad(5).row();
        pauseWindow.add(settingsButton).width(180).height(40).pad(5).row();
        pauseWindow.add(exitButton).width(180).height(40).pad(5).row();

        pauseWindow.pack();
        pauseWindow.setPosition(
                (pauseStage.getViewport().getWorldWidth() - pauseWindow.getWidth()) / 2f,
                (pauseStage.getViewport().getWorldHeight() - pauseWindow.getHeight()) / 2f
        );
        pauseWindow.setVisible(false);

        pauseStage.addActor(pauseWindow);
        pauseOverlay.setUserObject(pauseWindow);
    }

    private void togglePause() {
        paused = !paused;
        Window pauseWindow = (Window) pauseOverlay.getUserObject();
        pauseOverlay.setVisible(paused);
        pauseWindow.setVisible(paused);

        if (paused) {
            multiplexer.addProcessor(0, pauseStage);


            worldService.saveWorldData();
        } else {
            multiplexer.removeProcessor(pauseStage);
        }
    }

    private void initializePlayerPosition() {
        String playerName = playerService.getPlayerData().getUsername();
        PlayerData pd = worldService.getPlayerData(playerName);
        log.debug("initializePlayerPosition -> from worldService: username={}, x={}, y={}",
                pd != null ? pd.getUsername() : "(null)",
                pd != null ? pd.getX() : 0f,
                pd != null ? pd.getY() : 0f);

        if (pd == null) {
            pd = new PlayerData(playerName, 0, 0);
            playerService.setPlayerData(pd);
            log.debug("No existing PD => created new at (0,0)");
        } else {
            log.debug("Setting position to PD's tile coords = ({}, {})", (int) pd.getX(), (int) pd.getY());
            playerService.setPosition((int) pd.getX(), (int) pd.getY());
        }

        float playerPixelX = pd.getX() * TILE_SIZE + TILE_SIZE / 2f;
        float playerPixelY = pd.getY() * TILE_SIZE + TILE_SIZE / 2f;
        cameraPosX = playerPixelX;
        cameraPosY = playerPixelY;
        camera.position.set(cameraPosX, cameraPosY, 0);
        camera.update();
    }




    @Override
    public void render(float delta) {
        handleInput();
        updateGame(delta);
        preloadChunksAhead();
        renderGame(delta);
    }

    private void handleInput() {
        if (Gdx.input.isKeyJustPressed(Input.Keys.F3)) {
            showDebug = !showDebug;
        }

        if (!chatService.isActive() && Gdx.input.isKeyJustPressed(Input.Keys.T)) {
            chatTable.activate();
        }

        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            if (chatService.isActive()) {
                chatTable.deactivate();
            } else {
                togglePause();
            }
        }
    }

    private void preloadChunksAhead() {
        PlayerData player = playerService.getPlayerData();
        float px = player.getX() * TILE_SIZE;
        float py = player.getY() * TILE_SIZE;
        chunkPreloaderService.preloadAround(px, py);
    }

    private void updateGame(float delta) {
        if (!paused) {
            PlayerData player = playerService.getPlayerData();
            updateCamera();
            chunkLoaderService.updatePlayerPosition(
                    player.getX() * TILE_SIZE,
                    player.getY() * TILE_SIZE
            );
            playerService.update(delta);

        }

        pauseStage.act(delta);
        hudStage.act(delta);
    }


    private void renderGame(float delta) {
        // Clear
        Gdx.gl.glClearColor(0, 0, 0, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        // Draw world
        worldRenderer.render(camera, delta);

        // 1) Draw local player
        batch.setProjectionMatrix(camera.combined);
        batch.begin();
        playerService.render(batch);

        // 2) Draw remote players with updated animation time
        // In renderGame:
        Map<String, PlayerSyncData> states = multiplayerClient.getPlayerStates();
        String localUsername = playerService.getPlayerData().getUsername();

        for (Map.Entry<String, PlayerSyncData> entry : states.entrySet()) {
            String otherUsername = entry.getKey();
            // Skip local
            if (otherUsername.equals(localUsername)) continue;

            PlayerSyncData psd = entry.getValue();

            // If the remote is moving, increment their local animation timer
            if (psd.isMoving()) {
                psd.setAnimationTime(psd.getAnimationTime() + delta);
            }

            float px = psd.getX() * TILE_SIZE;
            float py = psd.getY() * TILE_SIZE;

            PlayerDirection dir = PlayerDirection.DOWN;
            try {
                dir = PlayerDirection.valueOf(psd.getDirection().toUpperCase());
            } catch (Exception ignored) {}

            // We pass 'psd.isMoving()' to get the correct standing vs. walking/running frames
            TextureRegion frame = animationService.getCurrentFrame(
                    dir,
                    psd.isMoving(),
                    psd.isRunning(),
                    psd.getAnimationTime()
            );
            batch.draw(frame, px, py);
        }


        batch.end();

        // Additional layered rendering if needed
        worldRenderer.renderTreeTops(delta);

        // Draw pause overlay if paused
        if (paused) {
            pauseStage.draw();
        }

        hudStage.act(delta);
        hudStage.draw();

        // Optional debug info
        if (showDebug) {
            renderDebugInfo();
        }
    }

    private void updateCamera() {
        float playerPixelX = playerService.getPlayerData().getX() * TILE_SIZE + TILE_SIZE / 2f;
        float playerPixelY = playerService.getPlayerData().getY() * TILE_SIZE + TILE_SIZE / 2f;

        cameraPosX = lerp(cameraPosX, playerPixelX);
        cameraPosY = lerp(cameraPosY, playerPixelY);

        camera.position.set(cameraPosX, cameraPosY, 0);
        camera.update();
    }

    private void renderDebugInfo() {
        batch.setProjectionMatrix(hudStage.getCamera().combined);
        batch.begin();

        PlayerData player = playerService.getPlayerData();
        final int TILE_SIZE = 32;
        final int CHUNK_SIZE = 16;
        final int WORLD_WIDTH_TILES = 100000;
        final int WORLD_HEIGHT_TILES = 100000;

        float pixelX = player.getX() * TILE_SIZE;
        float pixelY = player.getY() * TILE_SIZE;
        int tileX = (int) player.getX();
        int tileY = (int) player.getY();
        int chunkX = tileX / CHUNK_SIZE;
        int chunkY = tileY / CHUNK_SIZE;
        int totalChunksX = WORLD_WIDTH_TILES / CHUNK_SIZE;
        int totalChunksY = WORLD_HEIGHT_TILES / CHUNK_SIZE;

        font.setColor(Color.WHITE);
        float y = 25;

        font.draw(batch, "FPS: " + Gdx.graphics.getFramesPerSecond(), 10, y);
        y += 20;
        font.draw(batch, String.format("Pixel Pos: (%.1f, %.1f)", pixelX, pixelY), 10, y);
        y += 20;
        font.draw(batch, String.format("Tile Pos: (%d, %d)", tileX, tileY), 10, y);
        y += 20;
        font.draw(batch, String.format("Chunk Pos: (%d, %d)", chunkX, chunkY), 10, y);
        y += 20;
        font.draw(batch, String.format("Total Tiles: %d x %d", WORLD_WIDTH_TILES, WORLD_HEIGHT_TILES), 10, y);
        y += 20;
        font.draw(batch, String.format("Total Chunks: %d x %d", totalChunksX, totalChunksY), 10, y);
        y += 20;
        font.draw(batch, "Biome: " + getBiomeName(pixelX, pixelY), 10, y);
        y += 20;
        font.draw(batch, "Direction: " + player.getDirection(), 10, y);

        batch.end();
    }

    private String getBiomeName(float pixelX, float pixelY) {
        var biomeResult = biomeService.getBiomeAt(pixelX, pixelY);
        return biomeResult.getPrimaryBiome() != null ? biomeResult.getPrimaryBiome().getName() : "Unknown";
    }

    private float lerp(float a, float b) {
        float CAMERA_LERP_FACTOR = 0.1f;
        return a + (b - a) * CAMERA_LERP_FACTOR;
    }

    @Override
    public void resize(int width, int height) {
        camera.viewportWidth = TARGET_VIEWPORT_WIDTH_TILES * TILE_SIZE;
        camera.viewportHeight = camera.viewportWidth * ((float) height / width);
        camera.update();

        pauseStage.getViewport().update(width, height, true);
        hudStage.getViewport().update(width, height, true);

        if (chatTable != null) {
            chatTable.setPosition(10, height - 210);
        }

        if (pauseOverlay != null && pauseOverlay.isVisible()) {
            Window pauseWindow = (Window) pauseOverlay.getUserObject();
            if (pauseWindow != null) {
                pauseWindow.pack();
                pauseWindow.setPosition(
                        (pauseStage.getViewport().getWorldWidth() - pauseWindow.getWidth()) / 2f,
                        (pauseStage.getViewport().getWorldHeight() - pauseWindow.getHeight()) / 2f
                );
            }
        }
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void hide() {
    }


    @Override
    public void dispose() {

        worldService.saveWorldData();

        batch.dispose();
        font.dispose();
        pauseStage.dispose();
        hudStage.dispose();
        pauseSkin.dispose();
        hudSkin.dispose();
        worldRenderer.dispose();
        chunkLoaderService.dispose();
        chunkPreloaderService.dispose();
    }
}

================
File: main/java/io.github.minemon/core/screen/LoginScreen.java
================
package io.github.minemon.core.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.*;
import com.badlogic.gdx.utils.Scaling;
import com.badlogic.gdx.utils.viewport.ExtendViewport;
import io.github.minemon.audio.service.AudioService;
import io.github.minemon.core.service.ScreenManager;
import io.github.minemon.core.service.UiService;
import io.github.minemon.core.ui.ServerConfigDialog;
import io.github.minemon.multiplayer.model.ServerConnectionConfig;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.multiplayer.service.ServerConnectionService;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.world.service.WorldService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

@Component
public class LoginScreen implements Screen, MultiplayerClient.LoginResponseListener, MultiplayerClient.CreateUserResponseListener {

    private static final float MIN_WIDTH = 800;
    private static final float MIN_HEIGHT = 480;
    private static final String BACKGROUND_PATH = "assets/Textures/UI/ethereal.png";

    private final AudioService audioService;
    private final ScreenManager screenManager;
    private final ServerConnectionService serverConnectionService;
    private final MultiplayerClient multiplayerClient;
    private final UiService uiService;

    @Autowired
    private PlayerService playerService;

    private Stage stage;
    private Skin skin;
    private ServerListView serverListView;
    private Table root;
    private Dialog connectingDialog;
    private Dialog loginDialog;

    @Autowired
    public LoginScreen(
            AudioService audioService,
            ScreenManager screenManager,
            ServerConnectionService serverConnectionService,
            MultiplayerClient multiplayerClient,
            UiService uiService) {
        this.audioService = audioService;
        this.screenManager = screenManager;
        this.serverConnectionService = serverConnectionService;
        this.multiplayerClient = multiplayerClient;
        this.uiService = uiService;
    }

    @Override
    public void show() {
        stage = new Stage(new ExtendViewport(MIN_WIDTH, MIN_HEIGHT));
        uiService.initialize();
        uiService.getDialogFactory().setStage(stage);
        skin = uiService.getSkin();
        Gdx.input.setInputProcessor(stage);

        audioService.playMenuMusic();

        createUI();
        setupInputHandling();
    }
    @Autowired
    private WorldService worldService;

    private void createUI() {
        setBackground();

        root = new Table(skin);
        root.setFillParent(true);
        stage.addActor(root);

        Table topBar = new Table(skin);
        topBar.setBackground(uiService.getStyleFactory().createPanelBackground());
        topBar.pad(10);

        TextButton backButton = createSimpleButton("Back to Menu", this::handleBack);
        topBar.add(backButton).left().padRight(20);

        Label titleLabel = uiService.getStyleFactory().createTitleLabel("PokMeetup Server List", skin);
        topBar.add(titleLabel).expandX().center();
        topBar.add().width(100);

        root.add(topBar).expandX().fillX().row();

        Table headerRow = new Table(skin);
        headerRow.setBackground(skin.newDrawable("white", 0.2f, 0.2f, 0.2f, 0.8f));
        headerRow.pad(10);
        Label nameHeader = new Label("Server Name", skin);
        nameHeader.setColor(Color.GOLD);
        Label playersHeader = new Label("Players", skin);
        playersHeader.setColor(Color.GOLD);

        headerRow.add(nameHeader).expandX().left().padLeft(80);
        headerRow.add(playersHeader).width(100).right().padRight(10);

        root.add(headerRow).expandX().fillX().height(40).row();

        serverListView = new ServerListView(skin, loadServers());
        ScrollPane scrollPane = new ScrollPane(serverListView, skin);
        scrollPane.setFadeScrollBars(false);
        scrollPane.setScrollingDisabled(true, false);
        scrollPane.setForceScroll(false, true);
        scrollPane.setSmoothScrolling(true);

        Table serverContainer = new Table(skin);
        serverContainer.setBackground(uiService.getStyleFactory().createPanelBackground());
        serverContainer.add(scrollPane).expand().fill().pad(15);

        root.add(serverContainer).expand().fill().pad(20).row();

        Table buttonPanel = new Table(skin);
        buttonPanel.setBackground(uiService.getStyleFactory().createPanelBackground());
        buttonPanel.pad(10);

        float buttonWidth = 150;
        float buttonHeight = 50;

        TextButton joinButton = createSimpleButton("Join Server", this::handleJoinServer);
        TextButton addButton = createSimpleButton("Add Server", this::handleAddServer);
        TextButton editButton = createSimpleButton("Edit Server", this::handleEditServer);
        TextButton deleteButton = createSimpleButton("Delete Server", this::handleDeleteServer);

        buttonPanel.add(joinButton).width(buttonWidth).height(buttonHeight).pad(10);
        buttonPanel.add(addButton).width(buttonWidth).height(buttonHeight).pad(10);
        buttonPanel.add(editButton).width(buttonWidth).height(buttonHeight).pad(10);
        buttonPanel.add(deleteButton).width(buttonWidth).height(buttonHeight).pad(10);

        root.add(buttonPanel).expandX().fillX().padBottom(20);
    }

    private void setBackground() {
        Texture bgTexture = new Texture(Gdx.files.internal(BACKGROUND_PATH));
        Image backgroundImage = new Image(new TextureRegionDrawable(bgTexture));
        backgroundImage.setFillParent(true);
        backgroundImage.setScaling(Scaling.fill);
        backgroundImage.setTouchable(Touchable.disabled);
        stage.addActor(backgroundImage);
    }

    private TextButton createSimpleButton(String text, Runnable action) {
        TextButton button = uiService.getStyleFactory().createGameButton(text, skin);

        final Color NORMAL_COLOR = Color.WHITE;
        final Color HOVER_COLOR = new Color(0.9f, 0.9f, 0.9f, 1f);
        final Color PRESSED_COLOR = new Color(0.8f, 0.8f, 0.8f, 1f);

        button.setColor(NORMAL_COLOR);

        button.addListener(new InputListener() {
            boolean pressed = false;

            @Override
            public boolean touchDown(InputEvent event, float x, float y, int pointer, int buttonCode) {
                button.setColor(PRESSED_COLOR);
                pressed = true;
                return true;
            }

            @Override
            public void touchUp(InputEvent event, float x, float y, int pointer, int buttonCode) {
                if (pressed) {
                    if (x >= 0 && x <= button.getWidth() && y >= 0 && y <= button.getHeight()) {
                        action.run();
                        button.setColor(HOVER_COLOR);
                    } else {
                        button.setColor(NORMAL_COLOR);
                    }
                    pressed = false;
                }
            }

            @Override
            public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {
                if (!pressed) {
                    button.setColor(HOVER_COLOR);
                }
            }

            @Override
            public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {
                if (!pressed) {
                    button.setColor(NORMAL_COLOR);
                }
            }
        });

        return button;
    }

    private void handleBack() {
        screenManager.goBack();
    }

    private void handleJoinServer() {
        ServerConnectionConfig selected = serverListView.getSelected();
        if (selected == null) {
            uiService.getDialogFactory().showWarning("No Server Selected", "Please select a server to join.");
            return;
        }
        showLoginDialog(selected);
    }

    private void showLoginDialog(ServerConnectionConfig config) {
        if (loginDialog != null && loginDialog.isVisible()) {
            loginDialog.hide();
        }

        String prefillUsername = config.isRememberMe() ? config.getSavedUsername() : "";
        String prefillPassword = config.isRememberMe() ? config.getSavedPassword() : "";

        Window.WindowStyle windowStyle = skin.get(Window.WindowStyle.class);
        loginDialog = new Dialog("Login to " + config.getServerName(), windowStyle);
        loginDialog.pad(20);

        TextField usernameField = new TextField(prefillUsername, skin);
        usernameField.setMessageText("Username");
        TextField passwordField = new TextField(prefillPassword, skin);
        passwordField.setMessageText("Password");
        passwordField.setPasswordCharacter('*');
        passwordField.setPasswordMode(true);

        CheckBox rememberMeCheck = new CheckBox(" Remember Me", skin);
        rememberMeCheck.setChecked(config.isRememberMe());

        Table contentTable = loginDialog.getContentTable();
        contentTable.add(new Label("Username:", skin)).left().pad(5);
        contentTable.row();
        contentTable.add(usernameField).width(200).pad(5);
        contentTable.row();
        contentTable.add(new Label("Password:", skin)).left().pad(5);
        contentTable.row();
        contentTable.add(passwordField).width(200).pad(5);
        contentTable.row();
        contentTable.add(rememberMeCheck).pad(5);

        TextButton loginButton = new TextButton("Login", skin);
        TextButton createButton = new TextButton("Create Account", skin);
        TextButton cancelButton = new TextButton("Cancel", skin);

        loginButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                String user = usernameField.getText().trim();
                String pass = passwordField.getText();
                boolean rm = rememberMeCheck.isChecked();
                if (user.isEmpty() || pass.isEmpty()) {
                    uiService.getDialogFactory().showWarning("Invalid Input", "Username and password cannot be empty.");
                    return;
                }

                config.setRememberMe(rm);
                if (rm) {
                    config.setSavedUsername(user);
                    config.setSavedPassword(pass);
                } else {
                    config.setSavedUsername("");
                    config.setSavedPassword("");
                }
                serverConnectionService.saveConfig(config);

                loginDialog.hide();
                if (!multiplayerClient.isConnected()) {
                    // Set pending action to login after connecting
                    multiplayerClient.setPendingLoginRequest(() -> multiplayerClient.login(user, pass));
                    connectToServer(config);
                } else {
                    multiplayerClient.login(user, pass);
                }
            }
        });

        createButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                showCreateAccountDialog(config);
                loginDialog.hide();
            }
        });

        cancelButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                loginDialog.hide();
            }
        });

        loginDialog.button(loginButton);
        loginDialog.button(createButton);
        loginDialog.button(cancelButton);

        loginDialog.show(stage);
    }

    private void showCreateAccountDialog(ServerConnectionConfig config) {
        Dialog createDialog = new Dialog("Create Account for " + config.getServerName(), skin);
        createDialog.pad(20);

        TextField usernameField = new TextField("", skin);
        usernameField.setMessageText("Username");
        TextField passwordField = new TextField("", skin);
        passwordField.setMessageText("Password");
        passwordField.setPasswordCharacter('*');
        passwordField.setPasswordMode(true);

        TextField confirmField = new TextField("", skin);
        confirmField.setMessageText("Confirm Password");
        confirmField.setPasswordCharacter('*');
        confirmField.setPasswordMode(true);

        Table contentTable = createDialog.getContentTable();
        contentTable.add(new Label("Username:", skin)).left().pad(5);
        contentTable.row();
        contentTable.add(usernameField).width(200).pad(5);
        contentTable.row();
        contentTable.add(new Label("Password:", skin)).left().pad(5);
        contentTable.row();
        contentTable.add(passwordField).width(200).pad(5);
        contentTable.row();
        contentTable.add(new Label("Confirm Password:", skin)).left().pad(5);
        contentTable.row();
        contentTable.add(confirmField).width(200).pad(5);

        TextButton createBtn = new TextButton("Create", skin);
        TextButton cancelBtn = new TextButton("Cancel", skin);

        createBtn.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                String user = usernameField.getText().trim();
                String pass = passwordField.getText();
                String conf = confirmField.getText();
                if (user.isEmpty() || pass.isEmpty()) {
                    uiService.getDialogFactory().showWarning("Invalid Input", "Username and password cannot be empty.");
                    return;
                }
                if (!pass.equals(conf)) {
                    uiService.getDialogFactory().showWarning("Mismatch", "Passwords do not match.");
                    return;
                }

                createDialog.hide();
                if (!multiplayerClient.isConnected()) {
                    // Connect first, then send CreateUserRequest
                    multiplayerClient.setPendingCreateUserRequest(() -> multiplayerClient.createUser(user, pass));
                    connectToServer(config);
                } else {
                    // Already connected, send CreateUserRequest directly
                    multiplayerClient.createUser(user, pass);
                }
            }
        });

        cancelBtn.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                createDialog.hide();
            }
        });

        createDialog.button(createBtn);
        createDialog.button(cancelBtn);

        createDialog.show(stage);
    }

    private void connectToServer(ServerConnectionConfig config) {
        connectingDialog = uiService.getDialogFactory().showLoading("Connecting to " + config.getServerName());
        multiplayerClient.setLoginResponseListener(this);
        multiplayerClient.setCreateUserResponseListener(this);

        // Set multiplayer mode before connecting
        worldService.setMultiplayerMode(true);

        multiplayerClient.connect(config.getServerIP(), config.getTcpPort(), config.getUdpPort());
    }

    @Override
    public void onLoginResponse(boolean success, String message, String username, int startX, int startY) {
        Gdx.app.postRunnable(() -> {
            if (connectingDialog != null) {
                connectingDialog.hide();
            }

            // Check if we got disconnected
            if (!success && message != null && message.contains("Disconnected")) {
                // Return to login screen
                screenManager.showScreen(LoginScreen.class);
                return;
            }

            if (success) {
                PlayerData pd = playerService.getPlayerData();
                pd.setUsername(username);
                pd.setX(startX);
                pd.setY(startY);
                playerService.setPlayerData(pd);

                uiService.getDialogFactory().showSuccess("Connected", message);
                screenManager.showScreen(GameScreen.class);
            } else {
                uiService.getDialogFactory().showError("Connection Failed", message);
            }
        });
    }


    private void handleAddServer() {
        ServerConfigDialog dialog = new ServerConfigDialog(
                skin,
                uiService.getDialogFactory(),
                null,
                config -> {
                    serverConnectionService.addServer(config);
                    refreshServerList();
                    uiService.getDialogFactory().showSuccess("Server Added", "Server successfully added!");
                }
        );
        dialog.show(stage);
    }

    private void handleEditServer() {
        ServerConnectionConfig selected = serverListView.getSelected();
        if (selected == null) {
            uiService.getDialogFactory().showWarning("No Server Selected", "Please select a server to edit.");
            return;
        }

        ServerConfigDialog dialog = new ServerConfigDialog(
                skin,
                uiService.getDialogFactory(),
                selected,
                config -> {
                    serverConnectionService.saveConfig(config);
                    refreshServerList();
                    uiService.getDialogFactory().showSuccess("Server Updated", "Server successfully updated!");
                }
        );
        dialog.show(stage);
    }

    private void handleDeleteServer() {
        ServerConnectionConfig selected = serverListView.getSelected();
        if (selected == null) {
            uiService.getDialogFactory().showWarning("No Server Selected", "Please select a server to delete.");
            return;
        }

        uiService.getDialogFactory().showConfirmation(
                "Delete Server",
                "Are you sure you want to delete '" + selected.getServerName() + "'?",
                () -> {
                    serverConnectionService.deleteServer(selected);
                    refreshServerList();
                }
        );
    }

    private List<ServerConnectionConfig> loadServers() {
        return new ArrayList<>(serverConnectionService.listServers());
    }

    private void refreshServerList() {
        serverListView.setServers(loadServers());
    }

    private void setupInputHandling() {
        stage.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if (keycode == Input.Keys.ESCAPE) {
                    handleBack();
                    return true;
                }
                return false;
            }
        });
    }

    @Override
    public void render(float delta) {
        Gdx.gl.glClearColor(0, 0, 0, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        stage.act(delta);
        stage.draw();
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
        root.invalidateHierarchy();
        root.layout();
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void hide() {
        audioService.stopMenuMusic();
    }

    @Override
    public void dispose() {
        stage.dispose();
    }

    @Override
    public void onCreateUserResponse(boolean success, String message) {
        Gdx.app.postRunnable(() -> {
                    if (connectingDialog != null) {
                        connectingDialog.hide();
                    }

                    if (success) {
                        uiService.getDialogFactory().showSuccess("Account Created", message);
                    } else {
                        uiService.getDialogFactory().showError("Registration Failed", message);
                    }
                }
        );
    }

}

================
File: main/java/io.github.minemon/core/screen/ModeSelectionScreen.java
================
package io.github.minemon.core.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.minemon.audio.service.AudioService;
import io.github.minemon.core.service.BackgroundService;
import io.github.minemon.core.service.ScreenManager;
import io.github.minemon.core.service.SettingsService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;


@Component
@RequiredArgsConstructor
public class ModeSelectionScreen implements Screen {
    private final AudioService audioService;
    private final ScreenManager screenManager;
    private final SettingsService settingsService;
    private final BackgroundService backgroundAnimation;

    private Stage stage;
    private Skin skin;
    private Window settingsWindow;

    @Override
    public void show() {
        audioService.playMenuMusic();
        backgroundAnimation.initialize();

        stage = new Stage(new ScreenViewport());
        Gdx.input.setInputProcessor(stage);
        skin = new Skin(Gdx.files.internal("assets/Skins/uiskin.json"));

        createMainMenu();
        createSettingsWindow();
    }

    private void createMainMenu() {
        Table mainTable = new Table();
        mainTable.setFillParent(true);


        Label titleLabel = new Label("MineMon", skin);
        titleLabel.setFontScale(2.0f);


        Label versionLabel = new Label("Version 1.0", skin);


        TextButton singlePlayerButton = createStyledButton("Single Player");
        TextButton multiplayerButton = createStyledButton("Multiplayer");
        TextButton settingsButton = createStyledButton("Settings");
        TextButton exitButton = createStyledButton("Exit Game");


        Label motdLabel = new Label("Welcome to MineMon - Catch them all in an open world!", skin);
        motdLabel.setWrap(true);


        mainTable.add(titleLabel).pad(50).row();
        mainTable.add(versionLabel).padBottom(20).row();
        mainTable.add(motdLabel).width(400).pad(20).row();
        mainTable.add(singlePlayerButton).width(300).pad(10).row();
        mainTable.add(multiplayerButton).width(300).pad(10).row();
        mainTable.add(settingsButton).width(300).pad(10).row();
        mainTable.add(exitButton).width(300).pad(10).row();


        singlePlayerButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                screenManager.showScreen(WorldSelectionScreen.class);
            }
        });

        multiplayerButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                screenManager.showScreen(LoginScreen.class);
            }
        });

        settingsButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                toggleSettingsWindow();
            }
        });

        exitButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                Gdx.app.exit();
            }
        });

        stage.addActor(mainTable);
    }

    private TextButton createStyledButton(String text) {
        TextButton button = new TextButton(text, skin);
        button.addListener(new ClickListener() {
            @Override
            public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {
                button.setColor(1, 1, 0.8f, 1);
            }

            @Override
            public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {
                button.setColor(1, 1, 1, 1);
            }
        });
        return button;
    }

    private void createSettingsWindow() {
        settingsWindow = new Window("Settings", skin);
        settingsWindow.setVisible(false);
        settingsWindow.setModal(true);


        Label musicLabel = new Label("Music Volume:", skin);
        Slider musicSlider = new Slider(0, 1, 0.1f, false, skin);
        musicSlider.setValue(settingsService.getMusicVolume());
        musicSlider.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                settingsService.setMusicVolume(musicSlider.getValue());
            }
        });


        Label soundLabel = new Label("Sound Volume:", skin);
        Slider soundSlider = new Slider(0, 1, 0.1f, false, skin);
        soundSlider.setValue(settingsService.getSoundVolume());
        soundSlider.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                settingsService.setSoundVolume(soundSlider.getValue());
            }
        });


        CheckBox vsyncCheck = new CheckBox(" VSync", skin);
        vsyncCheck.setChecked(settingsService.getVSync());
        vsyncCheck.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                settingsService.setVSync(vsyncCheck.isChecked());
                Gdx.graphics.setVSync(vsyncCheck.isChecked());
            }
        });


        TextButton closeButton = new TextButton("Close", skin);
        closeButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                settingsWindow.setVisible(false);
            }
        });


        Table settingsTable = new Table();
        settingsTable.add(musicLabel).pad(10);
        settingsTable.add(musicSlider).width(200).pad(10).row();
        settingsTable.add(soundLabel).pad(10);
        settingsTable.add(soundSlider).width(200).pad(10).row();
        settingsTable.add(vsyncCheck).colspan(2).pad(10).row();
        settingsTable.add(closeButton).colspan(2).pad(10);

        settingsWindow.add(settingsTable);
        settingsWindow.pack();
        settingsWindow.setPosition(
                (stage.getWidth() - settingsWindow.getWidth()) / 2,
                (stage.getHeight() - settingsWindow.getHeight()) / 2
        );

        stage.addActor(settingsWindow);
    }

    private void toggleSettingsWindow() {
        settingsWindow.setVisible(!settingsWindow.isVisible());
    }

    @Override
    public void render(float delta) {
        Gdx.gl.glClearColor(0.1f, 0.1f, 0.1f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        backgroundAnimation.render(false);

        stage.act(delta);
        stage.draw();
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
        settingsWindow.setPosition(
                (width - settingsWindow.getWidth()) / 2,
                (height - settingsWindow.getHeight()) / 2
        );
    }

    @Override
    public void pause() {}

    @Override
    public void resume() {}

    @Override
    public void hide() {
        audioService.stopMenuMusic();
    }

    @Override
    public void dispose() {
        stage.dispose();
        skin.dispose();
        backgroundAnimation.dispose();
    }
}

================
File: main/java/io.github.minemon/core/screen/ServerListView.java
================
package io.github.minemon.core.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import io.github.minemon.multiplayer.model.ServerConnectionConfig;
import lombok.Getter;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class ServerListView extends Table {
    private static final float ROW_HEIGHT = 80f;
    private static final float ICON_SIZE = 48f;
    private static final float PADDING = 10f;
    private static final String DEFAULT_ICON_PATH = "assets/icons/default-server-icon.png";
    private static final String DEFAULT_MOTD = "No message of the day provided.";

    private final Skin skin;
    private final List<ServerConnectionConfig> servers;
    private final ButtonGroup<TextButton> buttonGroup;

    @Getter
    private ServerConnectionConfig selected;

    public ServerListView(Skin skin, List<ServerConnectionConfig> servers) {
        super(skin);
        this.skin = skin;
        this.servers = new ArrayList<>(servers);
        this.buttonGroup = new ButtonGroup<>();
        buttonGroup.setMaxCheckCount(1);
        buttonGroup.setMinCheckCount(0);
        buttonGroup.setUncheckLast(true);

        setFillParent(true);
        rebuild();
    }

    private void rebuild() {
        clear();
        buttonGroup.clear();



        for (ServerConnectionConfig server : servers) {
            createServerRow(server);
        }

        if (servers.isEmpty()) {
            Label noServersLabel = new Label("No servers added yet.", skin);
            noServersLabel.setColor(Color.LIGHT_GRAY);
            add(noServersLabel).pad(20).center().row();
        }

        pack();
    }

    private void createServerRow(ServerConnectionConfig server) {
        final Color normalColor = new Color(0.2f, 0.2f, 0.2f, 1f);
        final Color hoverColor = new Color(0.3f, 0.3f, 0.3f, 1f);
        final Color selectedColor = new Color(0.4f, 0.6f, 0.9f, 0.7f);

        Table rowTable = new Table(skin);
        rowTable.setBackground(skin.newDrawable("white", normalColor));

        Image icon = createServerIcon(server);
        rowTable.add(icon).size(ICON_SIZE).pad(PADDING);

        Table infoTable = new Table(skin);
        Label nameLabel = new Label(server.getServerName(), skin);
        nameLabel.setColor(Color.WHITE);

        Label motdLabel = new Label(getMotd(server), skin);
        motdLabel.setWrap(true);
        motdLabel.setColor(new Color(0.8f, 0.8f, 0.8f, 1f));

        infoTable.add(nameLabel).left().expandX().row();
        infoTable.add(motdLabel).left().expandX().padTop(5).width(400);

        rowTable.add(infoTable).expandX().fillX().pad(PADDING);

        Table playerCountTable = new Table(skin);
        playerCountTable.setBackground(skin.newDrawable("white", new Color(0.2f, 0.2f, 0.2f, 0.7f)));
        Label playersLabel = new Label(
                String.format("%d/%d", server.getCurrentPlayers(), server.getMaxPlayers()),
                skin
        );
        playersLabel.setColor(Color.WHITE);
        playerCountTable.add(playersLabel).pad(5);
        rowTable.add(playerCountTable).right().padRight(PADDING);

        TextButton rowButton = new TextButton("", skin);
        rowButton.add(rowTable).expand().fill();

        rowButton.addListener(new ClickListener() {
            @Override
            public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {
                if (!rowButton.isChecked()) {
                    rowTable.setBackground(skin.newDrawable("white", hoverColor));
                }
            }

            @Override
            public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {
                if (!rowButton.isChecked()) {
                    rowTable.setBackground(skin.newDrawable("white", normalColor));
                }
            }

            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (rowButton.isChecked()) {
                    selected = server;
                    rowTable.setBackground(skin.newDrawable("white", selectedColor));
                } else {
                    if (selected == server) selected = null;
                    rowTable.setBackground(skin.newDrawable("white", normalColor));
                }
            }
        });

        buttonGroup.add(rowButton);

        add(rowButton).expandX().fillX().height(ROW_HEIGHT).padBottom(2).row();
    }

    private Image createServerIcon(ServerConnectionConfig server) {
        String iconPath = server.getIconPath();
        if (iconPath == null || iconPath.trim().isEmpty() || !new File(iconPath).exists()) {
            iconPath = DEFAULT_ICON_PATH;
        }
        return new Image(new Texture(Gdx.files.internal(iconPath)));
    }

    private String getMotd(ServerConnectionConfig server) {
        String motd = server.getMotd();
        return (motd == null || motd.trim().isEmpty()) ? DEFAULT_MOTD : motd;
    }

    public void setServers(List<ServerConnectionConfig> newServers) {
        servers.clear();
        servers.addAll(newServers);
        selected = null;
        rebuild();
    }
}

================
File: main/java/io.github.minemon/core/screen/SettingsScreen.java
================
package io.github.minemon.core.screen;

import com.badlogic.gdx.*;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.minemon.core.service.BackgroundService;
import io.github.minemon.core.service.ScreenManager;
import io.github.minemon.core.service.SettingsService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class SettingsScreen implements Screen {
    private final ScreenManager screenManager;
    private final SettingsService settingsService;
    private final BackgroundService backgroundService;

    private Stage stage;
    private Skin skin;
    private Window settingsWindow;
    private boolean isGameScreen;

    @Override
    public void show() {
        stage = new Stage(new ScreenViewport());
        skin = new Skin(Gdx.files.internal("assets/Skins/uiskin.json"));


        isGameScreen = screenManager.getPreviousScreen() instanceof GameScreen;

        createSettingsWindow();


        InputMultiplexer multiplexer = new InputMultiplexer();
        multiplexer.addProcessor(stage);
        multiplexer.addProcessor(new InputAdapter() {
            @Override
            public boolean keyDown(int keycode) {
                if (keycode == Input.Keys.ESCAPE) {
                    goBack();
                    return true;
                }
                return false;
            }
        });
        Gdx.input.setInputProcessor(multiplexer);
    }

    private void createSettingsWindow() {
        settingsWindow = new Window("Settings", skin);
        settingsWindow.setMovable(false);
        settingsWindow.setKeepWithinStage(true);

        Table content = new Table(skin);
        content.defaults().pad(5).spaceBottom(10);


        content.add("Audio Settings").colspan(2).align(Align.left).row();
        addVolumeSlider(content, "Music Volume", settingsService.getMusicVolume(),
                settingsService::updateMusicVolume);
        addVolumeSlider(content, "Sound Volume", settingsService.getSoundVolume(),
                settingsService::updateSoundVolume);

        content.add().row();


        content.add("Video Settings").colspan(2).align(Align.left).row();
        addCheckbox(content, "VSync", settingsService.getVSync(),
                settingsService::updateVSync);
        addCheckbox(content, "Particles", settingsService.getSettings().isParticles(),
                settingsService::updateParticles);
        addCheckbox(content, "Smooth Lighting", settingsService.getSettings().isSmoothLighting(),
                settingsService::updateSmoothLighting);


        content.add("Controls").colspan(2).align(Align.left).row();
        addKeyBinding(content, "Move Up", "UP");
        addKeyBinding(content, "Move Down", "DOWN");
        addKeyBinding(content, "Move Left", "LEFT");
        addKeyBinding(content, "Move Right", "RIGHT");
        addKeyBinding(content, "Run", "RUN");


        TextButton doneButton = new TextButton("Done", skin);
        doneButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                goBack();
            }
        });
        content.add(doneButton).colspan(2).width(200).pad(20).row();

        settingsWindow.add(content).pad(20);
        settingsWindow.pack();


        settingsWindow.setPosition(
                (Gdx.graphics.getWidth() - settingsWindow.getWidth()) / 2,
                (Gdx.graphics.getHeight() - settingsWindow.getHeight()) / 2
        );

        stage.addActor(settingsWindow);
    }

    private void addVolumeSlider(Table table, String label, float initialValue,
                                 VolumeChangeListener listener) {
        table.add(label).left();
        Slider slider = new Slider(0, 1, 0.01f, false, skin);
        slider.setValue(initialValue);
        slider.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                listener.onVolumeChanged(slider.getValue());
            }
        });
        table.add(slider).width(200).row();
    }

    private void addCheckbox(Table table, String label, boolean initialValue,
                             CheckboxChangeListener listener) {
        CheckBox checkbox = new CheckBox(" " + label, skin);
        checkbox.setChecked(initialValue);
        checkbox.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                listener.onCheckboxChanged(checkbox.isChecked());
            }
        });
        table.add(checkbox).colspan(2).left().row();
    }

    private void addKeyBinding(Table table, String label, String binding) {
        table.add(label).left();
        TextButton bindButton = new TextButton(
                Input.Keys.toString(settingsService.getKeyBindings().get(binding)),
                skin
        );

        bindButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                startKeyBinding(bindButton, binding);
            }
        });

        table.add(bindButton).width(100).row();
    }

    private void startKeyBinding(TextButton button, String binding) {
        button.setText("Press any key...");
        stage.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if (keycode != Input.Keys.ESCAPE) {
                    settingsService.setKeyBinding(binding, keycode);
                    button.setText(Input.Keys.toString(keycode));
                }
                stage.removeListener(this);
                return true;
            }
        });
    }

    private void goBack() {
        if (isGameScreen) {
            screenManager.goBack();
        } else {
            screenManager.showScreen(ModeSelectionScreen.class);
        }
    }

    @Override
    public void render(float delta) {
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);


        backgroundService.render(isGameScreen);

        stage.act(delta);
        stage.draw();
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
        settingsWindow.setPosition(
                (width - settingsWindow.getWidth()) / 2,
                (height - settingsWindow.getHeight()) / 2
        );
    }

    @Override
    public void pause() {

    }

    @Override
    public void resume() {

    }

    @Override
    public void hide() {
        Gdx.input.setInputProcessor(null);
    }

    @Override
    public void dispose() {
        stage.dispose();
        skin.dispose();
    }

    private interface VolumeChangeListener {
        void onVolumeChanged(float value);
    }

    private interface CheckboxChangeListener {
        void onCheckboxChanged(boolean value);
    }
}

================
File: main/java/io.github.minemon/core/screen/WorldSelectionScreen.java
================
package io.github.minemon.core.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.Scaling;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.minemon.audio.service.AudioService;
import io.github.minemon.core.service.ScreenManager;
import io.github.minemon.world.model.WorldData;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Random;

@Component
@Slf4j
public class WorldSelectionScreen implements Screen {
    private final AudioService audioService;
    private final WorldService worldService;
    private final ScreenManager screenManager;

    @Value("${world.saveDir:assets/save/worlds/}")
    private String saveDir;

    private Stage stage;
    private Skin skin;
    private Table worldListTable;
    private String selectedWorldName;

    private Table infoPanel;
    private TextButton playButton;
    private TextButton deleteButton;
    private float fontScale;

    @Autowired
    public WorldSelectionScreen(AudioService audioService,
                                WorldService worldService,
                                ScreenManager screenManager) {
        this.audioService = audioService;
        this.worldService = worldService;
        this.screenManager = screenManager;
    }

    @Override
    public void show() {
        audioService.playMenuMusic();

        stage = new Stage(new ScreenViewport());
        Gdx.input.setInputProcessor(stage);
        skin = new Skin(Gdx.files.internal("assets/Skins/uiskin.json"));

        createUI();
        refreshWorldList();
    }

    private void createUI() {

        float width = Gdx.graphics.getWidth();
        float height = Gdx.graphics.getHeight();
        float maxUIWidth = 1400f;
        float maxUIHeight = 900f;



        fontScale = MathUtils.clamp(Math.min(width, height) / 900f, 0.8f, 1.5f);


        Table rootContainer = new Table(skin);
        rootContainer.setFillParent(true);
        stage.addActor(rootContainer);


        rootContainer.setBackground(skin.newDrawable("white", 0.1f,0.1f,0.1f,1f));


        Table mainTable = new Table(skin);
        mainTable.defaults().pad(10 * fontScale);
        rootContainer.add(mainTable)
                .width(Math.min(width * 0.9f, maxUIWidth))
                .height(Math.min(height * 0.9f, maxUIHeight))
                .center();


        Label titleLabel = new Label("Select World", skin);
        titleLabel.setFontScale(1.5f * fontScale);
        mainTable.add(titleLabel).colspan(2).padBottom(20 * fontScale).center().row();


        worldListTable = new Table(skin);
        worldListTable.top().defaults().pad(5 * fontScale);

        ScrollPane scrollPane = new ScrollPane(worldListTable, skin);
        scrollPane.setFadeScrollBars(false);
        scrollPane.setScrollingDisabled(true, false);


        Table worldListContainer = new Table(skin);
        worldListContainer.setBackground(skin.newDrawable("white", 0.15f,0.15f,0.15f,1f));
        worldListContainer.add(scrollPane).expand().fill();

        infoPanel = new Table(skin);
        infoPanel.defaults().left().pad(5 * fontScale);
        infoPanel.setBackground(skin.newDrawable("white", 0.15f,0.15f,0.15f,1f));
        infoPanel.add(new Label("Select a world to view details", skin)).expand().fill();

        Table contentTable = new Table(skin);
        float contentWidth = Math.min((Math.min(width, maxUIWidth)) * 0.9f, 1200f);
        float infoPanelWidth = Math.min(contentWidth * 0.35f, 350f);
        float worldListWidth = Math.min(contentWidth * 0.6f, 600f);

        contentTable.add(worldListContainer).expandY().fillY().width(worldListWidth).padRight(20 * fontScale);
        contentTable.add(infoPanel).expandY().fillY().width(infoPanelWidth);

        mainTable.add(contentTable).colspan(2).expand().fill().row();


        TextButton createButton = new TextButton("Create New World", skin);
        playButton = new TextButton("Play Selected World", skin);
        deleteButton = new TextButton("Delete World", skin);
        TextButton backButton = new TextButton("Back", skin);


        createButton.getLabel().setFontScale(fontScale);
        playButton.getLabel().setFontScale(fontScale);
        deleteButton.getLabel().setFontScale(fontScale);
        backButton.getLabel().setFontScale(fontScale);


        playButton.setDisabled(true);
        deleteButton.setDisabled(true);


        createButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                showCreateWorldDialog();
            }
        });

        playButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (selectedWorldName != null) {
                    log.debug("PLAY requested for world '{}'", selectedWorldName);
                    worldService.loadWorld(selectedWorldName);
                    screenManager.showScreen(GameScreen.class);
                }
            }
        });


        deleteButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (selectedWorldName != null) {
                    showDeleteConfirmDialog();
                }
            }
        });

        backButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                screenManager.goBack();
            }
        });

        Table buttonTable = new Table(skin);
        buttonTable.defaults().pad(10 * fontScale);
        buttonTable.add(createButton);
        buttonTable.add(playButton);
        buttonTable.add(deleteButton);
        buttonTable.row();
        buttonTable.add(backButton).colspan(3).center().padTop(10 * fontScale);

        mainTable.row();
        mainTable.add(buttonTable).colspan(2).padTop(20 * fontScale).center();
    }

    private void showDeleteConfirmDialog() {
        if (selectedWorldName == null) return;
        Dialog dialog = new Dialog("Delete World", skin) {
            @Override
            protected void result(Object object) {
                if ((Boolean) object) {

                    worldService.deleteWorld(selectedWorldName);
                    refreshWorldList();
                    selectedWorldName = null;
                    updateInfoPanel(null);
                    updateButtonsState();
                }
            }
        };
        dialog.text("Are you sure you want to delete world '" + selectedWorldName + "'?\nThis action cannot be undone!");
        dialog.button("Delete", true);
        dialog.button("Cancel", false);
        dialog.show(stage);
    }

    private Table createWorldEntry(final String worldName) {
        Table entry = new Table(skin);
        entry.setBackground(skin.newDrawable("white", 0.1f,0.1f,0.1f,1f));

        WorldData meta = loadWorldMetadata(worldName);

        FileHandle iconFile = Gdx.files.local(saveDir + worldName + "/icon.png");
        Image icon;
        if (iconFile.exists()) {
            Texture tex = new Texture(iconFile);
            icon = new Image(new TextureRegion(tex));
        } else {

            FileHandle fallbackFile = Gdx.files.internal("assets/icons/default_world_icon.png");
            Texture fallback = new Texture(fallbackFile);
            icon = new Image(new TextureRegion(fallback));
        }

        icon.setScaling(Scaling.fit);
        float iconSize = 64f * fontScale;
        entry.add(icon).size(iconSize, iconSize).pad(10 * fontScale);

        Table infoTable = new Table(skin);
        Label nameLabel = new Label(worldName, skin);
        nameLabel.setFontScale(fontScale);

        Label createdLabel = new Label("Created: " + formatDate(meta.getCreatedDate()), skin);
        createdLabel.setFontScale(fontScale);

        Label lastPlayedLabel = new Label("Last Played: " + formatDate(meta.getLastPlayed()), skin);
        lastPlayedLabel.setFontScale(fontScale);

        Label playedTimeLabel = new Label("Played Time: " + formatPlayedTime(meta.getPlayedTime()), skin);
        playedTimeLabel.setFontScale(fontScale);

        infoTable.add(nameLabel).left().row();
        infoTable.add(createdLabel).left().row();
        infoTable.add(lastPlayedLabel).left().row();
        infoTable.add(playedTimeLabel).left().row();

        entry.add(infoTable).expand().fill().pad(10 * fontScale);

        entry.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                selectedWorldName = worldName;
                highlightSelectedEntry(entry);
                updateInfoPanel(meta);
                updateButtonsState();
            }
        });
        return entry;
    }

    private void highlightSelectedEntry(Table selectedEntry) {
        for (Actor actor : worldListTable.getChildren()) {
            if (actor instanceof Table t) {
                t.setBackground(skin.newDrawable("white", 0.1f,0.1f,0.1f,1f));
            }
        }
        selectedEntry.setBackground(skin.newDrawable("white", 0.3f,0.6f,1f,1f));
    }

    private WorldData loadWorldMetadata(String worldName) {
        FileHandle worldFile = Gdx.files.local(saveDir + worldName + "/" + worldName + ".json");
        if (!worldFile.exists()) {
            WorldData wd = new WorldData();
            wd.setWorldName(worldName);
            wd.setSeed(0);
            wd.setCreatedDate(0);
            wd.setLastPlayed(0);
            wd.setPlayedTime(0);
            return wd;
        }
        Json json = new Json();
        return json.fromJson(WorldData.class, worldFile.readString());
    }

    private String formatPlayedTime(long millis) {
        long seconds = millis / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;
        seconds %= 60;
        minutes %= 60;
        return String.format("%02dh %02dm %02ds", hours, minutes, seconds);
    }

    private String formatDate(long timestamp) {
        if (timestamp == 0) return "Never";
        return new SimpleDateFormat("MMM d, yyyy HH:mm").format(new Date(timestamp));
    }

    private void refreshWorldList() {
        worldListTable.clear();
        List<String> worldNames = worldService.getAvailableWorlds();
        for (String worldName : worldNames) {
            Table entry = createWorldEntry(worldName);
            worldListTable.add(entry).expandX().fillX().row();
        }
        selectedWorldName = null;
        updateButtonsState();
        updateInfoPanel(null);
    }

    private void updateButtonsState() {
        boolean hasSelection = selectedWorldName != null;
        playButton.setDisabled(!hasSelection);
        deleteButton.setDisabled(!hasSelection);
    }private void showCreateWorldDialog() {
        Dialog dialog = new Dialog("Create New World", skin) {
            @Override
            protected void result(Object object) {
                if ((Boolean) object) {
                    TextField nameField = findActor("worldNameField");
                    TextField seedField = findActor("seedField");

                    String worldName = nameField.getText().trim();
                    if (worldName.isEmpty()) {
                        showErrorDialog("World name cannot be empty");
                        return;
                    }

                    long seed;
                    String seedText = seedField.getText().trim();
                    if (seedText.isEmpty()) {
                        seed = new Random().nextLong();
                    } else {
                        try {
                            seed = Long.parseLong(seedText);
                        } catch (NumberFormatException e) {
                            showErrorDialog("Seed must be a valid number");
                            return;
                        }
                    }

                    boolean success = worldService.createWorld(worldName, seed);
                    if (!success) {
                        showErrorDialog("Failed to create the world. The name might already exist or another error occurred.");
                        return;
                    }


                    worldService.generateWorldThumbnail(worldName);

                    refreshWorldList();
                    selectedWorldName = worldName;
                    highlightNewlyCreatedEntry(worldName);
                    updateButtonsState();
                    updateInfoPanel(loadWorldMetadata(worldName));
                }
            }
        };

        dialog.getContentTable().pad(10 * fontScale);

        Label worldNameLabel = new Label("World Name:", skin);
        worldNameLabel.setFontScale(fontScale);
        dialog.getContentTable().add(worldNameLabel).left().row();

        TextField nameField = new TextField("", skin);
        nameField.setName("worldNameField");
        nameField.setMessageText("Enter world name");
        dialog.getContentTable().add(nameField).width(300 * fontScale).padBottom(10 * fontScale).row();

        Label seedLabel = new Label("Seed (optional):", skin);
        seedLabel.setFontScale(fontScale);
        dialog.getContentTable().add(seedLabel).left().row();

        TextField seedField = new TextField("", skin);
        seedField.setName("seedField");
        seedField.setMessageText("Enter seed or leave empty");
        dialog.getContentTable().add(seedField).width(300 * fontScale).padBottom(10 * fontScale).row();

        dialog.button("Create", true);
        dialog.button("Cancel", false);
        dialog.key(Input.Keys.ENTER, true);
        dialog.key(Input.Keys.ESCAPE, false);

        dialog.show(stage);
    }


    private void highlightNewlyCreatedEntry(String worldName) {
        for (Actor actor : worldListTable.getChildren()) {
            if (actor instanceof Table entry) {
                Label nameLabel = findNameLabel(entry);
                if (nameLabel != null && worldName.equals(nameLabel.getText().toString())) {
                    highlightSelectedEntry(entry);
                    break;
                }
            }
        }
    }

    private Label findNameLabel(Table entry) {
        for (Actor child : entry.getChildren()) {
            if (child instanceof Table infoTable) {
                for (Actor infoChild : infoTable.getChildren()) {
                    if (infoChild instanceof Label label) {
                        return label;
                    }
                }
            }
        }
        return null;
    }

    private void updateInfoPanel(WorldData meta) {
        infoPanel.clear();
        if (meta == null) {
            Label prompt = new Label("Select a world to view details", skin);
            prompt.setFontScale(fontScale);
            infoPanel.add(prompt).expand().fill();
            return;
        }

        infoPanel.defaults().left().pad(5 * fontScale);
        Label nameLabel = new Label(meta.getWorldName(), skin);
        nameLabel.setFontScale(1.2f * fontScale);
        infoPanel.add(nameLabel).expandX().row();

        Label created = new Label("Created: " + formatDate(meta.getCreatedDate()), skin);
        created.setFontScale(fontScale);
        infoPanel.add(created).row();

        Label lastPlayed = new Label("Last Played: " + formatDate(meta.getLastPlayed()), skin);
        lastPlayed.setFontScale(fontScale);
        infoPanel.add(lastPlayed).row();

        Label playedTime = new Label("Played Time: " + formatPlayedTime(meta.getPlayedTime()), skin);
        playedTime.setFontScale(fontScale);
        infoPanel.add(playedTime).row();
    }

    private void showErrorDialog(String message) {
        Dialog errorDialog = new Dialog("Error", skin);
        errorDialog.text(message);
        errorDialog.button("OK");
        errorDialog.show(stage);
    }

    @Override
    public void render(float delta) {
        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            screenManager.goBack();
        }

        Gdx.gl.glClearColor(0.15f,0.15f,0.15f,1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        stage.act(delta);
        stage.draw();
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
    }

    @Override
    public void pause() {}

    @Override
    public void resume() {}

    @Override
    public void hide() {
        audioService.stopMenuMusic();
    }

    @Override
    public void dispose() {
        stage.dispose();
        skin.dispose();
    }
}

================
File: main/java/io.github.minemon/core/service/BackgroundService.java
================
package io.github.minemon.core.service;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.math.Matrix4;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Slf4j
@Service
public class BackgroundService {
    private SpriteBatch batch;
    private TextureRegion backgroundTexture;
    private ShaderProgram shader;
    private float time;
    private Matrix4 transform;
    private boolean useShader = true;

    public void initialize() {
        batch = new SpriteBatch();
        OrthographicCamera camera = new OrthographicCamera();
        camera.setToOrtho(false);
        transform = new Matrix4();


        try {
            shader = new ShaderProgram(
                    Gdx.files.internal("shaders/menu_background.vert"),
                    Gdx.files.internal("shaders/menu_background.frag")
            );

            if (!shader.isCompiled()) {
                log.error("Shader compilation failed: {}", shader.getLog());
                useShader = false;
            }
        } catch (Exception e) {
            log.error("Failed to load shader", e);
            useShader = false;
        }


        try {
            Texture bgTexture = new Texture(Gdx.files.internal("assets/Textures/UI/ethereal.png"));
            backgroundTexture = new TextureRegion(bgTexture);
        } catch (Exception e) {
            log.error("Failed to load background texture", e);
        }
    }

    public void update(float delta) {
        time += delta * 0.02f;
        if (useShader) {
            transform.setToRotation(0, 1, 0, time * 15);
        }
    }

    public void render(boolean transparent) {
        if (backgroundTexture == null) return;

        batch.begin();
        if (transparent) {
            batch.setColor(1, 1, 1, 0.5f);
        }

        batch.draw(backgroundTexture,
                0, 0,
                Gdx.graphics.getWidth(),
                Gdx.graphics.getHeight()
        );

        if (transparent) {
            batch.setColor(Color.WHITE);
        }
        batch.end();
    }

    public void dispose() {
        if (batch != null) batch.dispose();
        if (shader != null) shader.dispose();
        if (backgroundTexture != null) backgroundTexture.getTexture().dispose();
    }
}

================
File: main/java/io.github.minemon/core/service/FileAccessService.java
================
package io.github.minemon.core.service;

public interface FileAccessService {
    boolean exists(String path);
    String readFile(String path);
    void writeFile(String path, String content);
}

================
File: main/java/io.github.minemon/core/service/impl/LocalFileAccessService.java
================
package io.github.minemon.core.service.impl;

import io.github.minemon.core.service.FileAccessService;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@Service
@Profile("server")
public class LocalFileAccessService implements FileAccessService {

    @Override
    public boolean exists(String path) {
        Path p = Paths.get(path);
        return Files.exists(p);
    }

    @Override
    public String readFile(String path) {
        try {
            Path p = Paths.get(path);
            if (!Files.exists(p)) {
                throw new RuntimeException("File not found: " + path);
            }
            return Files.readString(p, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException("Error reading file " + path + ": " + e.getMessage(), e);
        }
    }

    @Override
    public void writeFile(String path, String content) {
        try {
            Path p = Paths.get(path);
            Files.writeString(p, content, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException("Error writing file " + path + ": " + e.getMessage(), e);
        }
    }
}

================
File: main/java/io.github.minemon/core/service/impl/ScreenManagerImpl.java
================
package io.github.minemon.core.service.impl;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import io.github.minemon.core.service.ScreenManager;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

import java.util.Stack;

@Service
@Primary
public class ScreenManagerImpl implements ScreenManager {
    private final ApplicationContext applicationContext;
    private final Game game;
    private final Stack<Class<? extends Screen>> screenHistory = new Stack<>();
    private Screen previousScreen;

    @Autowired
    public ScreenManagerImpl(ApplicationContext applicationContext, Game game) {
        this.applicationContext = applicationContext;
        this.game = game;
    }

    @Override
    public void showScreen(Class<? extends Screen> screenClass) {
        screenHistory.push(screenClass);
        previousScreen = game.getScreen();
        Screen newScreen = applicationContext.getBean(screenClass);
        Gdx.app.postRunnable(() -> game.setScreen(newScreen));
    }

    @Override
    public void goBack() {
        Gdx.app.postRunnable(() -> {
            if (screenHistory.size() <= 1) return;
            screenHistory.pop();
            Class<? extends Screen> previous = screenHistory.peek();
            Screen newScreen = applicationContext.getBean(previous);
            previousScreen = game.getScreen();
            game.setScreen(newScreen);
        });
    }

    @Override
    public Screen getPreviousScreen() {
        return previousScreen;
    }
}

================
File: main/java/io.github.minemon/core/service/impl/SpringFileAccessService.java
================
package io.github.minemon.core.service.impl;

import io.github.minemon.core.service.FileAccessService;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@Service
@Primary
@Profile("client")
public class SpringFileAccessService implements FileAccessService {

    public SpringFileAccessService() {
    }

    @Override
    public boolean exists(String path) {
        Path p = Paths.get(path).toAbsolutePath();
        return Files.exists(p);
    }

    @Override
    public String readFile(String path) {
        Path p = Paths.get(path).toAbsolutePath();
        try {
            if (!Files.exists(p)) {
                throw new RuntimeException("File not found: " + path);
            }
            return Files.readString(p, StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new RuntimeException("Failed to read file " + path + ": " + e.getMessage(), e);
        }
    }

    @Override
    public void writeFile(String path, String content) {
        Path p = Paths.get(path).toAbsolutePath();
        try {
            if (p.getParent() != null) {
                Files.createDirectories(p.getParent());
            }
            Files.writeString(p, content, StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new RuntimeException("Failed to write file: " + path, e);
        }
    }
}

================
File: main/java/io.github.minemon/core/service/ScreenManager.java
================
package io.github.minemon.core.service;

import com.badlogic.gdx.Screen;

public interface ScreenManager {
    void showScreen(Class<? extends Screen> screenClass);
    void goBack();
    Screen getPreviousScreen();
}

================
File: main/java/io.github.minemon/core/service/SettingsService.java
================
package io.github.minemon.core.service;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Preferences;
import io.github.minemon.core.config.GameSettings;
import io.github.minemon.input.InputConfiguration;
import io.github.minemon.player.model.PlayerDirection;
import lombok.Getter;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;

@Service
public class SettingsService {
    private static final String PREFS_NAME = "pokemeetup_settings";
    private final InputConfiguration inputConfig;
    private final float DEFAULT_MUSIC_VOLUME = 0.7f;
    private final float DEFAULT_SOUND_VOLUME = 1.0f;
    private final boolean DEFAULT_VSYNC = true;
    private final int DEFAULT_RENDER_DISTANCE = 12;
    private final boolean DEFAULT_PARTICLES = true;
    private final boolean DEFAULT_SMOOTH_LIGHTING = true;
    private Preferences prefs;
    private GameSettings currentSettings;
    private boolean initialized = false;
    @Getter
    private Map<String, Integer> keyBindings;

    public SettingsService(InputConfiguration inputConfig) {
        this.inputConfig = inputConfig;
        this.keyBindings = new HashMap<>();
        initializeDefaultKeyBindings();
        createDefaultSettings();
    }

    private void initializeDefaultKeyBindings() {
        keyBindings.put("UP", Input.Keys.W);
        keyBindings.put("DOWN", Input.Keys.S);
        keyBindings.put("LEFT", Input.Keys.A);
        keyBindings.put("RIGHT", Input.Keys.D);
        keyBindings.put("RUN", Input.Keys.Z);
        updateInputConfiguration();
    }

    private void createDefaultSettings() {
        currentSettings = new GameSettings();
        currentSettings.setMusicVolume(DEFAULT_MUSIC_VOLUME);
        currentSettings.setSoundVolume(DEFAULT_SOUND_VOLUME);
        currentSettings.setVSync(DEFAULT_VSYNC);
        currentSettings.setRenderDistance(DEFAULT_RENDER_DISTANCE);
        currentSettings.setParticles(DEFAULT_PARTICLES);
        currentSettings.setSmoothLighting(DEFAULT_SMOOTH_LIGHTING);
    }

    public void initialize() {
        if (initialized || Gdx.app == null) return;

        prefs = Gdx.app.getPreferences(PREFS_NAME);
        loadAllSettings();
        initialized = true;
    }

    private void loadAllSettings() {

        currentSettings.setMusicVolume(prefs.getFloat("music_volume", DEFAULT_MUSIC_VOLUME));
        currentSettings.setSoundVolume(prefs.getFloat("sound_volume", DEFAULT_SOUND_VOLUME));
        currentSettings.setVSync(prefs.getBoolean("vsync", DEFAULT_VSYNC));
        currentSettings.setRenderDistance(prefs.getInteger("render_distance", DEFAULT_RENDER_DISTANCE));
        currentSettings.setParticles(prefs.getBoolean("particles", DEFAULT_PARTICLES));
        currentSettings.setSmoothLighting(prefs.getBoolean("smooth_lighting", DEFAULT_SMOOTH_LIGHTING));


        keyBindings.put("UP", prefs.getInteger("key_up", Input.Keys.W));
        keyBindings.put("DOWN", prefs.getInteger("key_down", Input.Keys.S));
        keyBindings.put("LEFT", prefs.getInteger("key_left", Input.Keys.A));
        keyBindings.put("RIGHT", prefs.getInteger("key_right", Input.Keys.D));
        keyBindings.put("RUN", prefs.getInteger("key_run", Input.Keys.Z));

        updateInputConfiguration();
    }

    private void updateInputConfiguration() {
        Map<Integer, PlayerDirection> newMovementKeys = new HashMap<>();
        newMovementKeys.put(keyBindings.get("UP"), PlayerDirection.UP);
        newMovementKeys.put(keyBindings.get("DOWN"), PlayerDirection.DOWN);
        newMovementKeys.put(keyBindings.get("LEFT"), PlayerDirection.LEFT);
        newMovementKeys.put(keyBindings.get("RIGHT"), PlayerDirection.RIGHT);
        inputConfig.setMovementKeys(newMovementKeys);
        inputConfig.setRunKey(keyBindings.get("RUN"));
    }

    public GameSettings getSettings() {
        return currentSettings;
    }

    public void updateMusicVolume(float volume) {
        if (initialized && prefs != null) {
            prefs.putFloat("music_volume", volume);
            prefs.flush();
        }
        currentSettings.setMusicVolume(volume);
    }

    public void updateSoundVolume(float volume) {
        if (initialized && prefs != null) {
            prefs.putFloat("sound_volume", volume);
            prefs.flush();
        }
        currentSettings.setSoundVolume(volume);
    }

    public void updateVSync(boolean enabled) {
        if (initialized && prefs != null) {
            prefs.putBoolean("vsync", enabled);
            prefs.flush();
            Gdx.graphics.setVSync(enabled);
        }
        currentSettings.setVSync(enabled);
    }

    public void updateRenderDistance(int distance) {
        if (initialized && prefs != null) {
            prefs.putInteger("render_distance", distance);
            prefs.flush();
        }
        currentSettings.setRenderDistance(distance);
    }

    public void updateParticles(boolean enabled) {
        if (initialized && prefs != null) {
            prefs.putBoolean("particles", enabled);
            prefs.flush();
        }
        currentSettings.setParticles(enabled);
    }

    public void updateSmoothLighting(boolean enabled) {
        if (initialized && prefs != null) {
            prefs.putBoolean("smooth_lighting", enabled);
            prefs.flush();
        }
        currentSettings.setSmoothLighting(enabled);
    }

    public void setKeyBinding(String action, int keycode) {
        keyBindings.put(action, keycode);
        if (initialized && prefs != null) {
            prefs.putInteger("key_" + action.toLowerCase(), keycode);
            prefs.flush();
        }
        updateInputConfiguration();
    }

    public float getMusicVolume() {
        if (initialized && prefs != null) {
            return prefs.getFloat("music_volume", currentSettings.getMusicVolume());
        }
        return currentSettings.getMusicVolume();
    }

    public void setMusicVolume(float volume) {
        if (initialized && prefs != null) {
            prefs.putFloat("music_volume", volume);
            prefs.flush();
        }
        currentSettings.setMusicVolume(volume);
    }

    public float getSoundVolume() {
        if (initialized && prefs != null) {
            return prefs.getFloat("sound_volume", currentSettings.getSoundVolume());
        }
        return currentSettings.getSoundVolume();
    }

    public void setSoundVolume(float volume) {
        if (initialized && prefs != null) {
            prefs.putFloat("sound_volume", volume);
            prefs.flush();
        }
        currentSettings.setSoundVolume(volume);
    }

    public boolean getVSync() {
        if (initialized && prefs != null) {
            return prefs.getBoolean("vsync", currentSettings.isVSync());
        }
        return currentSettings.isVSync();
    }

    public void setVSync(boolean enabled) {
        if (initialized && prefs != null) {
            prefs.putBoolean("vsync", enabled);
            prefs.flush();
            Gdx.graphics.setVSync(enabled);
        }
        currentSettings.setVSync(enabled);
    }
}

================
File: main/java/io.github.minemon/core/service/UiService.java
================
package io.github.minemon.core.service;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import io.github.minemon.core.ui.DialogFactory;
import io.github.minemon.core.ui.StyleFactory;
import lombok.Getter;
import org.springframework.stereotype.Service;

@Getter
@Service
public class UiService {
    private static final String UI_SKIN_PATH = "assets/Skins/uiskin.json";
    private Skin skin;
    private DialogFactory dialogFactory;
    private StyleFactory styleFactory;

    public void initialize() {
        if (skin != null) {
            return;
        }

        skin = new Skin(Gdx.files.internal(UI_SKIN_PATH));
        dialogFactory = new DialogFactory(skin);
        styleFactory = new StyleFactory();
    }

    public void dispose() {
        if (skin != null) {
            skin.dispose();
            skin = null;
        }
    }
}

================
File: main/java/io.github.minemon/core/ui/DialogFactory.java
================
package io.github.minemon.core.ui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.utils.Align;
import lombok.Setter;

public class DialogFactory {
    private static final float DIALOG_PADDING = 20f;

    private final Skin skin;
    @Setter
    private Stage stage;

    public DialogFactory(Skin skin) {
        this.skin = skin;
    }

    public void showWarning(String title, String message) {
        if (stage == null) return;
        createDialog(title, message, DialogType.WARNING);
    }

    public void showError(String title, String message) {
        if (stage == null) return;
        createDialog(title, message, DialogType.ERROR);
    }

    public void showSuccess(String title, String message) {
        if (stage == null) return;
        createDialog(title, message, DialogType.SUCCESS);
    }

    public Dialog showLoading(String message) {
        if (stage == null) return null;
        Dialog dialog = new Dialog("", skin);
        dialog.pad(DIALOG_PADDING);

        Table content = new Table(skin);
        Label messageLabel = new Label(message, skin);
        messageLabel.setWrap(true);
        content.add(messageLabel).pad(10f).width(300f);
        content.row();
        content.add(new ProgressBar(0, 1, 0.01f, false, skin)).width(200f);

        dialog.getContentTable().add(content);
        dialog.setModal(true);
        dialog.show(stage);
        return dialog;
    }

    public void showConfirmation(String title, String message, Runnable onConfirm) {
        if (stage == null) return;
        Dialog dialog = new Dialog(title, skin);
        dialog.pad(DIALOG_PADDING);

        Label messageLabel = new Label(message, skin);
        messageLabel.setWrap(true);
        Cell<?> cell = dialog.getContentTable().add(messageLabel).pad(10f);
        cell.width(300f);

        TextButton confirmButton = new TextButton("Confirm", skin);
        TextButton cancelButton = new TextButton("Cancel", skin);

        confirmButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                onConfirm.run();
                dialog.hide();
            }
        });

        cancelButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                dialog.hide();
            }
        });

        Table buttonTable = new Table();
        buttonTable.add(confirmButton).pad(5).width(100f);
        buttonTable.add(cancelButton).pad(5).width(100f);

        dialog.getButtonTable().add(buttonTable);
        dialog.setModal(true);

        centerDialog(dialog);
        dialog.show(stage);
    }

    private void createDialog(String title, String message, DialogType type) {
        Dialog dialog = new Dialog(title, skin);
        dialog.pad(DIALOG_PADDING);

        Table content = new Table(skin);
        content.add(createIcon(type)).pad(10f).size(32);

        Label messageLabel = new Label(message, skin);
        messageLabel.setWrap(true);
        messageLabel.setAlignment(Align.left);
        content.add(messageLabel).pad(10f).width(300f);

        dialog.getContentTable().add(content);

        TextButton okButton = new TextButton("OK", skin);
        okButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                dialog.hide();
            }
        });

        dialog.getButtonTable().add(okButton).width(100f);
        dialog.setModal(true);

        centerDialog(dialog);
        dialog.show(stage);
    }

    private void centerDialog(Dialog dialog) {
        dialog.setPosition(
                (stage.getWidth() - dialog.getWidth()) / 2,
                (stage.getHeight() - dialog.getHeight()) / 2
        );
    }

    private Image createIcon(DialogType type) {
        String iconPath = switch (type) {
            case WARNING -> "assets/Textures/UI/warning-icon.png";
            case ERROR -> "assets/Textures/UI/error-icon.png";
            case SUCCESS -> "assets/Textures/UI/success-icon.png";
        };
        return new Image(new Texture(Gdx.files.internal(iconPath)));
    }

    private enum DialogType {
        WARNING,
        ERROR,
        SUCCESS
    }
}

================
File: main/java/io.github.minemon/core/ui/ServerConfigDialog.java
================
package io.github.minemon.core.ui;

import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import io.github.minemon.multiplayer.model.ServerConnectionConfig;
import java.util.function.Consumer;

public class ServerConfigDialog extends Dialog {
    private static final int MIN_PORT = 1024;
    private static final int MAX_PORT = 65535;
    private static final String DEFAULT_IP = "127.0.0.1";
    private static final int DEFAULT_TCP_PORT = 54555;
    private static final int DEFAULT_UDP_PORT = 54777;

    private final DialogFactory dialogFactory;
    private final Consumer<ServerConnectionConfig> onSave;
    private final ServerConnectionConfig existingConfig;

    private TextField nameField;
    private TextField ipField;
    private TextField tcpField;
    private TextField udpField;

    public ServerConfigDialog(Skin skin, DialogFactory dialogFactory,
                              ServerConnectionConfig existingConfig,
                              Consumer<ServerConnectionConfig> onSave) {
        super(existingConfig == null ? "Add Server" : "Edit Server", skin);
        this.dialogFactory = dialogFactory;
        this.existingConfig = existingConfig;
        this.onSave = onSave;

        createContent();
        createButtons();
    }

    private void createContent() {
        Table content = new Table(getSkin());
        content.pad(20);


        content.add("Server Name:").left().padRight(10);
        nameField = new TextField(getExistingValue(ServerConnectionConfig::getServerName, ""), getSkin());
        content.add(nameField).width(250).left().row();


        content.add("IP Address:").left().padRight(10).padTop(10);
        ipField = new TextField(getExistingValue(ServerConnectionConfig::getServerIP, DEFAULT_IP), getSkin());
        content.add(ipField).width(250).left().row();


        content.add("TCP Port:").left().padRight(10).padTop(10);
        tcpField = new TextField(getExistingValue(
                config -> String.valueOf(config.getTcpPort()),
                String.valueOf(DEFAULT_TCP_PORT)),
                getSkin());
        content.add(tcpField).width(250).left().row();


        content.add("UDP Port:").left().padRight(10).padTop(10);
        udpField = new TextField(getExistingValue(
                config -> String.valueOf(config.getUdpPort()),
                String.valueOf(DEFAULT_UDP_PORT)),
                getSkin());
        content.add(udpField).width(250).left().row();

        getContentTable().add(content);
    }

    private void createButtons() {
        TextButton saveButton = new TextButton("Save", getSkin());
        TextButton cancelButton = new TextButton("Cancel", getSkin());

        saveButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                handleSave();
            }
        });

        cancelButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                hide();
            }
        });

        button(saveButton);
        button(cancelButton);
    }

    private void handleSave() {

        if (nameField.getText().trim().isEmpty()) {
            dialogFactory.showWarning("Invalid Input", "Server name cannot be empty");
            return;
        }

        if (ipField.getText().trim().isEmpty()) {
            dialogFactory.showWarning("Invalid Input", "IP address cannot be empty");
            return;
        }

        try {
            int tcpPort = Integer.parseInt(tcpField.getText().trim());
            int udpPort = Integer.parseInt(udpField.getText().trim());

            if (!isValidPort(tcpPort) || !isValidPort(udpPort)) {
                dialogFactory.showWarning("Invalid Input",
                        "Ports must be between " + MIN_PORT + " and " + MAX_PORT);
                return;
            }

            ServerConnectionConfig config = existingConfig != null ?
                    existingConfig : new ServerConnectionConfig();

            config.setServerName(nameField.getText().trim());
            config.setServerIP(ipField.getText().trim());
            config.setTcpPort(tcpPort);
            config.setUdpPort(udpPort);

            if (existingConfig == null) {

                config.setMotd("Welcome to " + config.getServerName());
                config.setMaxPlayers(20);
                config.setIconPath("");
                config.setDefault(false);
            }

            onSave.accept(config);
            hide();

        } catch (NumberFormatException e) {
            dialogFactory.showWarning("Invalid Input", "Port numbers must be valid integers");
        }
    }

    private boolean isValidPort(int port) {
        return port >= MIN_PORT && port <= MAX_PORT;
    }

    private <T> String getExistingValue(java.util.function.Function<ServerConnectionConfig, T> getter,
                                        String defaultValue) {
        if (existingConfig != null) {
            T value = getter.apply(existingConfig);
            return value != null ? value.toString() : defaultValue;
        }
        return defaultValue;
    }
}

================
File: main/java/io.github.minemon/core/ui/StyleFactory.java
================
package io.github.minemon.core.ui;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.Gdx;
import org.springframework.stereotype.Component;

@Component
public class StyleFactory {
    private final Color TITLE_COLOR = new Color(1f, 0.95f, 0.8f, 1f);

    public Label createTitleLabel(String text, Skin skin) {
        Label label = new Label(text, skin);
        Label.LabelStyle style = new Label.LabelStyle(label.getStyle());
        style.fontColor = TITLE_COLOR;
        label.setStyle(style);
        float TITLE_SCALE = 1.8f;
        label.setFontScale(TITLE_SCALE);
        return label;
    }

    public TextButton createGameButton(String text, Skin skin) {
        TextButton button = new TextButton(text, skin);
        TextButton.TextButtonStyle style = new TextButton.TextButtonStyle(button.getStyle());
        style.up = createButtonBackground();
        style.down = createButtonBackground();
        style.over = createButtonBackground();
        button.setStyle(style);
        return button;
    }

    public Drawable createPanelBackground() {
        return new TextureRegionDrawable(new Texture(Gdx.files.internal("assets/Textures/UI/window.png")));
    }

    private Drawable createButtonBackground() {
        Texture buttonTexture = new Texture(Gdx.files.internal("assets/Textures/UI/hotbar_bg.png"));
        TextureRegionDrawable drawable = new TextureRegionDrawable(buttonTexture);
        drawable.setMinWidth(150);
        drawable.setMinHeight(50);
        return drawable;
    }
}

================
File: main/java/io.github.minemon/event/Event.java
================
package io.github.minemon.event;

public interface Event {
}

================
File: main/java/io.github.minemon/event/EventBus.java
================
package io.github.minemon.event;

import org.springframework.stereotype.Component;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class EventBus {
    private final Map<Class<? extends Event>, List<EventListener<?>>> listeners = new ConcurrentHashMap<>();

    public <E extends Event> void registerListener(Class<E> eventClass, EventListener<E> listener) {
        listeners.computeIfAbsent(eventClass, k -> Collections.synchronizedList(new ArrayList<>())).add(listener);
    }

    public <E extends Event> void unregisterListener(Class<E> eventClass, EventListener<E> listener) {
        List<EventListener<?>> list = listeners.get(eventClass);
        if (list != null) {
            list.remove(listener);
        }
    }

    @SuppressWarnings("unchecked")
    public <E extends Event> void fireEvent(E event) {
        Class<? extends Event> eventClass = event.getClass();
        List<EventListener<?>> list = listeners.get(eventClass);
        if (list != null) {
            for (EventListener<?> l : list) {
                ((EventListener<E>) l).onEvent(event);
            }
        }
    }
}

================
File: main/java/io.github.minemon/event/EventListener.java
================
package io.github.minemon.event;

public interface EventListener<E extends Event> {
    void onEvent(E event);
}

================
File: main/java/io.github.minemon/input/InputConfiguration.java
================
package io.github.minemon.input;

import com.badlogic.gdx.Input;
import io.github.minemon.player.model.PlayerDirection;
import lombok.Getter;
import lombok.Setter;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

@Setter
@Getter
@Component
public class InputConfiguration {
    private Map<Integer, PlayerDirection> movementKeys = new HashMap<>();

    private int runKey = Input.Keys.Z;

    public InputConfiguration() {

        movementKeys.put(Input.Keys.W, PlayerDirection.UP);
        movementKeys.put(Input.Keys.UP, PlayerDirection.UP);
        movementKeys.put(Input.Keys.S, PlayerDirection.DOWN);
        movementKeys.put(Input.Keys.DOWN, PlayerDirection.DOWN);
        movementKeys.put(Input.Keys.A, PlayerDirection.LEFT);
        movementKeys.put(Input.Keys.LEFT, PlayerDirection.LEFT);
        movementKeys.put(Input.Keys.D, PlayerDirection.RIGHT);
        movementKeys.put(Input.Keys.RIGHT, PlayerDirection.RIGHT);
    }

    public void updateKeyBinding(int oldKey, int newKey, PlayerDirection direction) {
        movementKeys.remove(oldKey);
        movementKeys.put(newKey, direction);
    }

    public PlayerDirection getDirectionForKey(int keyCode) {
        return movementKeys.get(keyCode);
    }
}

================
File: main/java/io.github.minemon/input/InputService.java
================
package io.github.minemon.input;

import com.badlogic.gdx.InputAdapter;
import io.github.minemon.player.model.PlayerDirection;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class InputService extends InputAdapter {

    private final InputConfiguration inputConfig;

    private boolean upPressed, downPressed, leftPressed, rightPressed;
    private boolean runPressed;

    private PlayerDirection lastPressedDirection = null;

    /**
     * Returns the current direction, favoring the last pressed direction if multiple are pressed.
     */
    public PlayerDirection getCurrentDirection() {
        if (lastPressedDirection != null) {
            switch (lastPressedDirection) {
                case UP -> { if (upPressed) return PlayerDirection.UP; }
                case DOWN -> { if (downPressed) return PlayerDirection.DOWN; }
                case LEFT -> { if (leftPressed) return PlayerDirection.LEFT; }
                case RIGHT -> { if (rightPressed) return PlayerDirection.RIGHT; }
            }
        }
        if (upPressed) return PlayerDirection.UP;
        if (downPressed) return PlayerDirection.DOWN;
        if (leftPressed) return PlayerDirection.LEFT;
        if (rightPressed) return PlayerDirection.RIGHT;
        return null;
    }

    public boolean isRunning() {
        return runPressed;
    }

    @Override
    public boolean keyDown(int keycode) {
        PlayerDirection dir = inputConfig.getDirectionForKey(keycode);
        if (dir != null) {
            switch (dir) {
                case UP -> upPressed = true;
                case DOWN -> downPressed = true;
                case LEFT -> leftPressed = true;
                case RIGHT -> rightPressed = true;
            }
            lastPressedDirection = dir;
            return true;
        }

        if (keycode == inputConfig.getRunKey()) {
            runPressed = true;
            return true;
        }

        return false;
    }

    @Override
    public boolean keyUp(int keycode) {
        PlayerDirection dir = inputConfig.getDirectionForKey(keycode);
        if (dir != null) {
            switch (dir) {
                case UP -> upPressed = false;
                case DOWN -> downPressed = false;
                case LEFT -> leftPressed = false;
                case RIGHT -> rightPressed = false;
            }
            if (dir == lastPressedDirection) {
                lastPressedDirection = null;

                if (upPressed) lastPressedDirection = PlayerDirection.UP;
                else if (downPressed) lastPressedDirection = PlayerDirection.DOWN;
                else if (leftPressed) lastPressedDirection = PlayerDirection.LEFT;
                else if (rightPressed) lastPressedDirection = PlayerDirection.RIGHT;
            }
            return true;
        }

        if (keycode == inputConfig.getRunKey()) {
            runPressed = false;
            return true;
        }

        return false;
    }
}

================
File: main/java/io.github.minemon/multiplayer/config/MultiplayerConfig.java
================
package io.github.minemon.multiplayer.config;

import io.github.minemon.core.service.FileAccessService;
import io.github.minemon.core.service.impl.LocalFileAccessService;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.world.service.WorldService;
import io.github.minemon.multiplayer.service.MultiplayerService;
import io.github.minemon.multiplayer.service.impl.MultiplayerServiceImpl;
import io.github.minemon.multiplayer.service.MultiplayerServer;
import io.github.minemon.multiplayer.service.impl.MultiplayerServerImpl;
import io.github.minemon.multiplayer.service.ServerConnectionService;
import io.github.minemon.multiplayer.service.impl.ServerConnectionServiceImpl;
import io.github.minemon.event.EventBus;
import io.github.minemon.multiplayer.service.AuthService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;

@Configuration
public class MultiplayerConfig {

    @Bean
    public FileAccessService fileAccessService() {
        return new LocalFileAccessService();
    }

    @Bean
    public ServerConnectionService serverConnectionService(FileAccessService fileAccessService) {
        return new ServerConnectionServiceImpl(fileAccessService);
    }

    @Bean
    public MultiplayerService multiplayerService(WorldService worldService, PlayerService playerService, Environment env) {
        return new MultiplayerServiceImpl(worldService, env);
    }

    @Bean
    public MultiplayerServer multiplayerServer(MultiplayerService multiplayerService, EventBus eventBus, AuthService authService) {
        return new MultiplayerServerImpl(multiplayerService, eventBus, authService);
    }

}

================
File: main/java/io.github.minemon/multiplayer/model/ChunkUpdate.java
================
package io.github.minemon.multiplayer.model;

import lombok.Getter;
import lombok.Setter;
import io.github.minemon.world.model.WorldObject;
import java.util.List;

@Getter @Setter
public class ChunkUpdate {
    private int chunkX;
    private int chunkY;
    private int[][] tiles;
    private List<WorldObject> objects;
}

================
File: main/java/io.github.minemon/multiplayer/model/PlayerSyncData.java
================
package io.github.minemon.multiplayer.model;

import lombok.Getter;
import lombok.Setter;
import io.github.minemon.player.model.PlayerData;

/**
 * Each remote player's sync data as sent by the server.
 * Now includes local animation fields for the client to track
 * each player's animation time and movement states.
 */
@Getter @Setter
public class PlayerSyncData {
    private String username;
    private float x;
    private float y;
    private boolean running;
    private String direction;
    private boolean moving;

    private float animationTime = 0f;

    private boolean wasMoving;
    private String lastDirection;

    public static PlayerSyncData fromPlayerData(PlayerData pd) {
        PlayerSyncData sync = new PlayerSyncData();
        sync.setUsername(pd.getUsername());
        sync.setX(pd.getX());
        sync.setY(pd.getY());
        sync.setRunning(pd.isWantsToRun());
        sync.setDirection(pd.getDirection() != null ? pd.getDirection().name() : "DOWN");
        sync.setMoving(pd.isMoving());
        return sync;
    }
}

================
File: main/java/io.github.minemon/multiplayer/model/ServerConnectionConfig.java
================
package io.github.minemon.multiplayer.model;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class ServerConnectionConfig {
    private String serverIP = "127.0.0.1";
    private int tcpPort = 54555;
    private int udpPort = 54777;
    private int maxPlayers = 20;
    private String iconPath = "";
    private String motd = "";
    private String serverName = "Default Server";
    private String version = "1.0";
    private String dataDirectory = "worlds";
    private boolean isDefault = false;
    private int currentPlayers = 0;


    private boolean rememberMe = false;
    private String savedUsername = "";
    private String savedPassword = "";

    @Override
    public String toString() {
        return serverName + " (" + serverIP + ":" + tcpPort + ")";
    }
}

================
File: main/java/io.github.minemon/multiplayer/model/User.java
================
package io.github.minemon.multiplayer.model;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

@Entity
@Data
@Table(name = "app_user")
public class User {

    @Id
    private String username;

    private String passwordHash;

    public User() {}

    public User(String username, String passwordHash) {
        this.username = username;
        this.passwordHash = passwordHash;
    }
}

================
File: main/java/io.github.minemon/multiplayer/model/WorldObjectUpdate.java
================
package io.github.minemon.multiplayer.model;

import lombok.Getter;
import lombok.Setter;

@Getter @Setter
public class WorldObjectUpdate {
    private String objectId;
    private String type;
    private int tileX;
    private int tileY;
    private boolean removed;
}

================
File: main/java/io.github.minemon/multiplayer/repository/UserRepository.java
================
package io.github.minemon.multiplayer.repository;

import io.github.minemon.multiplayer.model.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, String> {
    User findByUsername(String username);
}

================
File: main/java/io.github.minemon/multiplayer/service/AuthService.java
================
package io.github.minemon.multiplayer.service;

import io.github.minemon.multiplayer.repository.UserRepository;
import io.github.minemon.multiplayer.model.User;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;

@Service
public class AuthService {
    private final UserRepository userRepository;

    public AuthService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public boolean authenticate(String username, String password) {
        User user = userRepository.findByUsername(username);
        return user != null && BCrypt.checkpw(password, user.getPasswordHash());
    }

    public boolean createUser(String username, String rawPassword) {
        if (userRepository.findByUsername(username) != null) {
            return false;
        }
        String hashed = BCrypt.hashpw(rawPassword, BCrypt.gensalt());
        User newUser = new User(username, hashed);
        userRepository.save(newUser);
        return true;
    }
}

================
File: main/java/io.github.minemon/multiplayer/service/impl/MultiplayerClientImpl.java
================
package io.github.minemon.multiplayer.service.impl;

import com.badlogic.gdx.Gdx;
import com.esotericsoftware.kryonet.Client;
import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.Listener;
import io.github.minemon.NetworkProtocol;
import io.github.minemon.chat.event.ChatMessageReceivedEvent;
import io.github.minemon.multiplayer.model.ChunkUpdate;
import io.github.minemon.multiplayer.model.PlayerSyncData;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.world.model.ObjectType;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.world.service.WorldService;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Service
public class MultiplayerClientImpl implements MultiplayerClient {
    private final Map<String, PlayerSyncData> playerStates = new ConcurrentHashMap<>();
    private final Map<String, ChunkUpdate> loadedChunks = new ConcurrentHashMap<>();
    private final ApplicationEventPublisher eventPublisher;
    private Client client;
    private boolean connected = false;
    private LoginResponseListener loginResponseListener;
    private CreateUserResponseListener createUserResponseListener;
    private Runnable pendingCreateUserRequest = null;
    private Runnable pendingLoginRequest = null;
    @Autowired
    @Lazy
    private WorldService worldService;

    @Data
    @AllArgsConstructor
    private static class ChunkKey {
        private final int x;
        private final int y;
    }

    // Add this to class fields
    private final Set<ChunkKey> pendingChunkRequests = ConcurrentHashMap.newKeySet();

    @Override
    public boolean isPendingChunkRequest(int chunkX, int chunkY) {
        return pendingChunkRequests.contains(new ChunkKey(chunkX, chunkY));
    }

    @Override
    public void requestChunk(int chunkX, int chunkY) {
        if (!connected) return;

        ChunkKey key = new ChunkKey(chunkX, chunkY);
        if (pendingChunkRequests.add(key)) {
            NetworkProtocol.ChunkRequest req = new NetworkProtocol.ChunkRequest();
            req.setChunkX(chunkX);
            req.setChunkY(chunkY);
            req.setTimestamp(System.currentTimeMillis());
            client.sendTCP(req);
            log.debug("Sent chunk request for ({},{})", chunkX, chunkY);
        } else {
            log.trace("Chunk request for ({},{}) already pending", chunkX, chunkY);
        }
    }

    @Autowired
    public MultiplayerClientImpl(ApplicationEventPublisher eventPublisher) { // Modify constructor
        this.eventPublisher = eventPublisher;
    }

    @Override
    public Map<String, PlayerSyncData> getPlayerStates() {
        return playerStates;
    }

    @Override
    public void setLoginResponseListener(LoginResponseListener listener) {
        this.loginResponseListener = listener;
    }

    @Override
    public void setCreateUserResponseListener(CreateUserResponseListener listener) {
        this.createUserResponseListener = listener;
    }

    @Override
    public void connect(String serverIP, int tcpPort, int udpPort) {
        if (connected) {
            log.warn("Already connected to a server.");
            return;
        }
        client = new Client();
        NetworkProtocol.registerClasses(client.getKryo());

        client.addListener(new Listener() {
            @Override
            public void connected(Connection connection) {
                log.info("Connected to server: {}", connection.getRemoteAddressTCP());
                connected = true;
                if (pendingLoginRequest != null) {
                    pendingLoginRequest.run();
                    pendingLoginRequest = null;
                }
                if (pendingCreateUserRequest != null) {
                    pendingCreateUserRequest.run();
                    pendingCreateUserRequest = null;
                }
            }

            @Override
            public void disconnected(Connection connection) {
                log.info("Disconnected from server: {}", connection.getRemoteAddressTCP());
                connected = false;

                playerStates.clear();
                loadedChunks.clear();

                Gdx.app.postRunnable(() -> {
                    if (loginResponseListener != null) {
                        loginResponseListener.onLoginResponse(false, "Lost connection to server.", "", 0, 0);
                    }
                    if (createUserResponseListener != null) {
                        createUserResponseListener.onCreateUserResponse(false, "Disconnected before completion.");
                    }
                });
            }


            @Override
            public void received(Connection connection, Object object) {
                handleMessage(object);
            }
        });

        try {
            client.start();
            client.connect(5000, serverIP, tcpPort, udpPort);
            log.info("Client attempting to connect to {}:{} (TCP) and {} (UDP)", serverIP, tcpPort, udpPort);
        } catch (IOException e) {
            log.error("Failed to connect to server: {}", e.getMessage(), e);
            if (loginResponseListener != null) {
                loginResponseListener.onLoginResponse(false,
                        "Connection failed: " + e.getMessage(), "", 0, 0);
            }
            if (createUserResponseListener != null) {
                createUserResponseListener.onCreateUserResponse(false,
                        "Connection failed: " + e.getMessage());
            }
        }
    }

    @Override
    public void login(String username, String password) {
        if (!connected) {
            log.warn("Not connected to server. Cannot send login request.");
            if (loginResponseListener != null) {
                loginResponseListener.onLoginResponse(false,
                        "Not connected to server.", "", 0, 0);
            }
            return;
        }
        NetworkProtocol.LoginRequest req = new NetworkProtocol.LoginRequest();
        req.setUsername(username);
        req.setPassword(password);
        req.setTimestamp(System.currentTimeMillis());
        client.sendTCP(req);
        log.info("Sent LoginRequest for user: {}", username);
    }

    @Override
    public void createUser(String username, String password) {
        if (!connected) {
            log.warn("Not connected to server. Cannot send create user request.");
            if (createUserResponseListener != null) {
                createUserResponseListener.onCreateUserResponse(false,
                        "Not connected to server.");
            }
            return;
        }
        NetworkProtocol.CreateUserRequest req = new NetworkProtocol.CreateUserRequest();
        req.setUsername(username);
        req.setPassword(password);
        client.sendTCP(req);
        log.info("Sent CreateUserRequest for user: {}", username);
    }


    private void handleMessage(Object object) {
        if (object.getClass().getName().startsWith("com.esotericsoftware.kryonet.FrameworkMessage")) {
            return;
        }

        if (object instanceof NetworkProtocol.LoginResponse resp) {
            log.info("Received LoginResponse: success={}, message={}", resp.isSuccess(), resp.getMessage());
            if (loginResponseListener != null) {
                loginResponseListener.onLoginResponse(
                        resp.isSuccess(),
                        resp.getMessage() != null ? resp.getMessage() : (resp.isSuccess() ? "Success" : "Failed"),
                        resp.getUsername(),
                        resp.getX(),
                        resp.getY()
                );
            }
        } else if (object instanceof NetworkProtocol.CreateUserResponse createResp) {
            log.info("Received CreateUserResponse: success={}, message={}", createResp.isSuccess(), createResp.getMessage());
            if (createUserResponseListener != null) {
                createUserResponseListener.onCreateUserResponse(
                        createResp.isSuccess(),
                        createResp.getMessage() != null ? createResp.getMessage() : (createResp.isSuccess() ? "Account created." : "Failed to create account.")
                );
            }
        } else if (object instanceof NetworkProtocol.PlayerStatesUpdate pUpdate) {
            // Clear and update player states
            playerStates.clear();
            playerStates.putAll(pUpdate.getPlayers());

            // **New Step:** Update local player animations and camera based on new states
            Gdx.app.postRunnable(this::updateLocalPlayersFromServerStates);
        }  else if (object instanceof NetworkProtocol.ChunkData chunkData) {
            ChunkKey key = new ChunkKey(chunkData.getChunkX(), chunkData.getChunkY());
            if (pendingChunkRequests.remove(key)) {
                log.debug("Received chunk data for ({},{})", chunkData.getChunkX(), chunkData.getChunkY());
                // Update world service with chunk data
                Gdx.app.postRunnable(() -> {
                    worldService.loadOrReplaceChunkData(
                            chunkData.getChunkX(),
                            chunkData.getChunkY(),
                            chunkData.getTiles(),
                            chunkData.getObjects()
                    );
                });
            } else {
                log.warn("Received unrequested chunk data for ({},{})",
                        chunkData.getChunkX(), chunkData.getChunkY());
            }
        }else if (object instanceof NetworkProtocol.WorldObjectsUpdate wObjects) {
            wObjects.getObjects().forEach(update -> {
                String key = (update.getTileX() / 16) + "," + (update.getTileY() / 16);
                ChunkUpdate cu = loadedChunks.get(key);
                if (cu != null) {
                    if (update.isRemoved()) {
                        cu.getObjects().removeIf(o -> o.getId().equals(update.getObjectId()));
                    } else {
                        boolean found = false;
                        for (WorldObject wo : cu.getObjects()) {
                            if (wo.getId().equals(update.getObjectId())) {
                                wo.setTileX(update.getTileX());
                                wo.setTileY(update.getTileY());
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            ObjectType objType = ObjectType.valueOf(update.getType());
                            WorldObject newObj = new WorldObject(
                                    update.getTileX(),
                                    update.getTileY(),
                                    objType,
                                    objType.isCollidable()
                            );
                            cu.getObjects().add(newObj);
                        }
                    }
                }
                // Update the local world service with the object changes
                Gdx.app.postRunnable(() -> {
                    worldService.updateWorldObjectState(update);
                });
            });
        } else if (object instanceof io.github.minemon.chat.model.ChatMessage chatMsg) {
            log.info("Received ChatMessage from {}: {}", chatMsg.getSender(), chatMsg.getContent());
            eventPublisher.publishEvent(new ChatMessageReceivedEvent(this, chatMsg));
        } else {
            log.warn("Unknown message type received: {}", object.getClass().getName());
        }
    }


    private void updateLocalPlayersFromServerStates() {
        for (Map.Entry<String, PlayerSyncData> entry : playerStates.entrySet()) {
            String username = entry.getKey();
            PlayerSyncData syncData = entry.getValue();

            PlayerData localPD = worldService.getPlayerData(username);
            if (localPD == null) {
                localPD = new PlayerData(username, syncData.getX(), syncData.getY());
                worldService.setPlayerData(localPD);
            }

            localPD.setX(syncData.getX());
            localPD.setY(syncData.getY());
            localPD.setWantsToRun(syncData.isRunning());
            localPD.setMoving(syncData.isMoving());

            try {
                localPD.setDirection(io.github.minemon.player.model.PlayerDirection.valueOf(
                        syncData.getDirection().toUpperCase()
                ));
            } catch (IllegalArgumentException e) {
                log.error("Invalid direction '{}' for player '{}'",
                        syncData.getDirection(), username, e);
            }

            boolean directionChanged = (syncData.getLastDirection() == null
                    || !syncData.getLastDirection().equalsIgnoreCase(syncData.getDirection()));
            boolean movementChanged = (syncData.isMoving() != syncData.isWasMoving());

            if (directionChanged || movementChanged) {
                syncData.setAnimationTime(0f);
            }

            syncData.setWasMoving(syncData.isMoving());
            syncData.setLastDirection(syncData.getDirection());
        }
    }


    @Override
    public void disconnect() {
        if (client != null && connected) {
            client.close();
            connected = false;
            log.info("Client disconnected from server.");
        }
    }

    @Override
    public boolean isConnected() {
        return connected;
    }

    @Override
    public void sendPlayerMove(float x, float y, boolean running, boolean moving, String direction) {
        if (!connected) return;
        NetworkProtocol.PlayerMoveRequest req = new NetworkProtocol.PlayerMoveRequest();
        req.setX(x);
        req.setY(y);
        req.setRunning(running);
        req.setMoving(moving);
        req.setDirection(direction);
        client.sendTCP(req);
    }


    @Override
    public void update(float delta) {
    }

    @Override
    public void sendMessage(Object msg) {
        if (!connected) return;
        client.sendTCP(msg);
    }

    @Override
    public void setPendingLoginRequest(Runnable action) {
        this.pendingLoginRequest = action;
    }

    @Override
    public void setPendingCreateUserRequest(Runnable action) {
        this.pendingCreateUserRequest = action;
    }
}

================
File: main/java/io.github.minemon/multiplayer/service/impl/MultiplayerServerImpl.java
================
package io.github.minemon.multiplayer.service.impl;

import com.badlogic.gdx.math.Vector2;
import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.Listener;
import com.esotericsoftware.kryonet.Server;
import io.github.minemon.NetworkProtocol;
import io.github.minemon.event.EventBus;
import io.github.minemon.multiplayer.service.AuthService;
import io.github.minemon.multiplayer.service.MultiplayerServer;
import io.github.minemon.multiplayer.service.MultiplayerService;
import io.github.minemon.player.event.PlayerJoinEvent;
import io.github.minemon.player.event.PlayerLeaveEvent;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.multiplayer.model.ChunkUpdate;
import io.github.minemon.multiplayer.model.PlayerSyncData;
import io.github.minemon.world.service.WorldService;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Slf4j
@Primary
@Service
public class MultiplayerServerImpl implements MultiplayerServer {

    private final MultiplayerService multiplayerService;
    private final EventBus eventBus;
    private final AuthService authService;
    private final Map<Integer, String> connectionUserMap = new ConcurrentHashMap<>();

    private Server server;
    private static final long CHUNK_REQUEST_INTERVAL = 100; // 100ms minimum between requests
    private static final int MAX_CACHED_CHUNKS_PER_CLIENT = 256;
    private static final long CHUNK_CACHE_CLEANUP_INTERVAL = 60_000; // 60 seconds
    private static final long CHUNK_CACHE_TTL = 300_000; // 5 minutes
    private final Map<String, Map<ChunkKey, Long>> clientChunkCache = new ConcurrentHashMap<>();
    private final ScheduledExecutorService cacheCleanupExecutor =
            Executors.newSingleThreadScheduledExecutor();
    @Getter
    private final Set<ChunkKey> pendingChunkRequests = ConcurrentHashMap.newKeySet();

    @Data
    @AllArgsConstructor
    private static class ChunkKey {
        private final int x;
        private final int y;
    }

    private final Map<String, Long> chunkRequestTimes = new ConcurrentHashMap<>();
    private volatile boolean running = false;
    @Autowired
    private WorldService worldService;

    public MultiplayerServerImpl(MultiplayerService multiplayerService,
                                 EventBus eventBus,
                                 AuthService authService) {
        this.multiplayerService = multiplayerService;
        this.eventBus = eventBus;
        this.authService = authService;
    }

    @Override
    public void startServer(int tcpPort, int udpPort) {
        if (running) {
            log.warn("Server already running.");
            return;
        }

        server = new Server();
        NetworkProtocol.registerClasses(server.getKryo());

        server.addListener(new Listener() {
            @Override
            public void connected(Connection connection) {
                log.info("New connection: {}", connection.getRemoteAddressTCP());
            }

            @Override
            public void disconnected(Connection connection) {
                handleDisconnection(connection);
            }

            @Override
            public void received(Connection connection, Object object) {
                handleMessage(connection, object);
            }
        });

        try {
            server.start();
            server.bind(tcpPort, udpPort);
            running = true;
            log.info("Multiplayer server started on TCP:{} UDP:{}", tcpPort, udpPort);
        } catch (IOException e) {
            log.error("Failed to start server: {}", e.getMessage(), e);
        }
    }

    private void handleDisconnection(Connection connection) {
        String username = connectionUserMap.remove(connection.getID());
        if (username != null) {
            multiplayerService.playerDisconnected(username);
            eventBus.fireEvent(new PlayerLeaveEvent(username));
            log.info("Player {} disconnected", username);
            broadcastPlayerStates();
        } else {
            log.info("Connection {} disconnected without a known user.", connection.getID());
        }
    }

    private void handleMessage(Connection connection, Object object) {
        if (object.getClass().getName().startsWith("com.esotericsoftware.kryonet.FrameworkMessage")) {
            return;
        }
        if (object instanceof NetworkProtocol.LoginRequest req) {
            handleLogin(connection, req);
        } else if (object instanceof NetworkProtocol.CreateUserRequest createReq) {
            handleCreateUser(connection, createReq);
        } else if (object instanceof NetworkProtocol.PlayerMoveRequest moveReq) {
            handlePlayerMove(connection, moveReq);
        } else if (object instanceof NetworkProtocol.ChunkRequest chunkReq) {
            handleChunkRequest(connection, chunkReq);
        } else if (object instanceof io.github.minemon.chat.model.ChatMessage chatMsg) {
            handleChatMessage(connection, chatMsg);
        } else {
            log.warn("Unknown message type received: {}", object.getClass());
        }
    }

    private void handleChatMessage(Connection connection, io.github.minemon.chat.model.ChatMessage msg) {
        String sender = connectionUserMap.get(connection.getID());
        if (sender == null) {
            log.warn("ChatMessage received from unregistered connection: {}", connection.getID());
            return;
        }
        msg.setSender(sender);

        log.info("Received ChatMessage from {}: {}", sender, msg.getContent());
        server.sendToAllExceptTCP(connection.getID(), msg);

    }

    private void handleLogin(Connection connection, NetworkProtocol.LoginRequest req) {
        boolean authSuccess = authService.authenticate(req.getUsername(), req.getPassword());
        NetworkProtocol.LoginResponse resp = new NetworkProtocol.LoginResponse();

        if (!authSuccess) {
            resp.setSuccess(false);
            resp.setMessage("Invalid username or password.");
            connection.sendTCP(resp);
            log.info("Authentication failed for user: {}", req.getUsername());
            return;
        }

        connectionUserMap.put(connection.getID(), req.getUsername());
        multiplayerService.playerConnected(req.getUsername());

        eventBus.fireEvent(new PlayerJoinEvent(req.getUsername()));
        PlayerData pd = multiplayerService.getPlayerData(req.getUsername());

        resp.setSuccess(true);
        resp.setUsername(req.getUsername());
        resp.setX((int) pd.getX());
        resp.setY((int) pd.getY());

        connection.sendTCP(resp);
        log.info("User '{}' logged in successfully from {}", req.getUsername(), connection.getRemoteAddressTCP());

        broadcastPlayerStates();
        sendInitialChunks(connection, pd);
    }

    private void handleCreateUser(Connection connection, NetworkProtocol.CreateUserRequest req) {
        NetworkProtocol.CreateUserResponse resp = new NetworkProtocol.CreateUserResponse();
        boolean success = authService.createUser(req.getUsername(), req.getPassword());
        if (success) {
            resp.setSuccess(true);
            resp.setMessage("User created successfully. You can now log in.");
        } else {
            resp.setSuccess(false);
            resp.setMessage("Username already exists or invalid input.");
        }
        connection.sendTCP(resp);
        log.info("User creation attempt for '{}': {}", req.getUsername(), success ? "SUCCESS" : "FAILURE");
    }

    private void handlePlayerMove(Connection connection, NetworkProtocol.PlayerMoveRequest moveReq) {
        String username = connectionUserMap.get(connection.getID());
        if (username == null) {
            log.warn("No user for this connection.");
            return;
        }

        PlayerData pd = worldService.getPlayerData(username);
        if (pd == null) return;

        try {
            pd.setDirection(io.github.minemon.player.model.PlayerDirection.valueOf(
                    moveReq.getDirection().toUpperCase()
            ));
        } catch (IllegalArgumentException e) {
            log.error("Invalid direction '{}'", moveReq.getDirection());
        }

        boolean positionChanged = (pd.getX() != moveReq.getX() || pd.getY() != moveReq.getY());

        pd.setX(moveReq.getX());
        pd.setY(moveReq.getY());
        pd.setWantsToRun(moveReq.isRunning());
        pd.setMoving(positionChanged);

        worldService.setPlayerData(pd);

        broadcastPlayerStates();
    }


    private void broadcastPlayerStates() {
        Map<String, PlayerSyncData> states = multiplayerService.getAllPlayerStates();
        NetworkProtocol.PlayerStatesUpdate update = new NetworkProtocol.PlayerStatesUpdate();
        update.setPlayers(states);
        broadcast(update);
    }

    private void handleChunkRequest(Connection connection, NetworkProtocol.ChunkRequest req) {
        // Rate limit chunk requests per connection
        String clientId = connection.getID() + "";
        long now = System.currentTimeMillis();
        long lastRequest = chunkRequestTimes.getOrDefault(clientId, 0L);

        if (now - lastRequest < CHUNK_REQUEST_INTERVAL) {
            log.warn("Client {} requesting chunks too frequently", clientId);
            return;
        }
        chunkRequestTimes.put(clientId, now);

        ChunkUpdate chunk = multiplayerService.getChunkData(req.getChunkX(), req.getChunkY());
        if (chunk == null) {
            // Generate chunk if it doesn't exist
            worldService.loadChunk(new Vector2(req.getChunkX(), req.getChunkY()));
            chunk = multiplayerService.getChunkData(req.getChunkX(), req.getChunkY());
            if (chunk == null) {
                log.error("Failed to generate chunk ({}, {})", req.getChunkX(), req.getChunkY());
                return;
            }
        }
    }

    private void sendInitialChunks(Connection connection, PlayerData pd) {
        int px = (int) pd.getX();
        int py = (int) pd.getY();
        int radius = 2;
        int startX = px / 16 - radius;
        int endX = px / 16 + radius;
        int startY = py / 16 - radius;
        int endY = py / 16 + radius;

        for (int cx = startX; cx <= endX; cx++) {
            for (int cy = startY; cy <= endY; cy++) {
                ChunkUpdate chunk = multiplayerService.getChunkData(cx, cy);
                if (chunk == null) continue;

                NetworkProtocol.ChunkData cd = new NetworkProtocol.ChunkData();
                cd.setChunkX(cx);
                cd.setChunkY(cy);
                cd.setTiles(chunk.getTiles());
                cd.setObjects(chunk.getObjects());
                connection.sendTCP(cd);
            }
        }
    }


    @Override
    public void broadcast(Object message) {
        if (server != null && running) {
            server.sendToAllTCP(message);
        } else {
            log.warn("Cannot broadcast message, server not running.");
        }
    }

    @Override
    public synchronized void stopServer() {
        if (!running) {
            log.warn("Attempt to stop server that is not running.");
            return;
        }

        log.info("Beginning server shutdown sequence...");
        running = false;

        try {
            // 1. Notify clients of shutdown
            log.info("Notifying connected clients of shutdown...");
            NetworkProtocol.ServerShutdownNotice notice = new NetworkProtocol.ServerShutdownNotice();
            notice.setMessage("Server is shutting down...");
            broadcast(notice);

            // 2. Trigger disconnect events
            for (String username : connectionUserMap.values()) {
                eventBus.fireEvent(new PlayerLeaveEvent(username));
            }

            // 3. Save world state
            log.info("Saving world state...");
            worldService.saveWorldData();

            // 4. Wait briefly for clients to process shutdown
            Thread.sleep(1000);

            // 5. Clean up network resources
            if (server != null) {
                log.info("Stopping network server...");
                try {
                    server.close();
                } catch (Exception e) {
                    log.error("Error closing server: {}", e.getMessage());
                } finally {
                    server.stop();
                }
            }

            // 6. Clean up caches and executors
            log.info("Cleaning up resources...");
            if (cacheCleanupExecutor != null) {
                cacheCleanupExecutor.shutdown();
                if (!cacheCleanupExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                    cacheCleanupExecutor.shutdownNow();
                }
            }

            // 7. Clear all maps and collections
            chunkRequestTimes.clear();
            pendingChunkRequests.clear();
            clientChunkCache.clear();
            connectionUserMap.clear();

            log.info("Server shutdown completed successfully");

        } catch (Exception e) {
            log.error("Error during server shutdown: {}", e.getMessage(), e);
        } finally {
            server = null;
        }
    }
    @Override
    public void processMessages(float delta) {
        multiplayerService.tick(delta);
        var objectUpdates = multiplayerService.getAllWorldObjectUpdates();
        if (!objectUpdates.isEmpty()) {
            NetworkProtocol.WorldObjectsUpdate wUpdate = new NetworkProtocol.WorldObjectsUpdate();
            wUpdate.setObjects(objectUpdates);
            broadcast(wUpdate);
        }
    }
}

================
File: main/java/io.github.minemon/multiplayer/service/impl/MultiplayerServiceImpl.java
================
package io.github.minemon.multiplayer.service.impl;

import io.github.minemon.multiplayer.model.ChunkUpdate;
import io.github.minemon.multiplayer.model.PlayerSyncData;
import io.github.minemon.multiplayer.model.WorldObjectUpdate;
import io.github.minemon.multiplayer.service.MultiplayerService;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.*;

import org.springframework.core.env.Environment;
import org.springframework.core.env.Profiles;

@Service
@Slf4j
public class MultiplayerServiceImpl implements MultiplayerService {

    private final WorldService worldService;


    private final boolean isServer;
    private final Set<String> connectedPlayers = Collections.synchronizedSet(new HashSet<>());


    private final List<WorldObjectUpdate> pendingObjectUpdates = Collections.synchronizedList(new ArrayList<>());

    @Autowired
    public MultiplayerServiceImpl(WorldService worldService,
                                  Environment env ) {
        this.worldService = worldService;
        this.isServer = env.acceptsProfiles(Profiles.of("server"));
    }

    @Override
    public void playerConnected(String username) {
        if (!isServer) {
            log.warn("Client attempted to handle player connection - ignoring");
            return;
        }
        worldService.initIfNeeded();
        PlayerData pd = worldService.getPlayerData(username);
        if (pd == null) {
            pd = new PlayerData(username, 0, 0);
            worldService.setPlayerData(pd);
        }
        connectedPlayers.add(username);
    }

    @Override
    public void playerDisconnected(String username) {
        if (!isServer) {
            log.warn("Client attempted to handle player disconnection - ignoring");
            return;
        }
        connectedPlayers.remove(username);
    }

    @Override
    public PlayerData getPlayerData(String username) {
        return worldService.getPlayerData(username);
    }

    @Override
    public void updatePlayerData(PlayerData data) {
        if (!isServer) {
            log.warn("Client attempted to handle player disconnection - ignoring");
            return;
        }


        worldService.setPlayerData(data);
    }

    @Override
    public ChunkUpdate getChunkData(int chunkX, int chunkY) {
        if (!isServer) {
            log.warn("Client attempted to handle player disconnection - ignoring");
            return null;
        }
        int[][] tiles = worldService.getChunkTiles(chunkX, chunkY);
        if (tiles == null) return null;

        var wd = worldService.getWorldData();
        if (wd == null) return null;

        String key = chunkX + "," + chunkY;
        var chunkData = wd.getChunks().get(key);
        if (chunkData == null) return null;

        List<WorldObject> objs = chunkData.getObjects();

        ChunkUpdate update = new ChunkUpdate();
        update.setChunkX(chunkX);
        update.setChunkY(chunkY);
        update.setTiles(tiles);
        update.setObjects(objs);
        return update;
    }

    @Override
    public Map<String, PlayerSyncData> getAllPlayerStates() {
        if (!isServer) {
            log.warn("Client attempted to get all player states - ignoring");
            return Collections.emptyMap();
        }
        Map<String, PlayerSyncData> states = new HashMap<>();
        for (String user : connectedPlayers) {
            PlayerData pd = worldService.getPlayerData(user);
            if (pd != null) {
                states.put(user, PlayerSyncData.fromPlayerData(pd));
            }
        }
        return states;
    }

    @Override
    public List<WorldObjectUpdate> getAllWorldObjectUpdates() {
        List<WorldObjectUpdate> snapshot;
        synchronized (pendingObjectUpdates) {
            snapshot = new ArrayList<>(pendingObjectUpdates);
            pendingObjectUpdates.clear();
        }
        return snapshot;
    }

    @Override
    public void broadcastPlayerState(PlayerData data) {


    }

    @Override
    public void broadcastChunkUpdate(ChunkUpdate chunk) {

    }

    @Override
    public void broadcastWorldObjectUpdate(WorldObjectUpdate objUpdate) {
        if (!isServer) {
            log.warn("Client attempted to broadcast world object update - ignoring");
            return;
        }
        synchronized (pendingObjectUpdates) {
            pendingObjectUpdates.add(objUpdate);
        }
    }

    @Override
    public void tick(float delta) {

    }
}

================
File: main/java/io.github.minemon/multiplayer/service/impl/ServerCleanupService.java
================
package io.github.minemon.multiplayer.service.impl;

import jakarta.annotation.PreDestroy;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;

@Service
@Slf4j
public class ServerCleanupService {
    private static final long SHUTDOWN_TIMEOUT_SECONDS = 5;

    public void cleanupExecutor(ExecutorService executor, String executorName) {
        log.info("Shutting down {} executor service...", executorName);
        executor.shutdown();
        try {
            if (!executor.awaitTermination(SHUTDOWN_TIMEOUT_SECONDS, TimeUnit.SECONDS)) {
                log.warn("{} executor did not terminate in {} seconds, forcing shutdown...",
                        executorName, SHUTDOWN_TIMEOUT_SECONDS);
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            log.error("{} executor shutdown interrupted", executorName);
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    @PreDestroy
    public void preDestroy() {
        log.info("ServerCleanupService shutting down...");
    }
}

================
File: main/java/io.github.minemon/multiplayer/service/impl/ServerConnectionServiceImpl.java
================
package io.github.minemon.multiplayer.service.impl;

import com.badlogic.gdx.utils.Json;
import io.github.minemon.multiplayer.model.ServerConnectionConfig;
import io.github.minemon.multiplayer.service.ServerConnectionService;
import io.github.minemon.core.service.FileAccessService;
import jakarta.annotation.PostConstruct;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service
@Primary
@Profile("client")
public class ServerConnectionServiceImpl implements ServerConnectionService {

    private final List<ServerConnectionConfig> serverList = new ArrayList<>();
    private final FileAccessService fileAccessService;
    private ServerConnectionConfig currentConfig;

    public ServerConnectionServiceImpl(FileAccessService fileAccessService) {
        this.fileAccessService = fileAccessService;
    }

    @PostConstruct
    public void init() {
        loadServersFromFile();

        if (serverList.isEmpty()) {
            ServerConnectionConfig defaultServer = new ServerConnectionConfig();
            defaultServer.setServerName("Localhost");
            defaultServer.setServerIP("127.0.0.1");
            defaultServer.setTcpPort(54555);
            defaultServer.setUdpPort(54777);
            defaultServer.setMotd("Welcome!");
            defaultServer.setMaxPlayers(20);
            defaultServer.setRememberMe(false);
            serverList.add(defaultServer);
        }

        currentConfig = serverList.get(0);
    }
    @Override
    public void saveConfig(ServerConnectionConfig config) {
        ensureInitialized();

        boolean found = false;
        for (int i = 0; i < serverList.size(); i++) {
            ServerConnectionConfig s = serverList.get(i);
            if (s.getServerName().equals(config.getServerName()) && s.getServerIP().equals(config.getServerIP())) {
                serverList.set(i, config);
                found = true;
                break;
            }
        }

        if (!found) {
            serverList.add(config);
        }

        currentConfig = config;
        saveServersToFile();
        System.out.println("Server configuration saved: " + config);
    }

    @Override
    public ServerConnectionConfig loadConfig() {
        ensureInitialized();
        return currentConfig;
    }

    @Override
    public List<ServerConnectionConfig> listServers() {
        ensureInitialized();
        return new ArrayList<>(serverList);
    }

    @Override
    public void addServer(ServerConnectionConfig config) {
        ensureInitialized();
        serverList.add(config);
        saveServersToFile();
        System.out.println("Server added: " + config);
    }

    @Override
    public void deleteServer(ServerConnectionConfig config) {
        ensureInitialized();
        serverList.removeIf(s ->
                s.getServerName().equals(config.getServerName()) &&
                        s.getServerIP().equals(config.getServerIP())
        );
        saveServersToFile();
        System.out.println("Server deleted: " + config);
    }

    private void ensureInitialized() {
        if (currentConfig == null) {
            throw new IllegalStateException("ServerConnectionService is not initialized.");
        }
    }

    private void saveServersToFile() {
        Json json = new Json();
        String data = json.toJson(serverList);
        fileAccessService.writeFile("data/servers.json", data);
    }

    @SuppressWarnings("unchecked")
    private void loadServersFromFile() {
        if (fileAccessService.exists("data/servers.json")) {
            Json json = new Json();
            List<ServerConnectionConfig> loaded = json.fromJson(ArrayList.class, ServerConnectionConfig.class, fileAccessService.readFile("data/servers.json"));
            serverList.clear();
            if (loaded != null) {
                serverList.addAll(loaded);
            }
        }
    }
}

================
File: main/java/io.github.minemon/multiplayer/service/MultiplayerClient.java
================
package io.github.minemon.multiplayer.service;

import io.github.minemon.multiplayer.model.PlayerSyncData;

import java.util.Map;

public interface MultiplayerClient {
    interface LoginResponseListener {
        void onLoginResponse(boolean success, String message, String username, int startX, int startY);
    }
    boolean isPendingChunkRequest(int chunkX, int chunkY);
    Map<String, PlayerSyncData> getPlayerStates();

    interface CreateUserResponseListener {
        void onCreateUserResponse(boolean success, String message);
    }

    void setLoginResponseListener(LoginResponseListener listener);
    void setCreateUserResponseListener(CreateUserResponseListener listener);
    void connect(String serverIP, int tcpPort, int udpPort);
    void login(String username, String password);
    void createUser(String username, String password);
    void disconnect();
    boolean isConnected();
    void sendPlayerMove(float x, float y, boolean running, boolean moving, String direction);
    void requestChunk(int chunkX, int chunkY);
    void update(float delta);
    void sendMessage(Object msg);

    // New methods for handling pending actions
    void setPendingLoginRequest(Runnable action);
    void setPendingCreateUserRequest(Runnable action);
}

================
File: main/java/io.github.minemon/multiplayer/service/MultiplayerServer.java
================
package io.github.minemon.multiplayer.service;

public interface MultiplayerServer {
    void startServer(int tcpPort, int udpPort);
    void stopServer();
    void broadcast(Object message);
    void processMessages(float delta);
}

================
File: main/java/io.github.minemon/multiplayer/service/MultiplayerService.java
================
package io.github.minemon.multiplayer.service;

import io.github.minemon.player.model.PlayerData;
import io.github.minemon.multiplayer.model.ChunkUpdate;
import io.github.minemon.multiplayer.model.PlayerSyncData;
import io.github.minemon.multiplayer.model.WorldObjectUpdate;

import java.util.List;
import java.util.Map;

public interface MultiplayerService {
    void playerConnected(String username);
    void playerDisconnected(String username);

    PlayerData getPlayerData(String username);
    void updatePlayerData(PlayerData data);

    ChunkUpdate getChunkData(int chunkX, int chunkY);
    Map<String, PlayerSyncData> getAllPlayerStates();
    List<WorldObjectUpdate> getAllWorldObjectUpdates();

    void broadcastPlayerState(PlayerData data);
    void broadcastChunkUpdate(ChunkUpdate chunk);
    void broadcastWorldObjectUpdate(WorldObjectUpdate objUpdate);
    void tick(float delta);
}

================
File: main/java/io.github.minemon/multiplayer/service/ServerConnectionService.java
================
package io.github.minemon.multiplayer.service;

import io.github.minemon.multiplayer.model.ServerConnectionConfig;
import java.util.List;

public interface ServerConnectionService {
    void saveConfig(ServerConnectionConfig config);
    ServerConnectionConfig loadConfig();

    List<ServerConnectionConfig> listServers();
    void addServer(ServerConnectionConfig config);
    void deleteServer(ServerConnectionConfig config);
}

================
File: main/java/io.github.minemon/NetworkProtocol.java
================
package io.github.minemon;

import com.esotericsoftware.kryo.Kryo;
import io.github.minemon.chat.model.ChatMessage;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.utils.UUIDSerializer;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.multiplayer.model.PlayerSyncData;
import io.github.minemon.multiplayer.model.WorldObjectUpdate;
import lombok.Data;

import java.util.*;

public final class NetworkProtocol {

    private NetworkProtocol() {
    }

    public static void registerClasses(Kryo kryo) {
        kryo.register(UUID.class, new UUIDSerializer());
        kryo.register(java.util.UUID.class);
        kryo.register(ChatMessage.class);

        kryo.register(PlayerData.class);
        kryo.register(WorldObject.class);
        kryo.register(PlayerSyncData.class);
        kryo.register(WorldObjectUpdate.class);

        kryo.register(ServerShutdownNotice.class);

        kryo.register(ArrayList.class);
        kryo.register(HashMap.class);
        kryo.register(HashSet.class);
        kryo.register(List.class);
        kryo.register(Map.class);
        kryo.register(Set.class);

        kryo.register(LoginRequest.class);
        kryo.register(LoginResponse.class);
        kryo.register(PlayerMoveRequest.class);
        kryo.register(PlayerStatesUpdate.class);
        kryo.register(ChunkRequest.class);
        kryo.register(ChunkData.class);
        kryo.register(WorldObjectsUpdate.class);

        kryo.register(CreateUserRequest.class);
        kryo.register(CreateUserResponse.class);

        kryo.setRegistrationRequired(false);
        kryo.setReferences(false);
    }

    @Data
    public static class LoginRequest {
        private String username;
        private String password;
        private long timestamp;
    }
    @Data
    public static class CreateUserRequest {
        private String username;
        private String password;
    }

    @Data
    public static class CreateUserResponse {
        private boolean success;
        private String message;
    }
    @Data
    public static class ServerShutdownNotice {
        private String message;
    }
    @Data
    public static class LoginResponse {
        private boolean success;
        private String message;
        private String username;
        private int x;
        private int y;
        private long timestamp;
    }

    @Data
    public static class PlayerMoveRequest {
        private float x;
        private float y;
        private boolean running;
        private boolean moving;
        private String direction;
    }

    @Data
    public static class PlayerStatesUpdate {
        private Map<String, PlayerSyncData> players;
    }

    @Data
    public static class ChunkRequest {
        private int chunkX;
        private int chunkY;
        private long timestamp;
    }

    @Data
    public static class ChunkData {
        private int chunkX;
        private int chunkY;
        private int[][] tiles;
        private List<WorldObject> objects;
    }

    @Data
    public static class WorldObjectsUpdate {
        private List<WorldObjectUpdate> objects;
    }
}

================
File: main/java/io.github.minemon/player/config/PlayerConfig.java
================
package io.github.minemon.player.config;

import io.github.minemon.input.InputService;
import io.github.minemon.player.service.PlayerAnimationService;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.player.service.impl.PlayerServiceImpl;
import io.github.minemon.world.service.WorldService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Lazy;


@Configuration
@EnableConfigurationProperties(PlayerProperties.class)
public class PlayerConfig {

    private final InputService inputService;
    private final PlayerProperties playerProperties;

    @Autowired
    @Lazy
    private WorldService worldService;

    @Autowired
    public PlayerConfig(InputService inputService, PlayerProperties playerProperties, WorldService worldService) {
        this.inputService = inputService;
        this.playerProperties = playerProperties;
        this.worldService = worldService;

    }

    
    @Bean
    public PlayerService playerService(
            PlayerAnimationService animationService
    ) {
        return new PlayerServiceImpl(animationService, inputService, playerProperties, worldService);
    }
}

================
File: main/java/io.github.minemon/player/config/PlayerProperties.java
================
package io.github.minemon.player.config;

import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;


@Setter
@Getter
@Configuration
@ConfigurationProperties(prefix = "player")
public class PlayerProperties {

    
    private String username = "Player";

    
    private float walkStepDuration = 0.3f;

    
    private float runStepDuration = 0.15f;



}

================
File: main/java/io.github.minemon/player/event/PlayerJoinEvent.java
================
package io.github.minemon.player.event;

import io.github.minemon.event.Event;
import lombok.Getter;

@Getter
public class PlayerJoinEvent implements Event {
    private final String username;

    public PlayerJoinEvent(String username) {
        this.username = username;
    }

}

================
File: main/java/io.github.minemon/player/event/PlayerLeaveEvent.java
================
package io.github.minemon.player.event;

import io.github.minemon.event.Event;
import lombok.Getter;

@Getter
public class PlayerLeaveEvent implements Event {
    private final String username;

    public PlayerLeaveEvent(String username) {
        this.username = username;
    }

}

================
File: main/java/io.github.minemon/player/event/PlayerMoveEvent.java
================
package io.github.minemon.player.event;

import io.github.minemon.event.Event;
import io.github.minemon.player.model.PlayerData;
import lombok.Getter;

@Getter
public class PlayerMoveEvent implements Event {
    private final PlayerData playerData;

    public PlayerMoveEvent(PlayerData playerData) {
        this.playerData = playerData;
    }

}

================
File: main/java/io.github.minemon/player/model/PlayerData.java
================
package io.github.minemon.player.model;

import lombok.Data;

@Data
public class PlayerData {
    private String username;

    private float x;
    private float y;
    private boolean wantsToRun;
    private boolean moving;
    private PlayerDirection direction = PlayerDirection.DOWN;

    public PlayerData() {}

    public PlayerData(String username, float x, float y) {
        this.username = username;
        this.x = x;
        this.y = y;
        this.wantsToRun = false;
        this.moving = false;
    }
}

================
File: main/java/io.github.minemon/player/model/PlayerDirection.java
================
package io.github.minemon.player.model;

public enum PlayerDirection {
    UP, DOWN, LEFT, RIGHT
}

================
File: main/java/io.github.minemon/player/model/PlayerModel.java
================
package io.github.minemon.player.model;

import com.badlogic.gdx.math.Vector2;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class PlayerModel {
    public final int TILE_SIZE = 32;

    private Vector2 position;
    private Vector2 startPosition;
    private Vector2 targetPosition;

    private PlayerDirection direction;
    private boolean moving;
    private boolean running;

    private float movementTime = 0f;
    private float movementDuration = 0.2f;
    private float runSpeedMultiplier = 1.75f;

    private float stateTime = 0f;

    public PlayerModel(int startTileX, int startTileY) {
        float x = startTileX * TILE_SIZE;
        float y = startTileY * TILE_SIZE;
        this.position = new Vector2(x, y);
        this.targetPosition = new Vector2(x, y);
        this.startPosition = new Vector2(x, y);
        this.direction = PlayerDirection.DOWN;
        this.moving = false;
        this.running = false;
    }

    public void setTargetPosition(float x, float y) {
        this.targetPosition.set(x, y);
    }

    public void setStartPosition(float x, float y) {
        this.startPosition.set(x, y);
    }

    public void setPosition(float x, float y) {
        this.position.set(x, y);
    }
}

================
File: main/java/io.github.minemon/player/service/impl/PlayerAnimationServiceImpl.java
================
package io.github.minemon.player.service.impl;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.utils.Array;
import io.github.minemon.player.model.PlayerDirection;
import io.github.minemon.player.service.PlayerAnimationService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Comparator;

@Service
@Slf4j
public class PlayerAnimationServiceImpl implements PlayerAnimationService {

    /**
     * Increase the frame duration for walking to slow down the animation slightly.
     *
     * With 3 frames, 0.10f means ~10 FPS (1 / 0.10). Feel free to adjust as needed.
     */
    private static final float WALK_FRAME_DURATION = 0.10f;

    /**
     * Increase the frame duration for running but still keep it slightly faster than walk.
     *
     * With 3 frames, 0.06f means ~16.7 FPS (1 / 0.06). Adjust if you need a different feel.
     */
    private static final float RUN_FRAME_DURATION = 0.06f;

    private TextureRegion standingUp, standingDown, standingLeft, standingRight;
    private Animation<TextureRegion> walkUp, walkDown, walkLeft, walkRight;
    private Animation<TextureRegion> runUp, runDown, runLeft, runRight;
    private boolean initialized = false;

    public PlayerAnimationServiceImpl() {
    }

    @Override
    public TextureRegion getCurrentFrame(PlayerDirection direction, boolean moving, boolean running, float stateTime) {
        if (!moving) {
            return getStandingFrame(direction);
        }

        Animation<TextureRegion> anim = getMovementAnimation(direction, running);
        return anim.getKeyFrame(stateTime, true);
    }

    @Override
    public TextureRegion getStandingFrame(PlayerDirection direction) {
        return switch (direction) {
            case UP -> standingUp;
            case DOWN -> standingDown;
            case LEFT -> standingLeft;
            case RIGHT -> standingRight;
        };
    }

    private Animation<TextureRegion> getMovementAnimation(PlayerDirection direction, boolean running) {
        return switch (direction) {
            case UP -> running ? runUp : walkUp;
            case DOWN -> running ? runDown : walkDown;
            case LEFT -> running ? runLeft : walkLeft;
            case RIGHT -> running ? runRight : walkRight;
        };
    }

    private void loadAnimations() {
        String atlasPath = "assets/atlas/boy-gfx-atlas.atlas";
        log.info("Loading TextureAtlas from path: {}", atlasPath);
        TextureAtlas atlas = new TextureAtlas(Gdx.files.internal(atlasPath));

        log.info("Available regions in the atlas:");
        for (TextureAtlas.AtlasRegion region : atlas.getRegions()) {
            log.info("- {} (index: {})", region.name, region.index);
        }

        // Create the walking animations (3 frames expected, but will work with however many frames are found)
        walkUp = createLoopAnimation(atlas, "boy_walk_up", WALK_FRAME_DURATION);
        walkDown = createLoopAnimation(atlas, "boy_walk_down", WALK_FRAME_DURATION);
        walkLeft = createLoopAnimation(atlas, "boy_walk_left", WALK_FRAME_DURATION);
        walkRight = createLoopAnimation(atlas, "boy_walk_right", WALK_FRAME_DURATION);

        // Standing frames are simply the first key frame of each animation
        standingUp = walkUp.getKeyFrames()[0];
        standingDown = walkDown.getKeyFrames()[0];
        standingLeft = walkLeft.getKeyFrames()[0];
        standingRight = walkRight.getKeyFrames()[0];

        // Create the running animations (3 frames expected, but will work with however many frames are found)
        runUp = createLoopAnimation(atlas, "boy_run_up", RUN_FRAME_DURATION);
        runDown = createLoopAnimation(atlas, "boy_run_down", RUN_FRAME_DURATION);
        runLeft = createLoopAnimation(atlas, "boy_run_left", RUN_FRAME_DURATION);
        runRight = createLoopAnimation(atlas, "boy_run_right", RUN_FRAME_DURATION);
    }

    public void initAnimationsIfNeeded() {
        if (!initialized) {
            loadAnimations();
            initialized = true;
        }
    }

    private Animation<TextureRegion> createLoopAnimation(TextureAtlas atlas, String baseName, float duration) {
        Array<TextureAtlas.AtlasRegion> regions = atlas.findRegions(baseName);
        if (regions.size == 0) {
            log.error("No regions found for animation: {}", baseName);
            throw new RuntimeException("No regions found for animation: " + baseName);
        }

        // Sort frames by index to ensure correct ordering
        regions.sort(Comparator.comparingInt(a -> a.index));

        log.info("Creating animation '{}', frames: {}, frameDuration: {}",
                baseName, regions.size, duration);

        Animation<TextureRegion> anim = new Animation<>(duration, regions, Animation.PlayMode.LOOP);
        log.debug("Created loop animation: {}", baseName);
        return anim;
    }

    public void dispose() {
    }
}

================
File: main/java/io.github.minemon/player/service/impl/PlayerServiceImpl.java
================
package io.github.minemon.player.service.impl;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import io.github.minemon.event.EventBus;
import io.github.minemon.input.InputService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.config.PlayerProperties;
import io.github.minemon.player.event.PlayerMoveEvent;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.model.PlayerDirection;
import io.github.minemon.player.model.PlayerModel;
import io.github.minemon.player.service.PlayerAnimationService;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.world.model.ChunkData;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.ArrayList;
import java.util.List;

@Slf4j
public class PlayerServiceImpl implements PlayerService {
    public final int TILE_SIZE = 32;

    private final PlayerModel playerModel;
    private final PlayerAnimationService animationService;
    private final WorldService worldService;
    private String username;
    private final float walkStepDuration;
    private final float runStepDuration;
    private final InputService inputService;
    private PlayerDirection bufferedDirection = null;

    @Autowired
    private EventBus eventBus;

    @Autowired
    private MultiplayerClient multiplayerClient;

    public PlayerServiceImpl(
            PlayerAnimationService animationService,
            InputService inputService,
            PlayerProperties playerProperties,
            WorldService worldService
    ) {
        this.playerModel = new PlayerModel(0, 0);
        this.animationService = animationService;
        this.inputService = inputService;
        this.username = playerProperties.getUsername();
        this.walkStepDuration = playerProperties.getWalkStepDuration();
        this.runStepDuration = playerProperties.getRunStepDuration();
        this.playerModel.setRunning(false);
        this.worldService = worldService;
    }

    @Override
    public void move(PlayerDirection direction) {
        // If currently mid-move, buffer the new direction for after finishing
        if (playerModel.isMoving()) {
            log.debug("Currently moving. Buffering direction: {}", direction);
            this.bufferedDirection = direction;
            return;
        }

        float currentX = playerModel.getPosition().x;
        float currentY = playerModel.getPosition().y;
        float tileSize = TILE_SIZE;

        int currentTileX = (int) (currentX / tileSize);
        int currentTileY = (int) (currentY / tileSize);

        // Calculate the attempted tile
        int targetTileX = currentTileX;
        int targetTileY = currentTileY;
        switch (direction) {
            case UP -> targetTileY += 1;
            case DOWN -> targetTileY -= 1;
            case LEFT -> targetTileX -= 1;
            case RIGHT -> targetTileX += 1;
        }

        // Always set direction so we appear to face that way even if blocked
        playerModel.setDirection(direction);

        if (isColliding(targetTileX, targetTileY)) {
            log.debug("Collision at ({}, {}): no movement, but direction updated to {}",
                    targetTileX, targetTileY, direction);
            // No movement, remain idle, but direction is changed
            playerModel.setMoving(false);
            return;
        }

        // If passable, we do run/walk
        playerModel.setRunning(inputService.isRunning());
        float targetX = targetTileX * tileSize;
        float targetY = targetTileY * tileSize;

        playerModel.setStartPosition(currentX, currentY);
        playerModel.setTargetPosition(targetX, targetY);

        float duration = playerModel.isRunning() ? runStepDuration : walkStepDuration;
        playerModel.setMovementDuration(duration);

        // DO NOT reset stateTime, so the animation doesn't restart every step:
        // playerModel.setStateTime(0f);

        // We still reset movementTime for tile interpolation:
        playerModel.setMovementTime(0f);

        playerModel.setMoving(true);

        log.debug("Initiated movement: {}, Target=({}, {}), Duration={}",
                direction, targetX, targetY, duration);
    }


    private boolean isColliding(int tileX, int tileY) {
        int chunkX = tileX / 16;
        int chunkY = tileY / 16;
        int[][] chunkTiles = worldService.getChunkTiles(chunkX, chunkY);
        if (chunkTiles == null) return true;

        int localX = Math.floorMod(tileX, 16);
        int localY = Math.floorMod(tileY, 16);
        if (localX < 0 || localX >= 16 || localY < 0 || localY >= 16) return true;

        int tileID = chunkTiles[localX][localY];
        if (!worldService.getTileManager().isPassable(tileID)) {
            return true;
        }

        float tileSize = TILE_SIZE;
        Rectangle targetTileRect = new Rectangle(tileX * tileSize, tileY * tileSize, tileSize, tileSize);

        List<WorldObject> nearbyObjects = new ArrayList<>();

        for (int dx = -1; dx <= 1; dx++) {
            for (int dy = -1; dy <= 1; dy++) {
                int neighborChunkX = chunkX + dx;
                int neighborChunkY = chunkY + dy;
                String chunkKey = neighborChunkX + "," + neighborChunkY;
                ChunkData chunkData = worldService.getWorldData().getChunks().get(chunkKey);
                if (chunkData != null && chunkData.getObjects() != null) {
                    nearbyObjects.addAll(chunkData.getObjects());
                }
            }
        }

        for (WorldObject obj : nearbyObjects) {
            if (!obj.isCollidable()) continue;
            Rectangle collisionBox = obj.getCollisionBox();
            if (collisionBox == null) continue;
            if (collisionBox.overlaps(targetTileRect)) {
                log.debug("Collision detected with object {} at tile ({}, {})", obj.getId(), tileX, tileY);
                return true;
            }
        }

        return false;
    }

    @Override
    public void update(float delta) {
        playerModel.setStateTime(playerModel.getStateTime() + delta);

        if (playerModel.isMoving()) {
            float progress = playerModel.getMovementTime() / playerModel.getMovementDuration();
            progress = Math.min(progress + (delta / playerModel.getMovementDuration()), 1f);

            float smoothed = smoothstep(progress);

            float newX = lerp(playerModel.getStartPosition().x, playerModel.getTargetPosition().x, smoothed);
            float newY = lerp(playerModel.getStartPosition().y, playerModel.getTargetPosition().y, smoothed);
            playerModel.setPosition(newX, newY);

            playerModel.setMovementTime(playerModel.getMovementTime() + delta);

            if (progress >= 1f) {
                playerModel.setMoving(false);
                playerModel.setPosition(playerModel.getTargetPosition().x, playerModel.getTargetPosition().y);

                // Movement completed, send updated position to the server
                PlayerData pd = getPlayerData();
                worldService.setPlayerData(pd);
                multiplayerClient.sendPlayerMove(
                        pd.getX(),
                        pd.getY(),
                        pd.isWantsToRun(),
                        pd.isMoving(),
                        pd.getDirection().name().toLowerCase()
                );

                if (bufferedDirection != null) {
                    PlayerDirection nextDir = bufferedDirection;
                    bufferedDirection = null;
                    move(nextDir);
                } else {
                    PlayerDirection dir = inputService.getCurrentDirection();
                    if (dir != null) {
                        move(dir);
                    } else {
                        playerModel.setMoving(false);
                        playerModel.setRunning(false);
                    }
                }
            }
        } else {
            PlayerDirection dir = inputService.getCurrentDirection();
            if (dir != null) {
                move(dir);
            } else {
                playerModel.setMoving(false);
                playerModel.setRunning(false);
            }
        }

        if (!playerModel.isMoving()) {
            eventBus.fireEvent(new PlayerMoveEvent(getPlayerData()));
        }
    }

    private float lerp(float a, float b, float t) {
        return a + (b - a) * t;
    }

    private float smoothstep(float x) {
        x = Math.max(0f, Math.min(x, 1f));
        return x * x * (3f - 2f * x);
    }

    @Override
    public void render(SpriteBatch batch) {
        TextureRegion frame = animationService.getCurrentFrame(
                playerModel.getDirection(),
                playerModel.isMoving(),
                playerModel.isRunning(),
                playerModel.getStateTime()
        );
        batch.draw(frame, playerModel.getPosition().x, playerModel.getPosition().y);
    }

    @Override
    public PlayerData getPlayerData() {
        float tileX = playerModel.getPosition().x / TILE_SIZE;
        float tileY = playerModel.getPosition().y / TILE_SIZE;
        return new PlayerData(username, tileX, tileY);
    }

    @Override
    public void setPlayerData(PlayerData data) {
        if (data.getUsername() != null && !data.getUsername().isEmpty()) {
            this.username = data.getUsername();
        }

        int tileX = (int) data.getX();
        int tileY = (int) data.getY();
        setPosition(tileX, tileY);

        log.debug("Player data updated: username={}, x={}, y={}", data.getUsername(), data.getX(), data.getY());

        worldService.setPlayerData(data);
    }

    @Override
    public void setRunning(boolean running) {
        playerModel.setRunning(running);
        log.debug("Set running to {}", running);
    }

    @Override
    public void setPosition(int tileX, int tileY) {
        float x = tileX * TILE_SIZE;
        float y = tileY * TILE_SIZE;
        playerModel.setPosition(x, y);
        playerModel.setStartPosition(x, y);
        playerModel.setTargetPosition(x, y);
        playerModel.setMoving(false);
        playerModel.setMovementTime(0f);
        playerModel.setStateTime(0f);
        this.bufferedDirection = null;
        log.debug("Set position to ({}, {})", x, y);
    }
}

================
File: main/java/io.github.minemon/player/service/PlayerAnimationService.java
================
package io.github.minemon.player.service;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.minemon.player.model.PlayerDirection;

public interface PlayerAnimationService {
    TextureRegion getCurrentFrame(PlayerDirection direction, boolean moving, boolean running, float stateTime);
    TextureRegion getStandingFrame(PlayerDirection direction);
    void initAnimationsIfNeeded();
}

================
File: main/java/io.github.minemon/player/service/PlayerService.java
================
package io.github.minemon.player.service;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.model.PlayerDirection;

public interface PlayerService {
    void move(PlayerDirection direction);
    void update(float delta);
    void render(SpriteBatch batch);

    PlayerData getPlayerData();
    void setPlayerData(PlayerData data);

    void setRunning(boolean running);
    void setPosition(int tileX, int tileY);
}

================
File: main/java/io.github.minemon/plugin/Plugin.java
================
package io.github.minemon.plugin;

public interface Plugin {
    void onEnable();
    void onDisable();
}

================
File: main/java/io.github.minemon/plugin/PluginManager.java
================
package io.github.minemon.plugin;

import io.github.minemon.event.EventBus;
import lombok.Getter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.*;
import java.util.*;

@Component
public class PluginManager {
    private static final Logger logger = LoggerFactory.getLogger(PluginManager.class);
    private final List<Plugin> plugins = new ArrayList<>();
    @Getter
    private final EventBus eventBus;

    public PluginManager(EventBus eventBus) {
        this.eventBus = eventBus;
    }

    
    public void loadPlugins(Path pluginsDir) {
        if (Files.notExists(pluginsDir)) {
            try {
                Files.createDirectories(pluginsDir);
            } catch (IOException e) {
                logger.error("Failed to create plugins directory: {}", e.getMessage());
                return;
            }
        }

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(pluginsDir, "*.jar")) {
            for (Path jarPath : stream) {
                loadPluginFromJar(jarPath);
            }
        } catch (IOException e) {
            logger.error("Error reading plugins directory: {}", e.getMessage());
        }
    }

    
    private void loadPluginFromJar(Path jarPath) {
        logger.info("Loading plugin from JAR: {}", jarPath);
        try {
            URL jarUrl = jarPath.toUri().toURL();
            try (URLClassLoader loader = new URLClassLoader(new URL[]{jarUrl}, this.getClass().getClassLoader())) {
                ServiceLoader<Plugin> serviceLoader = ServiceLoader.load(Plugin.class, loader);
                for (Plugin plugin : serviceLoader) {
                    registerPlugin(plugin);
                }
            }
        } catch (IOException e) {
            logger.error("Failed to load plugin JAR {}: {}", jarPath, e.getMessage());
        }
    }

    
    public void registerPlugin(Plugin plugin) {
        plugins.add(plugin);
        plugin.onEnable();
        logger.info("Enabled plugin: {}", plugin.getClass().getName());
    }

    public void unloadAll() {
        for (Plugin plugin : plugins) {
            plugin.onDisable();
            logger.info("Disabled plugin: {}", plugin.getClass().getName());
        }
        plugins.clear();
    }
}

================
File: main/java/io.github.minemon/utils/OpenSimplex2.java
================
package io.github.minemon.utils;

public class OpenSimplex2 {

    private static final long PRIME_X = 0x5205402B9270C86FL;
    private static final long PRIME_Y = 0x598CD327003817B5L;
    private static final long PRIME_Z = 0x5BCC226E9FA0BACBL;
    private static final long PRIME_W = 0x56CC5227E58F554BL;
    private static final long HASH_MULTIPLIER = 0x53A3F72DEEC546F5L;
    private static final long SEED_FLIP_3D = -0x52D547B2E96ED629L;
    private static final long SEED_OFFSET_4D = 0xE83DC3E0DA7164DL;

    private static final double ROOT2OVER2 = 0.7071067811865476;
    private static final double SKEW_2D = 0.366025403784439;
    private static final double UNSKEW_2D = -0.21132486540518713;

    private static final double ROOT3OVER3 = 0.577350269189626;
    private static final double FALLBACK_ROTATE_3D = 2.0 / 3.0;
    private static final double ROTATE_3D_ORTHOGONALIZER = UNSKEW_2D;

    private static final float SKEW_4D = -0.138196601125011f;
    private static final float UNSKEW_4D = 0.309016994374947f;
    private static final float LATTICE_STEP_4D = 0.2f;

    private static final int N_GRADS_2D_EXPONENT = 7;
    private static final int N_GRADS_3D_EXPONENT = 8;
    private static final int N_GRADS_4D_EXPONENT = 9;
    private static final int N_GRADS_2D = 1 << N_GRADS_2D_EXPONENT;
    private static final int N_GRADS_3D = 1 << N_GRADS_3D_EXPONENT;
    private static final int N_GRADS_4D = 1 << N_GRADS_4D_EXPONENT;

    private static final double NORMALIZER_2D = 0.01001634121365712;
    private static final double NORMALIZER_3D = 0.07969837668935331;
    private static final double NORMALIZER_4D = 0.0220065933241897;

    private static final float RSQUARED_2D = 0.5f;
    private static final float RSQUARED_3D = 0.6f;
    private static final float RSQUARED_4D = 0.6f;


    

    
    public static float noise2(long seed, double x, double y) {


        double s = SKEW_2D * (x + y);
        double xs = x + s, ys = y + s;

        return noise2_UnskewedBase(seed, xs, ys);
    }

    
    public static float noise2_ImproveX(long seed, double x, double y) {


        double xx = x * ROOT2OVER2;
        double yy = y * (ROOT2OVER2 * (1 + 2 * SKEW_2D));

        return noise2_UnskewedBase(seed, yy + xx, yy - xx);
    }

    
    private static float noise2_UnskewedBase(long seed, double xs, double ys) {


        int xsb = fastFloor(xs), ysb = fastFloor(ys);
        float xi = (float)(xs - xsb), yi = (float)(ys - ysb);


        long xsbp = xsb * PRIME_X, ysbp = ysb * PRIME_Y;


        float t = (xi + yi) * (float)UNSKEW_2D;
        float dx0 = xi + t, dy0 = yi + t;


        float value = 0;
        float a0 = RSQUARED_2D - dx0 * dx0 - dy0 * dy0;
        if (a0 > 0) {
            value = (a0 * a0) * (a0 * a0) * grad(seed, xsbp, ysbp, dx0, dy0);
        }


        float a1 = (float)(2 * (1 + 2 * UNSKEW_2D) * (1 / UNSKEW_2D + 2)) * t + ((float)(-2 * (1 + 2 * UNSKEW_2D) * (1 + 2 * UNSKEW_2D)) + a0);
        if (a1 > 0) {
            float dx1 = dx0 - (float)(1 + 2 * UNSKEW_2D);
            float dy1 = dy0 - (float)(1 + 2 * UNSKEW_2D);
            value += (a1 * a1) * (a1 * a1) * grad(seed, xsbp + PRIME_X, ysbp + PRIME_Y, dx1, dy1);
        }


        if (dy0 > dx0) {
            float dx2 = dx0 - (float)UNSKEW_2D;
            float dy2 = dy0 - (float)(UNSKEW_2D + 1);
            float a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if (a2 > 0) {
                value += (a2 * a2) * (a2 * a2) * grad(seed, xsbp, ysbp + PRIME_Y, dx2, dy2);
            }
        }
        else
        {
            float dx2 = dx0 - (float)(UNSKEW_2D + 1);
            float dy2 = dy0 - (float)UNSKEW_2D;
            float a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if (a2 > 0) {
                value += (a2 * a2) * (a2 * a2) * grad(seed, xsbp + PRIME_X, ysbp, dx2, dy2);
            }
        }

        return value;
    }

    
    public static float noise3_ImproveXY(long seed, double x, double y, double z) {




        double xy = x + y;
        double s2 = xy * ROTATE_3D_ORTHOGONALIZER;
        double zz = z * ROOT3OVER3;
        double xr = x + s2 + zz;
        double yr = y + s2 + zz;
        double zr = xy * -ROOT3OVER3 + zz;


        return noise3_UnrotatedBase(seed, xr, yr, zr);
    }

    
    public static float noise3_ImproveXZ(long seed, double x, double y, double z) {




        double xz = x + z;
        double s2 = xz * ROTATE_3D_ORTHOGONALIZER;
        double yy = y * ROOT3OVER3;
        double xr = x + s2 + yy;
        double zr = z + s2 + yy;
        double yr = xz * -ROOT3OVER3 + yy;


        return noise3_UnrotatedBase(seed, xr, yr, zr);
    }

    
    public static float noise3_Fallback(long seed, double x, double y, double z) {



        double r = FALLBACK_ROTATE_3D * (x + y + z);
        double xr = r - x, yr = r - y, zr = r - z;


        return noise3_UnrotatedBase(seed, xr, yr, zr);
    }

    
    private static float noise3_UnrotatedBase(long seed, double xr, double yr, double zr) {


        int xrb = fastRound(xr), yrb = fastRound(yr), zrb = fastRound(zr);
        float xri = (float)(xr - xrb), yri = (float)(yr - yrb), zri = (float)(zr - zrb);


        int xNSign = (int)(-1.0f - xri) | 1, yNSign = (int)(-1.0f - yri) | 1, zNSign = (int)(-1.0f - zri) | 1;


        float ax0 = xNSign * -xri, ay0 = yNSign * -yri, az0 = zNSign * -zri;


        long xrbp = xrb * PRIME_X, yrbp = yrb * PRIME_Y, zrbp = zrb * PRIME_Z;


        float value = 0;
        float a = (RSQUARED_3D - xri * xri) - (yri * yri + zri * zri);
        for (int l = 0; ; l++) {


            if (a > 0) {
                value += (a * a) * (a * a) * grad(seed, xrbp, yrbp, zrbp, xri, yri, zri);
            }


            if (ax0 >= ay0 && ax0 >= az0) {
                float b = a + ax0 + ax0;
                if (b > 1) {
                    b -= 1;
                    value += (b * b) * (b * b) * grad(seed, xrbp - xNSign * PRIME_X, yrbp, zrbp, xri + xNSign, yri, zri);
                }
            }
            else if (ay0 > ax0 && ay0 >= az0) {
                float b = a + ay0 + ay0;
                if (b > 1) {
                    b -= 1;
                    value += (b * b) * (b * b) * grad(seed, xrbp, yrbp - yNSign * PRIME_Y, zrbp, xri, yri + yNSign, zri);
                }
            }
            else
            {
                float b = a + az0 + az0;
                if (b > 1) {
                    b -= 1;
                    value += (b * b) * (b * b) * grad(seed, xrbp, yrbp, zrbp - zNSign * PRIME_Z, xri, yri, zri + zNSign);
                }
            }


            if (l == 1) break;


            ax0 = 0.5f - ax0;
            ay0 = 0.5f - ay0;
            az0 = 0.5f - az0;


            xri = xNSign * ax0;
            yri = yNSign * ay0;
            zri = zNSign * az0;


            a += (0.75f - ax0) - (ay0 + az0);


            xrbp += (xNSign >> 1) & PRIME_X;
            yrbp += (yNSign >> 1) & PRIME_Y;
            zrbp += (zNSign >> 1) & PRIME_Z;


            xNSign = -xNSign;
            yNSign = -yNSign;
            zNSign = -zNSign;


            seed ^= SEED_FLIP_3D;
        }

        return value;
    }

    
    public static float noise4_ImproveXYZ_ImproveXY(long seed, double x, double y, double z, double w) {

        double xy = x + y;
        double s2 = xy * -0.21132486540518699998;
        double zz = z * 0.28867513459481294226;
        double ww = w * 0.2236067977499788;
        double xr = x + (zz + ww + s2), yr = y + (zz + ww + s2);
        double zr = xy * -0.57735026918962599998 + (zz + ww);
        double wr = z * -0.866025403784439 + ww;

        return noise4_UnskewedBase(seed, xr, yr, zr, wr);
    }

    
    public static float noise4_ImproveXYZ_ImproveXZ(long seed, double x, double y, double z, double w) {

        double xz = x + z;
        double s2 = xz * -0.21132486540518699998;
        double yy = y * 0.28867513459481294226;
        double ww = w * 0.2236067977499788;
        double xr = x + (yy + ww + s2), zr = z + (yy + ww + s2);
        double yr = xz * -0.57735026918962599998 + (yy + ww);
        double wr = y * -0.866025403784439 + ww;

        return noise4_UnskewedBase(seed, xr, yr, zr, wr);
    }

    
    public static float noise4_ImproveXYZ(long seed, double x, double y, double z, double w) {

        double xyz = x + y + z;
        double ww = w * 0.2236067977499788;
        double s2 = xyz * -0.16666666666666666 + ww;
        double xs = x + s2, ys = y + s2, zs = z + s2, ws = -0.5 * xyz + ww;

        return noise4_UnskewedBase(seed, xs, ys, zs, ws);
    }

    
    public static float noise4_ImproveXY_ImproveZW(long seed, double x, double y, double z, double w) {

        double s2 = (x + y) * -0.178275657951399372 + (z + w) * 0.215623393288842828;
        double t2 = (z + w) * -0.403949762580207112 + (x + y) * -0.375199083010075342;
        double xs = x + s2, ys = y + s2, zs = z + t2, ws = w + t2;

        return noise4_UnskewedBase(seed, xs, ys, zs, ws);
    }

    
    public static float noise4_Fallback(long seed, double x, double y, double z, double w) {


        double s = SKEW_4D * (x + y + z + w);
        double xs = x + s, ys = y + s, zs = z + s, ws = w + s;

        return noise4_UnskewedBase(seed, xs, ys, zs, ws);
    }

    
    private static float noise4_UnskewedBase(long seed, double xs, double ys, double zs, double ws) {


        int xsb = fastFloor(xs), ysb = fastFloor(ys), zsb = fastFloor(zs), wsb = fastFloor(ws);
        float xsi = (float)(xs - xsb), ysi = (float)(ys - ysb), zsi = (float)(zs - zsb), wsi = (float)(ws - wsb);



        float siSum = (xsi + ysi) + (zsi + wsi);
        int startingLattice = (int)(siSum * 1.25);


        seed += startingLattice * SEED_OFFSET_4D;


        float startingLatticeOffset = startingLattice * -LATTICE_STEP_4D;
        xsi += startingLatticeOffset; ysi += startingLatticeOffset; zsi += startingLatticeOffset; wsi += startingLatticeOffset;


        float ssi = (siSum + startingLatticeOffset * 4) * UNSKEW_4D;


        long xsvp = xsb * PRIME_X, ysvp = ysb * PRIME_Y, zsvp = zsb * PRIME_Z, wsvp = wsb * PRIME_W;


        float value = 0;
        for (int i = 0; ; i++) {


            double score0 = 1.0 + ssi * (-1.0 / UNSKEW_4D);
            if (xsi >= ysi && xsi >= zsi && xsi >= wsi && xsi >= score0) {
                xsvp += PRIME_X;
                xsi -= 1;
                ssi -= UNSKEW_4D;
            }
            else if (ysi > xsi && ysi >= zsi && ysi >= wsi && ysi >= score0) {
                ysvp += PRIME_Y;
                ysi -= 1;
                ssi -= UNSKEW_4D;
            }
            else if (zsi > xsi && zsi > ysi && zsi >= wsi && zsi >= score0) {
                zsvp += PRIME_Z;
                zsi -= 1;
                ssi -= UNSKEW_4D;
            }
            else if (wsi > xsi && wsi > ysi && wsi > zsi && wsi >= score0) {
                wsvp += PRIME_W;
                wsi -= 1;
                ssi -= UNSKEW_4D;
            }


            float dx = xsi + ssi, dy = ysi + ssi, dz = zsi + ssi, dw = wsi + ssi;
            float a = (dx * dx + dy * dy) + (dz * dz + dw * dw);
            if (a < RSQUARED_4D) {
                a -= RSQUARED_4D;
                a *= a;
                value += a * a * grad(seed, xsvp, ysvp, zsvp, wsvp, dx, dy, dz, dw);
            }


            if (i == 4) break;


            xsi += LATTICE_STEP_4D; ysi += LATTICE_STEP_4D; zsi += LATTICE_STEP_4D; wsi += LATTICE_STEP_4D;
            ssi += LATTICE_STEP_4D * 4 * UNSKEW_4D;
            seed -= SEED_OFFSET_4D;


            if (i == startingLattice) {
                xsvp -= PRIME_X;
                ysvp -= PRIME_Y;
                zsvp -= PRIME_Z;
                wsvp -= PRIME_W;
                seed += SEED_OFFSET_4D * 5;
            }
        }

        return value;
    }

    

    private static float grad(long seed, long xsvp, long ysvp, float dx, float dy) {
        long hash = seed ^ xsvp ^ ysvp;
        hash *= HASH_MULTIPLIER;
        hash ^= hash >> (64 - N_GRADS_2D_EXPONENT + 1);
        int gi = (int)hash & ((N_GRADS_2D - 1) << 1);
        return GRADIENTS_2D[gi | 0] * dx + GRADIENTS_2D[gi | 1] * dy;
    }

    private static float grad(long seed, long xrvp, long yrvp, long zrvp, float dx, float dy, float dz) {
        long hash = (seed ^ xrvp) ^ (yrvp ^ zrvp);
        hash *= HASH_MULTIPLIER;
        hash ^= hash >> (64 - N_GRADS_3D_EXPONENT + 2);
        int gi = (int)hash & ((N_GRADS_3D - 1) << 2);
        return GRADIENTS_3D[gi | 0] * dx + GRADIENTS_3D[gi | 1] * dy + GRADIENTS_3D[gi | 2] * dz;
    }

    private static float grad(long seed, long xsvp, long ysvp, long zsvp, long wsvp, float dx, float dy, float dz, float dw) {
        long hash = seed ^ (xsvp ^ ysvp) ^ (zsvp ^ wsvp);
        hash *= HASH_MULTIPLIER;
        hash ^= hash >> (64 - N_GRADS_4D_EXPONENT + 2);
        int gi = (int)hash & ((N_GRADS_4D - 1) << 2);
        return (GRADIENTS_4D[gi | 0] * dx + GRADIENTS_4D[gi | 1] * dy) + (GRADIENTS_4D[gi | 2] * dz + GRADIENTS_4D[gi | 3] * dw);
    }

    private static int fastFloor(double x) {
        int xi = (int)x;
        return x < xi ? xi - 1 : xi;
    }

    private static int fastRound(double x) {
        return x < 0 ? (int)(x - 0.5) : (int)(x + 0.5);
    }

    

    private static float[] GRADIENTS_2D;
    private static float[] GRADIENTS_3D;
    private static float[] GRADIENTS_4D;
    static {

        GRADIENTS_2D = new float[N_GRADS_2D * 2];
        float[] grad2 = {
            0.38268343236509f,   0.923879532511287f,
            0.923879532511287f,  0.38268343236509f,
            0.923879532511287f, -0.38268343236509f,
            0.38268343236509f,  -0.923879532511287f,
            -0.38268343236509f,  -0.923879532511287f,
            -0.923879532511287f, -0.38268343236509f,
            -0.923879532511287f,  0.38268343236509f,
            -0.38268343236509f,   0.923879532511287f,

            0.130526192220052f,  0.99144486137381f,
            0.608761429008721f,  0.793353340291235f,
            0.793353340291235f,  0.608761429008721f,
            0.99144486137381f,   0.130526192220051f,
            0.99144486137381f,  -0.130526192220051f,
            0.793353340291235f, -0.60876142900872f,
            0.608761429008721f, -0.793353340291235f,
            0.130526192220052f, -0.99144486137381f,
            -0.130526192220052f, -0.99144486137381f,
            -0.608761429008721f, -0.793353340291235f,
            -0.793353340291235f, -0.608761429008721f,
            -0.99144486137381f,  -0.130526192220052f,
            -0.99144486137381f,   0.130526192220051f,
            -0.793353340291235f,  0.608761429008721f,
            -0.608761429008721f,  0.793353340291235f,
            -0.130526192220052f,  0.99144486137381f,
        };
        for (int i = 0; i < grad2.length; i++) {
            grad2[i] = (float)(grad2[i] / NORMALIZER_2D);
        }
        for (int i = 0, j = 0; i < GRADIENTS_2D.length; i++, j++) {
            if (j == grad2.length) j = 0;
            GRADIENTS_2D[i] = grad2[j];
        }

        GRADIENTS_3D = new float[N_GRADS_3D * 4];
        float[] grad3 = {
            2.22474487139f,       2.22474487139f,      -1.0f,                 0.0f,
            2.22474487139f,       2.22474487139f,       1.0f,                 0.0f,
            3.0862664687972017f,  1.1721513422464978f,  0.0f,                 0.0f,
            1.1721513422464978f,  3.0862664687972017f,  0.0f,                 0.0f,
            -2.22474487139f,       2.22474487139f,      -1.0f,                 0.0f,
            -2.22474487139f,       2.22474487139f,       1.0f,                 0.0f,
            -1.1721513422464978f,  3.0862664687972017f,  0.0f,                 0.0f,
            -3.0862664687972017f,  1.1721513422464978f,  0.0f,                 0.0f,
            -1.0f,                -2.22474487139f,      -2.22474487139f,       0.0f,
            1.0f,                -2.22474487139f,      -2.22474487139f,       0.0f,
            0.0f,                -3.0862664687972017f, -1.1721513422464978f,  0.0f,
            0.0f,                -1.1721513422464978f, -3.0862664687972017f,  0.0f,
            -1.0f,                -2.22474487139f,       2.22474487139f,       0.0f,
            1.0f,                -2.22474487139f,       2.22474487139f,       0.0f,
            0.0f,                -1.1721513422464978f,  3.0862664687972017f,  0.0f,
            0.0f,                -3.0862664687972017f,  1.1721513422464978f,  0.0f,

            -2.22474487139f,      -2.22474487139f,      -1.0f,                 0.0f,
            -2.22474487139f,      -2.22474487139f,       1.0f,                 0.0f,
            -3.0862664687972017f, -1.1721513422464978f,  0.0f,                 0.0f,
            -1.1721513422464978f, -3.0862664687972017f,  0.0f,                 0.0f,
            -2.22474487139f,      -1.0f,                -2.22474487139f,       0.0f,
            -2.22474487139f,       1.0f,                -2.22474487139f,       0.0f,
            -1.1721513422464978f,  0.0f,                -3.0862664687972017f,  0.0f,
            -3.0862664687972017f,  0.0f,                -1.1721513422464978f,  0.0f,
            -2.22474487139f,      -1.0f,                 2.22474487139f,       0.0f,
            -2.22474487139f,       1.0f,                 2.22474487139f,       0.0f,
            -3.0862664687972017f,  0.0f,                 1.1721513422464978f,  0.0f,
            -1.1721513422464978f,  0.0f,                 3.0862664687972017f,  0.0f,
            -1.0f,                 2.22474487139f,      -2.22474487139f,       0.0f,
            1.0f,                 2.22474487139f,      -2.22474487139f,       0.0f,
            0.0f,                 1.1721513422464978f, -3.0862664687972017f,  0.0f,
            0.0f,                 3.0862664687972017f, -1.1721513422464978f,  0.0f,
            -1.0f,                 2.22474487139f,       2.22474487139f,       0.0f,
            1.0f,                 2.22474487139f,       2.22474487139f,       0.0f,
            0.0f,                 3.0862664687972017f,  1.1721513422464978f,  0.0f,
            0.0f,                 1.1721513422464978f,  3.0862664687972017f,  0.0f,
            2.22474487139f,      -2.22474487139f,      -1.0f,                 0.0f,
            2.22474487139f,      -2.22474487139f,       1.0f,                 0.0f,
            1.1721513422464978f, -3.0862664687972017f,  0.0f,                 0.0f,
            3.0862664687972017f, -1.1721513422464978f,  0.0f,                 0.0f,
            2.22474487139f,      -1.0f,                -2.22474487139f,       0.0f,
            2.22474487139f,       1.0f,                -2.22474487139f,       0.0f,
            3.0862664687972017f,  0.0f,                -1.1721513422464978f,  0.0f,
            1.1721513422464978f,  0.0f,                -3.0862664687972017f,  0.0f,
            2.22474487139f,      -1.0f,                 2.22474487139f,       0.0f,
            2.22474487139f,       1.0f,                 2.22474487139f,       0.0f,
            1.1721513422464978f,  0.0f,                 3.0862664687972017f,  0.0f,
            3.0862664687972017f,  0.0f,                 1.1721513422464978f,  0.0f,
        };
        for (int i = 0; i < grad3.length; i++) {
            grad3[i] = (float)(grad3[i] / NORMALIZER_3D);
        }
        for (int i = 0, j = 0; i < GRADIENTS_3D.length; i++, j++) {
            if (j == grad3.length) j = 0;
            GRADIENTS_3D[i] = grad3[j];
        }

        GRADIENTS_4D = new float[N_GRADS_4D * 4];
        float[] grad4 = {
            -0.6740059517812944f,   -0.3239847771997537f,   -0.3239847771997537f,    0.5794684678643381f,
            -0.7504883828755602f,   -0.4004672082940195f,    0.15296486218853164f,   0.5029860367700724f,
            -0.7504883828755602f,    0.15296486218853164f,  -0.4004672082940195f,    0.5029860367700724f,
            -0.8828161875373585f,    0.08164729285680945f,   0.08164729285680945f,   0.4553054119602712f,
            -0.4553054119602712f,   -0.08164729285680945f,  -0.08164729285680945f,   0.8828161875373585f,
            -0.5029860367700724f,   -0.15296486218853164f,   0.4004672082940195f,    0.7504883828755602f,
            -0.5029860367700724f,    0.4004672082940195f,   -0.15296486218853164f,   0.7504883828755602f,
            -0.5794684678643381f,    0.3239847771997537f,    0.3239847771997537f,    0.6740059517812944f,
            -0.6740059517812944f,   -0.3239847771997537f,    0.5794684678643381f,   -0.3239847771997537f,
            -0.7504883828755602f,   -0.4004672082940195f,    0.5029860367700724f,    0.15296486218853164f,
            -0.7504883828755602f,    0.15296486218853164f,   0.5029860367700724f,   -0.4004672082940195f,
            -0.8828161875373585f,    0.08164729285680945f,   0.4553054119602712f,    0.08164729285680945f,
            -0.4553054119602712f,   -0.08164729285680945f,   0.8828161875373585f,   -0.08164729285680945f,
            -0.5029860367700724f,   -0.15296486218853164f,   0.7504883828755602f,    0.4004672082940195f,
            -0.5029860367700724f,    0.4004672082940195f,    0.7504883828755602f,   -0.15296486218853164f,
            -0.5794684678643381f,    0.3239847771997537f,    0.6740059517812944f,    0.3239847771997537f,
            -0.6740059517812944f,    0.5794684678643381f,   -0.3239847771997537f,   -0.3239847771997537f,
            -0.7504883828755602f,    0.5029860367700724f,   -0.4004672082940195f,    0.15296486218853164f,
            -0.7504883828755602f,    0.5029860367700724f,    0.15296486218853164f,  -0.4004672082940195f,
            -0.8828161875373585f,    0.4553054119602712f,    0.08164729285680945f,   0.08164729285680945f,
            -0.4553054119602712f,    0.8828161875373585f,   -0.08164729285680945f,  -0.08164729285680945f,
            -0.5029860367700724f,    0.7504883828755602f,   -0.15296486218853164f,   0.4004672082940195f,
            -0.5029860367700724f,    0.7504883828755602f,    0.4004672082940195f,   -0.15296486218853164f,
            -0.5794684678643381f,    0.6740059517812944f,    0.3239847771997537f,    0.3239847771997537f,
            0.5794684678643381f,   -0.6740059517812944f,   -0.3239847771997537f,   -0.3239847771997537f,
            0.5029860367700724f,   -0.7504883828755602f,   -0.4004672082940195f,    0.15296486218853164f,
            0.5029860367700724f,   -0.7504883828755602f,    0.15296486218853164f,  -0.4004672082940195f,
            0.4553054119602712f,   -0.8828161875373585f,    0.08164729285680945f,   0.08164729285680945f,
            0.8828161875373585f,   -0.4553054119602712f,   -0.08164729285680945f,  -0.08164729285680945f,
            0.7504883828755602f,   -0.5029860367700724f,   -0.15296486218853164f,   0.4004672082940195f,
            0.7504883828755602f,   -0.5029860367700724f,    0.4004672082940195f,   -0.15296486218853164f,
            0.6740059517812944f,   -0.5794684678643381f,    0.3239847771997537f,    0.3239847771997537f,

            -0.753341017856078f,    -0.37968289875261624f,  -0.37968289875261624f,  -0.37968289875261624f,
            -0.7821684431180708f,   -0.4321472685365301f,   -0.4321472685365301f,    0.12128480194602098f,
            -0.7821684431180708f,   -0.4321472685365301f,    0.12128480194602098f,  -0.4321472685365301f,
            -0.7821684431180708f,    0.12128480194602098f,  -0.4321472685365301f,   -0.4321472685365301f,
            -0.8586508742123365f,   -0.508629699630796f,     0.044802370851755174f,  0.044802370851755174f,
            -0.8586508742123365f,    0.044802370851755174f, -0.508629699630796f,     0.044802370851755174f,
            -0.8586508742123365f,    0.044802370851755174f,  0.044802370851755174f, -0.508629699630796f,
            -0.9982828964265062f,   -0.03381941603233842f,  -0.03381941603233842f,  -0.03381941603233842f,
            -0.37968289875261624f,  -0.753341017856078f,    -0.37968289875261624f,  -0.37968289875261624f,
            -0.4321472685365301f,   -0.7821684431180708f,   -0.4321472685365301f,    0.12128480194602098f,
            -0.4321472685365301f,   -0.7821684431180708f,    0.12128480194602098f,  -0.4321472685365301f,
            0.12128480194602098f,  -0.7821684431180708f,   -0.4321472685365301f,   -0.4321472685365301f,
            -0.508629699630796f,    -0.8586508742123365f,    0.044802370851755174f,  0.044802370851755174f,
            0.044802370851755174f, -0.8586508742123365f,   -0.508629699630796f,     0.044802370851755174f,
            0.044802370851755174f, -0.8586508742123365f,    0.044802370851755174f, -0.508629699630796f,
            -0.03381941603233842f,  -0.9982828964265062f,   -0.03381941603233842f,  -0.03381941603233842f,
            -0.37968289875261624f,  -0.37968289875261624f,  -0.753341017856078f,    -0.37968289875261624f,
            -0.4321472685365301f,   -0.4321472685365301f,   -0.7821684431180708f,    0.12128480194602098f,
            -0.4321472685365301f,    0.12128480194602098f,  -0.7821684431180708f,   -0.4321472685365301f,
            0.12128480194602098f,  -0.4321472685365301f,   -0.7821684431180708f,   -0.4321472685365301f,
            -0.508629699630796f,     0.044802370851755174f, -0.8586508742123365f,    0.044802370851755174f,
            0.044802370851755174f, -0.508629699630796f,    -0.8586508742123365f,    0.044802370851755174f,
            0.044802370851755174f,  0.044802370851755174f, -0.8586508742123365f,   -0.508629699630796f,
            -0.03381941603233842f,  -0.03381941603233842f,  -0.9982828964265062f,   -0.03381941603233842f,
            -0.37968289875261624f,  -0.37968289875261624f,  -0.37968289875261624f,  -0.753341017856078f,
            -0.4321472685365301f,   -0.4321472685365301f,    0.12128480194602098f,  -0.7821684431180708f,
            -0.4321472685365301f,    0.12128480194602098f,  -0.4321472685365301f,   -0.7821684431180708f,
            0.12128480194602098f,  -0.4321472685365301f,   -0.4321472685365301f,   -0.7821684431180708f,
            -0.508629699630796f,     0.044802370851755174f,  0.044802370851755174f, -0.8586508742123365f,
            0.044802370851755174f, -0.508629699630796f,     0.044802370851755174f, -0.8586508742123365f,
            0.044802370851755174f,  0.044802370851755174f, -0.508629699630796f,    -0.8586508742123365f,
            -0.03381941603233842f,  -0.03381941603233842f,  -0.03381941603233842f,  -0.9982828964265062f,
            -0.3239847771997537f,   -0.6740059517812944f,   -0.3239847771997537f,    0.5794684678643381f,
            -0.4004672082940195f,   -0.7504883828755602f,    0.15296486218853164f,   0.5029860367700724f,
            0.15296486218853164f,  -0.7504883828755602f,   -0.4004672082940195f,    0.5029860367700724f,
            0.08164729285680945f,  -0.8828161875373585f,    0.08164729285680945f,   0.4553054119602712f,
            -0.08164729285680945f,  -0.4553054119602712f,   -0.08164729285680945f,   0.8828161875373585f,
            -0.15296486218853164f,  -0.5029860367700724f,    0.4004672082940195f,    0.7504883828755602f,
            0.4004672082940195f,   -0.5029860367700724f,   -0.15296486218853164f,   0.7504883828755602f,
            0.3239847771997537f,   -0.5794684678643381f,    0.3239847771997537f,    0.6740059517812944f,
            -0.3239847771997537f,   -0.3239847771997537f,   -0.6740059517812944f,    0.5794684678643381f,
            -0.4004672082940195f,    0.15296486218853164f,  -0.7504883828755602f,    0.5029860367700724f,
            0.15296486218853164f,  -0.4004672082940195f,   -0.7504883828755602f,    0.5029860367700724f,
            0.08164729285680945f,   0.08164729285680945f,  -0.8828161875373585f,    0.4553054119602712f,
            -0.08164729285680945f,  -0.08164729285680945f,  -0.4553054119602712f,    0.8828161875373585f,
            -0.15296486218853164f,   0.4004672082940195f,   -0.5029860367700724f,    0.7504883828755602f,
            0.4004672082940195f,   -0.15296486218853164f,  -0.5029860367700724f,    0.7504883828755602f,
            0.3239847771997537f,    0.3239847771997537f,   -0.5794684678643381f,    0.6740059517812944f,
            -0.3239847771997537f,   -0.6740059517812944f,    0.5794684678643381f,   -0.3239847771997537f,
            -0.4004672082940195f,   -0.7504883828755602f,    0.5029860367700724f,    0.15296486218853164f,
            0.15296486218853164f,  -0.7504883828755602f,    0.5029860367700724f,   -0.4004672082940195f,
            0.08164729285680945f,  -0.8828161875373585f,    0.4553054119602712f,    0.08164729285680945f,
            -0.08164729285680945f,  -0.4553054119602712f,    0.8828161875373585f,   -0.08164729285680945f,
            -0.15296486218853164f,  -0.5029860367700724f,    0.7504883828755602f,    0.4004672082940195f,
            0.4004672082940195f,   -0.5029860367700724f,    0.7504883828755602f,   -0.15296486218853164f,
            0.3239847771997537f,   -0.5794684678643381f,    0.6740059517812944f,    0.3239847771997537f,
            -0.3239847771997537f,   -0.3239847771997537f,    0.5794684678643381f,   -0.6740059517812944f,
            -0.4004672082940195f,    0.15296486218853164f,   0.5029860367700724f,   -0.7504883828755602f,
            0.15296486218853164f,  -0.4004672082940195f,    0.5029860367700724f,   -0.7504883828755602f,
            0.08164729285680945f,   0.08164729285680945f,   0.4553054119602712f,   -0.8828161875373585f,
            -0.08164729285680945f,  -0.08164729285680945f,   0.8828161875373585f,   -0.4553054119602712f,
            -0.15296486218853164f,   0.4004672082940195f,    0.7504883828755602f,   -0.5029860367700724f,
            0.4004672082940195f,   -0.15296486218853164f,   0.7504883828755602f,   -0.5029860367700724f,
            0.3239847771997537f,    0.3239847771997537f,    0.6740059517812944f,   -0.5794684678643381f,
            -0.3239847771997537f,    0.5794684678643381f,   -0.6740059517812944f,   -0.3239847771997537f,
            -0.4004672082940195f,    0.5029860367700724f,   -0.7504883828755602f,    0.15296486218853164f,
            0.15296486218853164f,   0.5029860367700724f,   -0.7504883828755602f,   -0.4004672082940195f,
            0.08164729285680945f,   0.4553054119602712f,   -0.8828161875373585f,    0.08164729285680945f,
            -0.08164729285680945f,   0.8828161875373585f,   -0.4553054119602712f,   -0.08164729285680945f,
            -0.15296486218853164f,   0.7504883828755602f,   -0.5029860367700724f,    0.4004672082940195f,
            0.4004672082940195f,    0.7504883828755602f,   -0.5029860367700724f,   -0.15296486218853164f,
            0.3239847771997537f,    0.6740059517812944f,   -0.5794684678643381f,    0.3239847771997537f,
            -0.3239847771997537f,    0.5794684678643381f,   -0.3239847771997537f,   -0.6740059517812944f,
            -0.4004672082940195f,    0.5029860367700724f,    0.15296486218853164f,  -0.7504883828755602f,
            0.15296486218853164f,   0.5029860367700724f,   -0.4004672082940195f,   -0.7504883828755602f,
            0.08164729285680945f,   0.4553054119602712f,    0.08164729285680945f,  -0.8828161875373585f,
            -0.08164729285680945f,   0.8828161875373585f,   -0.08164729285680945f,  -0.4553054119602712f,
            -0.15296486218853164f,   0.7504883828755602f,    0.4004672082940195f,   -0.5029860367700724f,
            0.4004672082940195f,    0.7504883828755602f,   -0.15296486218853164f,  -0.5029860367700724f,
            0.3239847771997537f,    0.6740059517812944f,    0.3239847771997537f,   -0.5794684678643381f,
            0.5794684678643381f,   -0.3239847771997537f,   -0.6740059517812944f,   -0.3239847771997537f,
            0.5029860367700724f,   -0.4004672082940195f,   -0.7504883828755602f,    0.15296486218853164f,
            0.5029860367700724f,    0.15296486218853164f,  -0.7504883828755602f,   -0.4004672082940195f,
            0.4553054119602712f,    0.08164729285680945f,  -0.8828161875373585f,    0.08164729285680945f,
            0.8828161875373585f,   -0.08164729285680945f,  -0.4553054119602712f,   -0.08164729285680945f,
            0.7504883828755602f,   -0.15296486218853164f,  -0.5029860367700724f,    0.4004672082940195f,
            0.7504883828755602f,    0.4004672082940195f,   -0.5029860367700724f,   -0.15296486218853164f,
            0.6740059517812944f,    0.3239847771997537f,   -0.5794684678643381f,    0.3239847771997537f,
            0.5794684678643381f,   -0.3239847771997537f,   -0.3239847771997537f,   -0.6740059517812944f,
            0.5029860367700724f,   -0.4004672082940195f,    0.15296486218853164f,  -0.7504883828755602f,
            0.5029860367700724f,    0.15296486218853164f,  -0.4004672082940195f,   -0.7504883828755602f,
            0.4553054119602712f,    0.08164729285680945f,   0.08164729285680945f,  -0.8828161875373585f,
            0.8828161875373585f,   -0.08164729285680945f,  -0.08164729285680945f,  -0.4553054119602712f,
            0.7504883828755602f,   -0.15296486218853164f,   0.4004672082940195f,   -0.5029860367700724f,
            0.7504883828755602f,    0.4004672082940195f,   -0.15296486218853164f,  -0.5029860367700724f,
            0.6740059517812944f,    0.3239847771997537f,    0.3239847771997537f,   -0.5794684678643381f,
            0.03381941603233842f,   0.03381941603233842f,   0.03381941603233842f,   0.9982828964265062f,
            -0.044802370851755174f, -0.044802370851755174f,  0.508629699630796f,     0.8586508742123365f,
            -0.044802370851755174f,  0.508629699630796f,    -0.044802370851755174f,  0.8586508742123365f,
            -0.12128480194602098f,   0.4321472685365301f,    0.4321472685365301f,    0.7821684431180708f,
            0.508629699630796f,    -0.044802370851755174f, -0.044802370851755174f,  0.8586508742123365f,
            0.4321472685365301f,   -0.12128480194602098f,   0.4321472685365301f,    0.7821684431180708f,
            0.4321472685365301f,    0.4321472685365301f,   -0.12128480194602098f,   0.7821684431180708f,
            0.37968289875261624f,   0.37968289875261624f,   0.37968289875261624f,   0.753341017856078f,
            0.03381941603233842f,   0.03381941603233842f,   0.9982828964265062f,    0.03381941603233842f,
            -0.044802370851755174f,  0.044802370851755174f,  0.8586508742123365f,    0.508629699630796f,
            -0.044802370851755174f,  0.508629699630796f,     0.8586508742123365f,   -0.044802370851755174f,
            -0.12128480194602098f,   0.4321472685365301f,    0.7821684431180708f,    0.4321472685365301f,
            0.508629699630796f,    -0.044802370851755174f,  0.8586508742123365f,   -0.044802370851755174f,
            0.4321472685365301f,   -0.12128480194602098f,   0.7821684431180708f,    0.4321472685365301f,
            0.4321472685365301f,    0.4321472685365301f,    0.7821684431180708f,   -0.12128480194602098f,
            0.37968289875261624f,   0.37968289875261624f,   0.753341017856078f,     0.37968289875261624f,
            0.03381941603233842f,   0.9982828964265062f,    0.03381941603233842f,   0.03381941603233842f,
            -0.044802370851755174f,  0.8586508742123365f,   -0.044802370851755174f,  0.508629699630796f,
            -0.044802370851755174f,  0.8586508742123365f,    0.508629699630796f,    -0.044802370851755174f,
            -0.12128480194602098f,   0.7821684431180708f,    0.4321472685365301f,    0.4321472685365301f,
            0.508629699630796f,     0.8586508742123365f,   -0.044802370851755174f, -0.044802370851755174f,
            0.4321472685365301f,    0.7821684431180708f,   -0.12128480194602098f,   0.4321472685365301f,
            0.4321472685365301f,    0.7821684431180708f,    0.4321472685365301f,   -0.12128480194602098f,
            0.37968289875261624f,   0.753341017856078f,     0.37968289875261624f,   0.37968289875261624f,
            0.9982828964265062f,    0.03381941603233842f,   0.03381941603233842f,   0.03381941603233842f,
            0.8586508742123365f,   -0.044802370851755174f, -0.044802370851755174f,  0.508629699630796f,
            0.8586508742123365f,   -0.044802370851755174f,  0.508629699630796f,    -0.044802370851755174f,
            0.7821684431180708f,   -0.12128480194602098f,   0.4321472685365301f,    0.4321472685365301f,
            0.8586508742123365f,    0.508629699630796f,    -0.044802370851755174f, -0.044802370851755174f,
            0.7821684431180708f,    0.4321472685365301f,   -0.12128480194602098f,   0.4321472685365301f,
            0.7821684431180708f,    0.4321472685365301f,    0.4321472685365301f,   -0.12128480194602098f,
            0.753341017856078f,     0.37968289875261624f,   0.37968289875261624f,   0.37968289875261624f,
        };
        for (int i = 0; i < grad4.length; i++) {
            grad4[i] = (float)(grad4[i] / NORMALIZER_4D);
        }
        for (int i = 0, j = 0; i < GRADIENTS_4D.length; i++, j++) {
            if (j == grad4.length) j = 0;
            GRADIENTS_4D[i] = grad4[j];
        }
    }
}

================
File: main/java/io.github.minemon/utils/UUIDSerializer.java
================
package io.github.minemon.utils;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.Serializer;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

import java.util.UUID;

public class UUIDSerializer extends Serializer<UUID> {
    @Override
    public void write(Kryo kryo, Output output, UUID uuid) {
        output.writeLong(uuid.getMostSignificantBits());
        output.writeLong(uuid.getLeastSignificantBits());
    }

    @Override
    public UUID read(Kryo kryo, Input input, Class<UUID> type) {
        long mostSigBits = input.readLong();
        long leastSigBits = input.readLong();
        return new UUID(mostSigBits, leastSigBits);
    }
}

================
File: main/java/io.github.minemon/weather/config/WeatherConfig.java
================
package io.github.minemon.weather.config;

import org.springframework.context.annotation.Configuration;

@Configuration
public class WeatherConfig {
    public float getWeatherCheckInterval() {
        return 10f;
    }

    public int getMaxParticles() {
        return 300;
    }

    public float getMaxParticleSpawnRate() {
        return 300f;
    }

}

================
File: main/java/io.github.minemon/weather/model/WeatherType.java
================
package io.github.minemon.weather.model;

public enum WeatherType {
    CLEAR,
    RAIN,
    HEAVY_RAIN,
    SNOW,
    BLIZZARD,
    SANDSTORM,
    FOG,
    THUNDERSTORM
}

================
File: main/java/io.github.minemon/weather/service/WeatherAudioService.java
================
package io.github.minemon.weather.service;

import io.github.minemon.audio.model.WeatherSoundEffect;
import io.github.minemon.audio.service.AudioService;
import io.github.minemon.weather.model.WeatherType;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;


@Service
@Slf4j
public class WeatherAudioService {

    private static final float THUNDER_MIN_INTERVAL = 5f;
    private static final float THUNDER_MAX_INTERVAL = 15f;

    private float thunderTimer;
    private float nextThunderTime;
    private boolean isThundering;
    @Getter
    private float lightningAlpha;

    @Setter
    private AudioService audioService;

    public WeatherAudioService() {
        resetThunderTimer();
    }

    private void resetThunderTimer() {
        nextThunderTime = randomRange();
        thunderTimer = 0;
    }

    
    public void update(float delta, WeatherType currentWeather, float intensity) {
        updateThunderAndLightning(delta, currentWeather, intensity);
        updateWeatherSounds(currentWeather, intensity);
    }

    private void updateThunderAndLightning(float delta, WeatherType currentWeather, float intensity) {
        if (currentWeather == WeatherType.THUNDERSTORM) {
            thunderTimer += delta;


            if (isThundering) {
                lightningAlpha = Math.max(0, lightningAlpha - delta * 2f);
                if (lightningAlpha <= 0) {
                    isThundering = false;
                }
            }


            if (thunderTimer >= nextThunderTime) {
                triggerThunderAndLightning(intensity);
                resetThunderTimer();
            }
        } else {
            lightningAlpha = 0;
            isThundering = false;
            resetThunderTimer();
        }
    }

    private void triggerThunderAndLightning(float intensity) {
        isThundering = true;
        lightningAlpha = 0.7f * intensity;


        float volume = 0.5f + (intensity * 0.5f);
        float pitch = 0.9f + (randomFloat() * 0.2f);
        if (audioService != null && audioService.isSoundEnabled()) {
            audioService.playWeatherSound(WeatherSoundEffect.THUNDER, volume, pitch);
        } else {
            log.debug("AudioService not available or sound disabled; skipping thunder sound.");
        }
    }

    private void updateWeatherSounds(WeatherType currentWeather, float intensity) {
        if (audioService == null || !audioService.isSoundEnabled()) {
            return;
        }


        switch (currentWeather) {
            case RAIN -> {

                audioService.updateWeatherLoop(WeatherSoundEffect.LIGHT_RAIN, intensity * 0.6f);
                audioService.stopWeatherLoop(WeatherSoundEffect.WIND);
                audioService.stopWeatherLoop(WeatherSoundEffect.SAND_WIND);
            }
            case HEAVY_RAIN, THUNDERSTORM -> {
                audioService.stopWeatherLoop(WeatherSoundEffect.LIGHT_RAIN);
                audioService.stopWeatherLoop(WeatherSoundEffect.WIND);
                audioService.stopWeatherLoop(WeatherSoundEffect.SAND_WIND);
            }
            case SNOW, BLIZZARD -> {

                audioService.updateWeatherLoop(WeatherSoundEffect.WIND, intensity * 0.4f);
                audioService.stopWeatherLoop(WeatherSoundEffect.LIGHT_RAIN);
                audioService.stopWeatherLoop(WeatherSoundEffect.SAND_WIND);
            }
            case SANDSTORM -> {

                audioService.updateWeatherLoop(WeatherSoundEffect.SAND_WIND, intensity * 0.7f);
                audioService.stopWeatherLoop(WeatherSoundEffect.LIGHT_RAIN);
                audioService.stopWeatherLoop(WeatherSoundEffect.WIND);
            }
            default -> {

                audioService.stopWeatherLoop(WeatherSoundEffect.LIGHT_RAIN);
                audioService.stopWeatherLoop(WeatherSoundEffect.WIND);
                audioService.stopWeatherLoop(WeatherSoundEffect.SAND_WIND);
            }
        }
    }

    private float randomFloat() {
        return (float) Math.random();
    }

    private float randomRange() {
        return WeatherAudioService.THUNDER_MIN_INTERVAL + randomFloat() * (WeatherAudioService.THUNDER_MAX_INTERVAL - WeatherAudioService.THUNDER_MIN_INTERVAL);
    }
}

================
File: main/java/io.github.minemon/world/biome/config/BiomeConfig.java
================
package io.github.minemon.world.biome.config;

import lombok.Getter;
import lombok.Setter;

import java.util.HashMap;

@Setter
@Getter
public class BiomeConfig {
    private HashMap<String, HashMap<String, Integer>> biomes;
}

================
File: main/java/io.github.minemon/world/biome/config/BiomeConfigurationLoader.java
================
package io.github.minemon.world.biome.config;

import com.badlogic.gdx.utils.Json;
import io.github.minemon.core.service.FileAccessService;
import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.biome.model.BiomeType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
public class BiomeConfigurationLoader {
    private static final Logger logger = LoggerFactory.getLogger(BiomeConfigurationLoader.class);

    public static class BiomeDefinition {
        public String name;
        public String type;
        public ArrayList<Integer> allowedTileTypes = new ArrayList<>();
        public HashMap<String, Double> tileDistribution = new HashMap<>();
        public ArrayList<String> spawnableObjects = new ArrayList<>();
        public HashMap<String, Double> spawnChances = new HashMap<>();
    }

    public static class BiomeRoot {
        public ArrayList<BiomeDefinition> biomes = new ArrayList<>();
    }

    private final FileAccessService fileAccessService;

    public BiomeConfigurationLoader(FileAccessService fileAccessService) {
        this.fileAccessService = fileAccessService;
    }

    public Map<BiomeType, Biome> loadBiomes(String configFilePath) {
        if (!fileAccessService.exists(configFilePath)) {
            logger.error("Biome config file not found: {}", configFilePath);
            return Collections.emptyMap();
        }

        String jsonContent;
        try {
            jsonContent = fileAccessService.readFile(configFilePath);
        } catch (RuntimeException e) {
            logger.error("Failed to read biome config: {}", e.getMessage());
            return Collections.emptyMap();
        }

        Json json = new Json();
        json.setIgnoreUnknownFields(true);

        BiomeRoot root = json.fromJson(BiomeRoot.class, jsonContent);
        if (root == null || root.biomes.isEmpty()) {
            logger.warn("No biomes found in file: {}", configFilePath);
            return Collections.emptyMap();
        }

        Map<BiomeType, Biome> biomeMap = new HashMap<>();
        for (BiomeDefinition def : root.biomes) {
            BiomeType type;
            try {
                type = BiomeType.valueOf(def.type.toUpperCase());
            } catch (IllegalArgumentException ex) {
                logger.error("Unknown biome type '{}' in config. Skipping...", def.type);
                continue;
            }

            Map<Integer, Double> distribution = new HashMap<>();
            for (Map.Entry<String, Double> entry : def.tileDistribution.entrySet()) {
                try {
                    distribution.put(Integer.valueOf(entry.getKey()), entry.getValue());
                } catch (NumberFormatException ex) {
                    logger.error("Invalid tile type '{}' in distribution for biome '{}'. Skipping this entry.", entry.getKey(), def.name);
                }
            }

            Biome biome = new Biome(
                    def.name,
                    type,
                    def.allowedTileTypes,
                    distribution,
                    def.spawnableObjects,
                    def.spawnChances
            );
            biomeMap.put(type, biome);
        }

        logger.info("Loaded {} biomes from {}", biomeMap.size(), configFilePath);
        return biomeMap;
    }
}

================
File: main/java/io.github.minemon/world/biome/model/Biome.java
================
package io.github.minemon.world.biome.model;

import io.github.minemon.world.model.ObjectType;
import lombok.Getter;

import java.util.List;
import java.util.Map;

@Getter
public class Biome {
    private final String name;

    private BiomeType type;

    private List<Integer> allowedTileTypes;

    private Map<Integer, Double> tileDistribution;

    private List<String> spawnableObjects;

    private Map<String, Double> spawnChances;

    public Biome(String name,
                 BiomeType type,
                 List<Integer> allowedTileTypes,
                 Map<Integer, Double> tileDistribution,
                 List<String> spawnableObjects,
                 Map<String, Double> spawnChances) {
        this.name = name;
        this.type = type;
        this.allowedTileTypes = allowedTileTypes;
        this.tileDistribution = tileDistribution;
        this.spawnableObjects = spawnableObjects;
        this.spawnChances = spawnChances;
    }

    public double getSpawnChanceForObject(ObjectType objType) {
        return spawnChances.getOrDefault(objType.name(), 0.0);
    }
}

================
File: main/java/io.github.minemon/world/biome/model/BiomeTransitionResult.java
================
package io.github.minemon.world.biome.model;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class BiomeTransitionResult {
    private final Biome primaryBiome;
    private final Biome secondaryBiome;
    
    private final float transitionFactor;
}

================
File: main/java/io.github.minemon/world/biome/model/BiomeType.java
================
package io.github.minemon.world.biome.model;

public enum BiomeType {
    PLAINS,
    DESERT,
    SNOW,
    FOREST,
    RAIN_FOREST,
    HAUNTED,
    BIG_MOUNTAINS,
    RUINS
}

================
File: main/java/io.github.minemon/world/biome/service/BiomeService.java
================
package io.github.minemon.world.biome.service;

import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.biome.model.BiomeTransitionResult;
import io.github.minemon.world.biome.model.BiomeType;

public interface BiomeService {
    
    BiomeTransitionResult getBiomeAt(float worldX, float worldY);

    
    Biome getBiome(BiomeType type);

    void init();
    void initWithSeed(long seed);

    
    void debugBiomeDistribution(int samples);
}

================
File: main/java/io.github.minemon/world/biome/service/impl/BiomeServiceImpl.java
================
package io.github.minemon.world.biome.service.impl;

import io.github.minemon.utils.OpenSimplex2;
import io.github.minemon.world.biome.config.BiomeConfigurationLoader;
import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.biome.model.BiomeTransitionResult;
import io.github.minemon.world.biome.model.BiomeType;
import io.github.minemon.world.biome.service.BiomeService;
import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;


@Service
@Slf4j
public class BiomeServiceImpl implements BiomeService {


    private static final float TEMPERATURE_SCALE = 0.00005f;
    private static final float MOISTURE_SCALE = 0.00005f;
    private static final float WARP_SCALE = 0.00001f;
    private static final float WARP_STRENGTH = 30f;
    private static final double TRANSITION_BASE = 0.15;
    private final BiomeConfigurationLoader configurationLoader;
    private long baseSeed;
    private long temperatureSeed;
    private long moistureSeed;
    private long warpSeed;
    private Map<BiomeType, Biome> biomes = new HashMap<>();

    public BiomeServiceImpl(BiomeConfigurationLoader configurationLoader) {
        this.configurationLoader = configurationLoader;
    }

    public void initWithSeed(long seed) {
        this.baseSeed = seed;
        this.temperatureSeed = seed + 1000;
        this.moistureSeed = seed + 2000;
        this.warpSeed = seed + 4000;
    }


    @PostConstruct
    @Override
    public void init() {
        this.biomes = configurationLoader.loadBiomes("assets/config/biomes.json");
        if (biomes.isEmpty()) {
            log.warn("No biomes loaded - using defaults.");
        } else {
            log.info("Loaded {} biomes.", biomes.size());
        }
    }

    @Override
    public BiomeTransitionResult getBiomeAt(float worldX, float worldY) {
        float[] warped = domainWarp(worldX, worldY);
        double temperature = getNoiseValue(warped[0], warped[1], temperatureSeed, TEMPERATURE_SCALE);
        double moisture = getNoiseValue(warped[0], warped[1], moistureSeed, MOISTURE_SCALE);


        BiomeType primaryType = determineBiomeType(temperature, moisture);


        double edgeNoise = getNoiseValue(worldX, worldY, warpSeed, TEMPERATURE_SCALE * 2);
        double transitionThreshold = TRANSITION_BASE + edgeNoise * 0.05;

        if (shouldBlendBiomes(temperature, moisture, transitionThreshold)) {

            float[] offsetWarp = domainWarp(worldX + 64, worldY + 64);
            double temp2 = getNoiseValue(offsetWarp[0], offsetWarp[1], temperatureSeed, TEMPERATURE_SCALE);
            double moist2 = getNoiseValue(offsetWarp[0], offsetWarp[1], moistureSeed, MOISTURE_SCALE);
            BiomeType secondaryType = determineBiomeType(temp2, moist2);

            if (primaryType != secondaryType && areCompatibleBiomes(primaryType, secondaryType)) {
                float transitionFactor = computeTransitionFactor(temperature, moisture, transitionThreshold);
                return new BiomeTransitionResult(getBiome(primaryType), getBiome(secondaryType), transitionFactor);
            }
        }


        return new BiomeTransitionResult(getBiome(primaryType), null, 1.0f);
    }

    
    private float computeTransitionFactor(double temperature, double moisture, double threshold) {

        double tempDelta = Math.abs(temperature - 0.5);
        double moistDelta = Math.abs(moisture - 0.5);
        double maxDelta = Math.max(tempDelta, moistDelta);

        double factor = maxDelta / threshold;
        return (float) Math.min(Math.max(factor, 0.0), 1.0);
    }

    
    private boolean shouldBlendBiomes(double temperature, double moisture, double transitionThreshold) {
        return (Math.abs(temperature - 0.5) < transitionThreshold ||
                Math.abs(moisture - 0.5) < transitionThreshold);
    }

    
    private BiomeType determineBiomeType(double temperature, double moisture) {

        if (temperature < 0.35) {
            return (moisture > 0.65) ? BiomeType.SNOW : BiomeType.PLAINS;
        } else if (temperature > 0.65) {
            return (moisture < 0.35) ? BiomeType.DESERT : BiomeType.PLAINS;
        } else {
            return BiomeType.PLAINS;
        }
    }

    
    private float[] domainWarp(float x, float y) {
        float[] warped = new float[]{x, y};
        float amplitude = WARP_STRENGTH;
        float frequency = WARP_SCALE;

        for (int i = 0; i < 3; i++) {
            float warpX = (float) OpenSimplex2.noise2(warpSeed + i, warped[0] * frequency, warped[1] * frequency) * amplitude;
            float warpY = (float) OpenSimplex2.noise2(warpSeed + i + 1000, warped[0] * frequency, warped[1] * frequency) * amplitude;

            warped[0] += warpX;
            warped[1] += warpY;

            amplitude *= 0.5f;
            frequency *= 1.8f;
        }
        return warped;
    }

    
    private double getNoiseValue(float x, float y, long seed, float scale) {
        double value = 0;
        double amplitude = 1.0;
        double frequency = 1.0;
        double maxAmplitude = 0;


        for (int i = 0; i < 3; i++) {
            double n = OpenSimplex2.noise2(seed + i, x * scale * frequency, y * scale * frequency);
            value += amplitude * n;
            maxAmplitude += amplitude;
            amplitude *= 0.5;
            frequency *= 2.0;
        }

        value = (value / maxAmplitude + 1) / 2;
        return Math.max(0.0, Math.min(1.0, Math.pow(value, 1.1)));
    }

    
    private boolean areCompatibleBiomes(BiomeType a, BiomeType b) {
        if (a == b) return true;

        if (a == BiomeType.PLAINS && b == BiomeType.FOREST) return true;

        return true;
    }

    @Override
    public Biome getBiome(BiomeType type) {
        Biome biome = biomes.get(type);
        if (biome == null) {
            log.error("Missing biome type: {}. Falling back to PLAINS.", type);
            return biomes.getOrDefault(BiomeType.PLAINS, new Biome("Plains", BiomeType.PLAINS, null, null, null, null));
        }
        return biome;
    }

    @Override
    public void debugBiomeDistribution(int samples) {

        Map<BiomeType, Integer> distribution = new HashMap<>();
        for (int i = 0; i < samples; i++) {
            float x = (float) Math.random() * 1000;
            float y = (float) Math.random() * 1000;
            BiomeTransitionResult result = getBiomeAt(x, y);
            BiomeType type = result.getPrimaryBiome().getType();
            distribution.merge(type, 1, Integer::sum);
        }

        log.info("=== Biome Distribution ({} samples) ===", samples);
        for (Map.Entry<BiomeType, Integer> entry : distribution.entrySet()) {
            double perc = (entry.getValue() * 100.0) / samples;
            log.info("{}: {} ({}%)", entry.getKey(), entry.getValue(), perc);
        }
        log.info("======================================");
    }
}

================
File: main/java/io.github.minemon/world/config/TileConfig.java
================
package io.github.minemon.world.config;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Setter
@Getter
public class TileConfig {
    private List<TileDefinition> tiles;

    @Setter
    @Getter
    public static class TileDefinition {
        private int id;
        private String name;
        private String texture;
        private boolean passable;

    }
}

================
File: main/java/io.github.minemon/world/config/WorldConfig.java
================
package io.github.minemon.world.config;

import lombok.Getter;

@Getter
public class WorldConfig {
    private final long seed;
    private final int chunkSize = 16;
    private final int tileSize = 32;

    public WorldConfig(long seed) {
        this.seed = seed;
    }

}

================
File: main/java/io.github.minemon/world/config/WorldConfiguration.java
================
package io.github.minemon.world.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class WorldConfiguration {

    @Value("${world.seed:12345}")
    private long seed;

    @Bean
    public WorldConfig worldConfig() {
        return new WorldConfig(seed);
    }
}

================
File: main/java/io.github.minemon/world/config/WorldObjectConfig.java
================
package io.github.minemon.world.config;

import io.github.minemon.world.service.WorldObjectManager;
import io.github.minemon.world.service.impl.ServerWorldObjectManagerImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;

@Configuration
public class WorldObjectConfig {

    @Bean
    @Profile("server")
    public WorldObjectManager serverWorldObjectManager() {
        return new ServerWorldObjectManagerImpl();
    }
}

================
File: main/java/io.github.minemon/world/event/ChunkLoadEvent.java
================
package io.github.minemon.world.event;

import io.github.minemon.event.Event;
import lombok.Getter;

@Getter
public class ChunkLoadEvent implements Event {
    private final int chunkX;
    private final int chunkY;

    public ChunkLoadEvent(int chunkX, int chunkY) {
        this.chunkX = chunkX;
        this.chunkY = chunkY;
    }

}

================
File: main/java/io.github.minemon/world/event/WorldObjectRemoveEvent.java
================
package io.github.minemon.world.event;

import lombok.Getter;
import org.springframework.context.ApplicationEvent;

@Getter
public class WorldObjectRemoveEvent extends ApplicationEvent {
    private final String objectId;

    public WorldObjectRemoveEvent(Object source, String objectId) {
        super(source);
        this.objectId = objectId;
    }
}

================
File: main/java/io.github.minemon/world/event/WorldObjectSpawnEvent.java
================
package io.github.minemon.world.event;

import io.github.minemon.world.model.WorldObject;
import lombok.Getter;
import org.springframework.context.ApplicationEvent;

@Getter
public class WorldObjectSpawnEvent extends ApplicationEvent {
    private final WorldObject worldObject;

    public WorldObjectSpawnEvent(Object source, WorldObject worldObject) {
        super(source);
        this.worldObject = worldObject;
    }
}

================
File: main/java/io.github.minemon/world/model/ChunkData.java
================
package io.github.minemon.world.model;

import lombok.Data;

import java.io.*;
import java.util.List;

@Data
public class ChunkData {
    private int chunkX;
    private int chunkY;

    private int[][] tiles;

    private List<WorldObject> objects;

    private transient byte[] tilesBlob;

    public int[][] getTiles() {
        if (tiles == null && tilesBlob != null) {
            tiles = deserializeTiles(tilesBlob);
        }
        return tiles;
    }

    public void setTiles(int[][] tiles) {
        this.tiles = tiles;
        this.tilesBlob = serializeTiles(tiles);
    }

    private byte[] serializeTiles(int[][] tiles) {
        if (tiles == null) return null;
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
             ObjectOutputStream oos = new ObjectOutputStream(baos)) {
            oos.writeObject(tiles);
            return baos.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException("Failed to serialize tiles", e);
        }
    }

    private int[][] deserializeTiles(byte[] data) {
        if (data == null) return null;
        try (ByteArrayInputStream bais = new ByteArrayInputStream(data);
             ObjectInputStream ois = new ObjectInputStream(bais)) {
            return (int[][]) ois.readObject();
        } catch (IOException | ClassNotFoundException e) {
            throw new RuntimeException("Failed to deserialize tiles", e);
        }
    }
}

================
File: main/java/io.github.minemon/world/model/ObjectType.java
================
package io.github.minemon.world.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum ObjectType {

    TREE_0(true, true, 2, 3, RenderLayer.LAYERED, "treeONE"),
    TREE_1(true, true, 2, 3, RenderLayer.LAYERED, "treeTWO"),
    SNOW_TREE(true, true, 2, 3, RenderLayer.LAYERED, "snow_tree"),
    HAUNTED_TREE(true, true, 2, 3, RenderLayer.LAYERED, "haunted_tree"),
    RUINS_TREE(true, true, 2, 3, RenderLayer.LAYERED, "ruins_tree"),
    APRICORN_TREE(true, true, 3, 3, RenderLayer.LAYERED, "apricorn_tree_grown"),


    CACTUS(true, true, 1, 2, RenderLayer.BELOW_PLAYER, "desert_cactus"),
    DEAD_TREE(true, true, 1, 2, RenderLayer.BELOW_PLAYER, "dead_tree"),
    SMALL_HAUNTED_TREE(true, true, 1, 2, RenderLayer.BELOW_PLAYER, "small_haunted_tree"),
    BUSH(true, true, 3, 2, RenderLayer.BELOW_PLAYER, "bush"),
    VINES(true, false, 1, 2, RenderLayer.BELOW_PLAYER, "vines"),
    RUIN_POLE(true, true, 1, 3, RenderLayer.BELOW_PLAYER, "ruins_pole"),
    POKEBALL(true, true, 1, 1, RenderLayer.BELOW_PLAYER, "pokeball"),
    RAIN_TREE(true, true, 2, 3, RenderLayer.LAYERED, "rain_tree"),
    CHERRY_TREE(true, true, 2, 3, RenderLayer.LAYERED, "CherryTree"),
    SUNFLOWER(true, false, 1, 2, RenderLayer.BELOW_PLAYER, "sunflower");

    private final boolean isPermanent;
    private final boolean isCollidable;
    private final int widthInTiles;
    private final int heightInTiles;
    private final RenderLayer renderLayer;
    private final String textureRegionName;

    public enum RenderLayer {
        BELOW_PLAYER,
        ABOVE_PLAYER,
        LAYERED,
        ABOVE_TALL_GRASS
    }
}

================
File: main/java/io.github.minemon/world/model/WorldData.java
================
package io.github.minemon.world.model;

import java.util.HashMap;
import java.util.Map;

import io.github.minemon.player.model.PlayerData;
import lombok.Getter;
import lombok.Setter;

@Getter
public class WorldData {
    @Setter
    private String worldName;
    @Setter
    private long seed;
    private final Map<String, PlayerData> players = new HashMap<>();
    private final Map<String, ChunkData> chunks = new HashMap<>();

    @Setter
    private long createdDate;
    @Setter
    private long lastPlayed;
    @Setter
    private long playedTime; 
}

================
File: main/java/io.github.minemon/world/model/WorldMetadata.java
================
package io.github.minemon.world.model;


import lombok.Data;

@Data
public class WorldMetadata {

    private String worldName;

    private long seed;
    private long createdDate;
    private long lastPlayed;
    private long playedTime;
}

================
File: main/java/io.github.minemon/world/model/WorldObject.java
================
package io.github.minemon.world.model;

import com.badlogic.gdx.math.Rectangle;

import lombok.Data;

import java.util.UUID;


@Data
public class WorldObject {

    private String id;

    private int tileX;
    private int tileY;

    private ObjectType type;

    private float spawnTime;
    private boolean collidable;

    
    private float timeSinceVisible;

    public WorldObject() {

    }

    public WorldObject(int tileX, int tileY, ObjectType type, boolean collidable) {
        this.tileX = tileX;
        this.tileY = tileY;
        this.type = type;
        this.collidable = collidable;
        this.id = UUID.randomUUID().toString();
        this.spawnTime = type.isPermanent() ? 0f : (System.currentTimeMillis() / 1000f);
        this.timeSinceVisible = 0f;
    }

    

    public float getFadeAlpha() {
        return Math.min(timeSinceVisible, 1f);
    }

    

    public Rectangle getCollisionBox() {
        if (!collidable) {
            return null;
        }

        float pixelX = tileX * 32;
        float pixelY = tileY * 32;

        if (isTreeType(this.type)) {
            float baseX = pixelX - 32;
            return new Rectangle(baseX, pixelY, this.type.getWidthInTiles() * 32, 32);
        } else {
            return new Rectangle(
                    pixelX,
                    pixelY,
                    this.type.getWidthInTiles() * 32,
                    this.type.getHeightInTiles() * 32
            );
        }
    }


    private boolean isTreeType(ObjectType t) {
        return t == ObjectType.TREE_0 ||
                t == ObjectType.TREE_1 ||
                t == ObjectType.SNOW_TREE ||
                t == ObjectType.HAUNTED_TREE ||
                t == ObjectType.RUINS_TREE ||
                t == ObjectType.APRICORN_TREE ||
                t == ObjectType.RAIN_TREE ||
                t == ObjectType.CHERRY_TREE;
    }
}

================
File: main/java/io.github.minemon/world/model/WorldRenderer.java
================
package io.github.minemon.world.model;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import io.github.minemon.world.service.TileManager;
import io.github.minemon.world.service.WorldService;
import io.github.minemon.world.service.impl.ObjectTextureManager;
import org.springframework.stereotype.Component;

import java.util.Comparator;
import java.util.List;
import java.util.Map;

@Component
public class WorldRenderer {
    private static final int TILE_SIZE = 32;
    private static final int CHUNK_SIZE = 16;

    private static final int VIEW_PADDING = 5;

    private final TileManager tileManager;
    private final WorldService worldService;

    private final ObjectTextureManager objectTextureManager;

    private SpriteBatch batch;
    private boolean initialized = false;

    private float currentDelta = 0f;

    public WorldRenderer(WorldService worldService, TileManager tileManager, ObjectTextureManager objectTextureManager) {
        this.worldService = worldService;
        this.tileManager = tileManager;
        this.objectTextureManager = objectTextureManager;
    }

    public void initialize() {
        if (!initialized) {
            this.batch = new SpriteBatch();
            initialized = true;
        }
    }

    public void render(OrthographicCamera camera, float delta) {
        if (!initialized) {
            initialize();
        }
        currentDelta = delta;
        worldService.setCamera(camera);
        batch.setProjectionMatrix(camera.combined);
        batch.begin();

        renderGroundLayer();
        renderBelowPlayerLayer();
        renderTreeBases();

        batch.end();
    }

    public void renderTreeTops(float delta) {
        currentDelta = delta;
        batch.begin();
        renderAbovePlayerLayer();
        renderTreeTopsForLayeredTrees();
        batch.end();
    }

    private Rectangle calculateViewBounds() {
        OrthographicCamera camera = worldService.getCamera();
        float width = camera.viewportWidth * camera.zoom;
        float height = camera.viewportHeight * camera.zoom;

        return new Rectangle(
                camera.position.x - (width / 2) - (TILE_SIZE * VIEW_PADDING),
                camera.position.y - (height / 2) - (TILE_SIZE * VIEW_PADDING),
                width + (TILE_SIZE * VIEW_PADDING * 2),
                height + (TILE_SIZE * VIEW_PADDING * 2)
        );
    }

    private void renderGroundLayer() {
        Rectangle viewBounds = calculateViewBounds();
        Map<String, ChunkData> visibleChunks = worldService.getVisibleChunks(viewBounds);

        batch.setColor(Color.WHITE);
        for (Map.Entry<String, ChunkData> entry : visibleChunks.entrySet()) {
            String[] coords = entry.getKey().split(",");
            int chunkX = Integer.parseInt(coords[0]);
            int chunkY = Integer.parseInt(coords[1]);
            ChunkData chunkData = entry.getValue();

            int[][] tiles = chunkData.getTiles();
            if (tiles != null) {
                for (int x = 0; x < CHUNK_SIZE; x++) {
                    for (int y = 0; y < CHUNK_SIZE; y++) {
                        TextureRegion region = tileManager.getRegionForTile(tiles[x][y]);
                        if (region != null) {
                            float worldX = (chunkX * CHUNK_SIZE + x) * TILE_SIZE;
                            float worldY = (chunkY * CHUNK_SIZE + y) * TILE_SIZE;
                            batch.draw(region, worldX, worldY, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }
            }
        }
    }

    private void renderBelowPlayerLayer() {
        Rectangle viewBounds = calculateViewBounds();
        List<WorldObject> objects = worldService.getVisibleObjects(viewBounds);

        objects.stream()
                .filter(obj -> obj.getType().getRenderLayer() == ObjectType.RenderLayer.BELOW_PLAYER)
                .sorted(Comparator.comparingInt(WorldObject::getTileY))
                .forEach(this::renderObjectWithFade);
    }

    private void renderAbovePlayerLayer() {
        Rectangle viewBounds = calculateViewBounds();
        List<WorldObject> objects = worldService.getVisibleObjects(viewBounds);

        objects.stream()
                .filter(obj -> obj.getType().getRenderLayer() == ObjectType.RenderLayer.ABOVE_PLAYER)
                .sorted(Comparator.comparingInt(WorldObject::getTileY))
                .forEach(this::renderObjectWithFade);
    }

    private void renderTreeBases() {
        Rectangle viewBounds = calculateViewBounds();
        List<WorldObject> objects = worldService.getVisibleObjects(viewBounds);

        objects.stream()
                .filter(obj -> obj.getType().getRenderLayer() == ObjectType.RenderLayer.LAYERED)
                .forEach(this::renderTreeBase);
    }

    private void renderTreeTopsForLayeredTrees() {
        Rectangle viewBounds = calculateViewBounds();
        List<WorldObject> objects = worldService.getVisibleObjects(viewBounds);

        objects.stream()
                .filter(obj -> obj.getType().getRenderLayer() == ObjectType.RenderLayer.LAYERED)
                .sorted(Comparator.comparingInt(WorldObject::getTileY))
                .forEach(this::renderTreeTop);
    }

    private void renderObjectWithFade(WorldObject obj) {
        TextureRegion texture = getObjectTexture(obj);
        if (texture == null) return;

        obj.setTimeSinceVisible(obj.getTimeSinceVisible() + currentDelta);

        float alpha = obj.getFadeAlpha();
        Color c = batch.getColor();
        batch.setColor(c.r, c.g, c.b, alpha);

        float x = obj.getTileX() * TILE_SIZE;
        float y = obj.getTileY() * TILE_SIZE;
        int width = obj.getType().getWidthInTiles() * TILE_SIZE;
        int height = obj.getType().getHeightInTiles() * TILE_SIZE;
        batch.draw(texture, x, y, width, height);

        batch.setColor(c.r, c.g, c.b, 1f);
    }

    private void renderTreeBase(WorldObject tree) {
        TextureRegion fullTexture = getObjectTexture(tree);
        if (fullTexture == null) return;

        tree.setTimeSinceVisible(tree.getTimeSinceVisible() + currentDelta);

        int totalHeight = fullTexture.getRegionHeight();
        int baseHeight = totalHeight / 3;

        TextureRegion baseRegion = new TextureRegion(
                fullTexture.getTexture(),
                fullTexture.getRegionX(),
                fullTexture.getRegionY() + totalHeight - baseHeight,
                fullTexture.getRegionWidth(),
                baseHeight
        );

        float renderX = tree.getTileX() * TILE_SIZE - TILE_SIZE;
        float renderY = tree.getTileY() * TILE_SIZE;

        float alpha = tree.getFadeAlpha();
        Color c = batch.getColor();
        batch.setColor(c.r, c.g, c.b, alpha);

        batch.draw(baseRegion,
                renderX, renderY,
                tree.getType().getWidthInTiles() * TILE_SIZE,
                TILE_SIZE);

        batch.setColor(c.r, c.g, c.b, 1f);
    }

    private void renderTreeTop(WorldObject tree) {
        TextureRegion fullTexture = getObjectTexture(tree);
        if (fullTexture == null) return;

        tree.setTimeSinceVisible(tree.getTimeSinceVisible() + currentDelta);

        int totalHeight = fullTexture.getRegionHeight();
        int topHeight = (totalHeight * 2) / 3;

        TextureRegion topRegion = new TextureRegion(
                fullTexture.getTexture(),
                fullTexture.getRegionX(),
                fullTexture.getRegionY(),
                fullTexture.getRegionWidth(),
                topHeight
        );

        float renderX = tree.getTileX() * TILE_SIZE - TILE_SIZE;
        float renderY = tree.getTileY() * TILE_SIZE + TILE_SIZE;

        float alpha = tree.getFadeAlpha();
        Color c = batch.getColor();
        batch.setColor(c.r, c.g, c.b, alpha);

        batch.draw(topRegion,
                renderX, renderY,
                tree.getType().getWidthInTiles() * TILE_SIZE,
                TILE_SIZE * 2);

        batch.setColor(c.r, c.g, c.b, 1f);
    }

    
    private TextureRegion getObjectTexture(WorldObject obj) {
        String regionName = obj.getType().getTextureRegionName();
        return objectTextureManager.getTexture(regionName);
    }

    public void dispose() {
        batch.dispose();
    }
}

================
File: main/java/io.github.minemon/world/service/ChunkLoaderService.java
================
package io.github.minemon.world.service;

import com.badlogic.gdx.math.Vector2;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.*;

@Service
public class ChunkLoaderService {
    private static final int VISIBLE_RADIUS = 2;
    private static final int PRELOAD_RADIUS = 4;

    private final Map<Vector2, Float> chunkFadeStates = new ConcurrentHashMap<>();
    private final Set<Vector2> preloadedChunks = Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final WorldService worldService;
    private final ExecutorService executorService;
    private final Map<Vector2, CompletableFuture<Void>> loadingChunks = new ConcurrentHashMap<>();
    public ChunkLoaderService(WorldService worldService) {
        this.worldService = worldService;
        this.executorService = Executors.newFixedThreadPool(4);
    }

    public void updatePlayerPosition(float playerX, float playerY) {
        int chunkX = (int) Math.floor(playerX / (16 * 32));
        int chunkY = (int) Math.floor(playerY / (16 * 32));


        Set<Vector2> requiredChunks = new HashSet<>();
        for (int dx = -PRELOAD_RADIUS; dx <= PRELOAD_RADIUS; dx++) {
            for (int dy = -PRELOAD_RADIUS; dy <= PRELOAD_RADIUS; dy++) {
                requiredChunks.add(new Vector2(chunkX + dx, chunkY + dy));
            }
        }


        for (Vector2 chunkPos : requiredChunks) {
            if (!preloadedChunks.contains(chunkPos)) {
                preloadChunk(chunkPos);
            }
        }


        for (int dx = -VISIBLE_RADIUS; dx <= VISIBLE_RADIUS; dx++) {
            for (int dy = -VISIBLE_RADIUS; dy <= VISIBLE_RADIUS; dy++) {
                Vector2 visibleChunk = new Vector2(chunkX + dx, chunkY + dy);
                if (!chunkFadeStates.containsKey(visibleChunk)) {
                    chunkFadeStates.put(visibleChunk, 0f);
                }
            }
        }
    }

    private void preloadChunk(Vector2 chunkPos) {
        if (!loadingChunks.containsKey(chunkPos) && !worldService.isChunkLoaded(chunkPos)) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                worldService.loadChunk(chunkPos);
                preloadedChunks.add(chunkPos);
            }, executorService).whenComplete((result, ex) -> {
                loadingChunks.remove(chunkPos);
            });
            loadingChunks.put(chunkPos, future);
        }
    }
    private void preloadChunks(int centerX, int centerY) {
        Set<Vector2> requiredChunks = new HashSet<>();


        for (int dx = -PRELOAD_RADIUS; dx <= PRELOAD_RADIUS; dx++) {
            for (int dy = -PRELOAD_RADIUS; dy <= PRELOAD_RADIUS; dy++) {
                requiredChunks.add(new Vector2(centerX + dx, centerY + dy));
            }
        }


        for (Vector2 chunkPos : requiredChunks) {
            if (!loadingChunks.containsKey(chunkPos) && !worldService.isChunkLoaded(chunkPos)) {
                CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                    worldService.loadChunk(chunkPos);
                }, executorService).whenComplete((result, ex) -> {
                    loadingChunks.remove(chunkPos);
                });
                loadingChunks.put(chunkPos, future);
            }
        }
    }

    public void dispose() {
        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
        }
    }
}

================
File: main/java/io.github.minemon/world/service/ChunkPreloaderService.java
================
package io.github.minemon.world.service;

import com.badlogic.gdx.math.Vector2;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;


@Service
@Slf4j
public class ChunkPreloaderService {
    private static final int PRELOAD_RADIUS = 3;

    private final WorldService worldService;
    private final ExecutorService executor = Executors.newSingleThreadExecutor();
    private float lastPreloadX = Float.MIN_VALUE;
    private float lastPreloadY = Float.MIN_VALUE;

    public ChunkPreloaderService(WorldService worldService) {
        this.worldService = worldService;
    }

    public void preloadAround(float playerX, float playerY) {

        if (Math.abs(playerX - lastPreloadX) < 128 && Math.abs(playerY - lastPreloadY) < 128) {
            return;
        }
        lastPreloadX = playerX;
        lastPreloadY = playerY;

        int tileX = (int)(playerX / 32);
        int tileY = (int)(playerY / 32);
        int playerChunkX = tileX / 16;
        int playerChunkY = tileY / 16;

        executor.submit(() -> {
            for (int cx = playerChunkX - PRELOAD_RADIUS; cx <= playerChunkX + PRELOAD_RADIUS; cx++) {
                for (int cy = playerChunkY - PRELOAD_RADIUS; cy <= playerChunkY + PRELOAD_RADIUS; cy++) {
                    Vector2 chunkPos = new Vector2(cx, cy);
                    if (!worldService.isChunkLoaded(chunkPos)) {
                        worldService.loadChunk(chunkPos);
                    }
                }
            }
            log.debug("Preloaded chunks around player ({},{})", playerX, playerY);
        });
    }

    public void dispose() {
        executor.shutdownNow();
    }
}

================
File: main/java/io.github.minemon/world/service/impl/BaseWorldServiceImpl.java
================
package io.github.minemon.world.service.impl;

import com.badlogic.gdx.graphics.OrthographicCamera;
import io.github.minemon.world.service.WorldService;

public abstract class BaseWorldServiceImpl implements WorldService {
    protected OrthographicCamera camera;

    @Override
    public OrthographicCamera getCamera() {
        return camera;
    }

    @Override
    public void setCamera(OrthographicCamera camera) {
        this.camera = camera;
    }
}

================
File: main/java/io.github.minemon/world/service/impl/ChunkCacheManager.java
================
package io.github.minemon.world.service.impl;

import io.github.minemon.world.service.WorldService;
import jakarta.annotation.PreDestroy;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Service
@Slf4j
public class ChunkCacheManager {
    private final Map<String, Map<ChunkKey, Long>> clientChunks = new ConcurrentHashMap<>();
    private final ScheduledExecutorService cleanupExecutor;
    private final int maxChunksPerClient;
    private final long cacheTtl;

    public ChunkCacheManager(
            @Value("${server.chunk.cache.maxPerClient:256}") int maxChunksPerClient,
            @Value("${server.chunk.cache.ttl:300000}") long cacheTtl) {
        this.maxChunksPerClient = maxChunksPerClient;
        this.cacheTtl = cacheTtl;
        this.cleanupExecutor = Executors.newSingleThreadScheduledExecutor();
        startCleanupTask();
    }

    public boolean isChunkCached(String clientId, int chunkX, int chunkY) {
        Map<ChunkKey, Long> clientCache = clientChunks.get(clientId);
        if (clientCache == null) return false;

        ChunkKey key = new ChunkKey(chunkX, chunkY);
        Long cacheTime = clientCache.get(key);
        if (cacheTime == null) return false;

        if (System.currentTimeMillis() - cacheTime > cacheTtl) {
            clientCache.remove(key);
            return false;
        }
        return true;
    }
    private final boolean isServer = false;

    @Autowired
    private WorldService worldService;

    public void cacheChunk(String clientId, int chunkX, int chunkY) {
        // Only cache on server or in singleplayer
        if (!isServer && worldService.isMultiplayerMode()) {
            return;
        }
        clientChunks.computeIfAbsent(clientId, k -> new ConcurrentHashMap<>())
                .put(new ChunkKey(chunkX, chunkY), System.currentTimeMillis());

        // If cache too large, remove oldest entries
        Map<ChunkKey, Long> clientCache = clientChunks.get(clientId);
        if (clientCache.size() > maxChunksPerClient) {
            List<ChunkKey> oldestChunks = clientCache.entrySet().stream()
                    .sorted(Map.Entry.comparingByValue())
                    .limit(clientCache.size() - maxChunksPerClient)
                    .map(Map.Entry::getKey)
                    .toList();

            for (ChunkKey key : oldestChunks) {
                clientCache.remove(key);
            }
        }
    }

    public void removeClient(String clientId) {
        clientChunks.remove(clientId);
        log.debug("Removed chunk cache for client: {}", clientId);
    }

    private void startCleanupTask() {
        cleanupExecutor.scheduleAtFixedRate(this::cleanupCache,
                60, 60, TimeUnit.SECONDS);
    }

    private void cleanupCache() {
        long now = System.currentTimeMillis();
        clientChunks.forEach((clientId, chunks) -> {
            chunks.entrySet().removeIf(entry ->
                    now - entry.getValue() > cacheTtl);
        });
        clientChunks.entrySet().removeIf(entry -> entry.getValue().isEmpty());
        log.debug("Completed chunk cache cleanup");
    }

    @PreDestroy
    public void shutdown() {
        cleanupExecutor.shutdown();
        try {
            if (!cleanupExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                cleanupExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            cleanupExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    @Data
    @AllArgsConstructor
    private static class ChunkKey {
        private final int x;
        private final int y;
    }
}

================
File: main/java/io.github.minemon/world/service/impl/ClientTileManagerImpl.java
================
package io.github.minemon.world.service.impl;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.utils.Json;
import io.github.minemon.core.service.FileAccessService;
import io.github.minemon.world.config.TileConfig;
import io.github.minemon.world.service.TileManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

import java.util.HashMap;

@Component
@Profile("client")
@Qualifier("clientTileManagerImpl")
public class ClientTileManagerImpl implements TileManager {
    private static final Logger logger = LoggerFactory.getLogger(ClientTileManagerImpl.class);

    @Value("${tiles.configPath:config/tiles.json}")
    private String tileConfigFile;

    private final HashMap<Integer, TileConfig.TileDefinition> tiles = new HashMap<>();
    private TextureAtlas atlas;
    private boolean initialized = false;
    private final FileAccessService fileAccessService;

    public ClientTileManagerImpl(FileAccessService fileAccessService) {
        this.fileAccessService = fileAccessService;
    }

    @Override
    public void initIfNeeded() {
        if (!initialized) {
            loadConfig(tileConfigFile);
            atlas = new TextureAtlas(Gdx.files.internal("assets/atlas/tiles-gfx-atlas.atlas"));
            initialized = true;
            logger.info("TileManager (client) initialized.");
        }
    }

    private void loadConfig(String tileConfigFile) {
        if (!fileAccessService.exists(tileConfigFile)) {
            logger.warn("Tile config file not found: {}", tileConfigFile);
            return;
        }

        String jsonContent = fileAccessService.readFile(tileConfigFile);
        Json json = new Json();
        TileConfig config = json.fromJson(TileConfig.class, jsonContent);
        for (TileConfig.TileDefinition def : config.getTiles()) {
            tiles.put(def.getId(), def);
        }
        logger.info("Loaded {} tiles from {}", tiles.size(), tileConfigFile);
    }

    @Override
    public TextureRegion getRegionForTile(int tileId) {
        TileConfig.TileDefinition def = tiles.get(tileId);
        if (def == null) {
            TextureRegion unknown = atlas.findRegion("unknown");
            if (unknown == null) {
                logger.warn("Unknown tile requested and no 'unknown' region found.");
            }
            return unknown;
        }
        TextureRegion region = atlas.findRegion(def.getTexture());
        if (region == null) {
            logger.warn("No region found in atlas for tile texture: {}", def.getTexture());
            return atlas.findRegion("unknown");
        }
        return region;
    }

    @Override
    public boolean isPassable(int tileId) {
        TileConfig.TileDefinition def = tiles.get(tileId);
        if (def == null) return false;
        return def.isPassable();
    }

    @Override
    public String getTileName(int tileId) {
        TileConfig.TileDefinition def = tiles.get(tileId);
        if (def == null) return "unknown";
        return def.getName();
    }
}

================
File: main/java/io.github.minemon/world/service/impl/ClientWorldServiceImpl.java
================
package io.github.minemon.world.service.impl;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.PixmapIO;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.FrameBuffer;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.minemon.multiplayer.model.WorldObjectUpdate;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.world.biome.config.BiomeConfigurationLoader;
import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.biome.model.BiomeType;
import io.github.minemon.world.biome.service.BiomeService;
import io.github.minemon.world.config.WorldConfig;
import io.github.minemon.world.model.*;
import io.github.minemon.world.service.TileManager;
import io.github.minemon.world.service.WorldGenerator;
import io.github.minemon.world.service.WorldObjectManager;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Lazy;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.*;

@Slf4j
@Service
@Profile("client")
public class ClientWorldServiceImpl extends BaseWorldServiceImpl implements WorldService {
    private static final int CHUNK_SIZE = 16;
    private final boolean isServer = false;
    private static final int TILE_SIZE = 32;
    private final WorldGenerator worldGenerator;
    @Autowired

    @Lazy
    private final WorldObjectManager worldObjectManager;
    private final TileManager tileManager;
    private final ObjectTextureManager objectTextureManager;
    private final BiomeConfigurationLoader biomeLoader;
    private final BiomeService biomeService;

    private final JsonWorldDataService jsonWorldDataService;  // NEW

    private final WorldData worldData = new WorldData();
    @Value("${world.defaultName:defaultWorld}")
    private String defaultWorldName;
    @Value("${world.saveDir:assets/save/worlds/}")
    private String saveDir;
    private boolean initialized = false;

    @Autowired
    @Lazy
    private MultiplayerClient multiplayerClient;

    private boolean isMultiplayerMode = false;


    public ClientWorldServiceImpl(
            WorldConfig worldConfig,
            WorldGenerator worldGenerator,
            WorldObjectManager worldObjectManager,
            TileManager tileManager,
            BiomeConfigurationLoader biomeLoader,
            BiomeService biomeService,
            ObjectTextureManager objectTextureManager,
            JsonWorldDataService jsonWorldDataService     // NEW
    ) {
        this.worldGenerator = worldGenerator;
        this.worldObjectManager = worldObjectManager;
        this.tileManager = tileManager;
        this.biomeLoader = biomeLoader;
        this.biomeService = biomeService;
        // this.worldMetadataRepo = worldMetadataRepo;   // REMOVED
        // this.chunkRepository = chunkRepository;       // REMOVED
        // this.playerDataRepository = playerDataRepository; // REMOVED
        this.objectTextureManager = objectTextureManager;
        this.jsonWorldDataService = jsonWorldDataService; // NEW
    }

    @Override
    public void generateWorldThumbnail(String worldName) {
        initIfNeeded();
        objectTextureManager.initializeIfNeeded();
        int previewSize = 8;
        int tileSize = 32;
        int iconWidth = 128;
        int iconHeight = 128;

        float scaleX = (float) iconWidth / (previewSize * tileSize);
        float scaleY = (float) iconHeight / (previewSize * tileSize);
        float scale = Math.min(scaleX, scaleY);

        FrameBuffer fbo = new FrameBuffer(Pixmap.Format.RGBA8888, iconWidth, iconHeight, false);
        SpriteBatch batch = new SpriteBatch();

        fbo.begin();
        Gdx.gl.glClearColor(0, 0, 0, 0);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        OrthographicCamera camera = new OrthographicCamera(iconWidth, iconHeight);
        camera.setToOrtho(true, iconWidth, iconHeight);

        batch.setProjectionMatrix(camera.combined);
        batch.begin();

        com.badlogic.gdx.math.Matrix4 transform = batch.getTransformMatrix();
        transform.idt();

        float worldWidth = previewSize * tileSize;
        float worldHeight = previewSize * tileSize;
        transform.translate(iconWidth / 2f, iconHeight / 2f, 0);
        transform.scale(scale, scale, 1f);
        transform.translate(-worldWidth / 2f, -worldHeight / 2f, 0);

        batch.setTransformMatrix(transform);

        int centerX = 0;
        int centerY = 0;


        for (int dy = 0; dy < previewSize; dy++) {
            for (int dx = 0; dx < previewSize; dx++) {
                int tileX = centerX + dx - previewSize / 2;
                int tileY = centerY + dy - previewSize / 2;
                int chunkX = tileX / 16;
                int chunkY = tileY / 16;
                int[][] tiles = getChunkTiles(chunkX, chunkY);
                if (tiles != null) {
                    int localX = Math.floorMod(tileX, 16);
                    int localY = Math.floorMod(tileY, 16);
                    if (localX >= 0 && localX < 16 && localY >= 0 && localY < 16) {
                        int tileType = tiles[localX][localY];
                        TextureRegion region = tileManager.getRegionForTile(tileType);
                        if (region != null) {
                            float worldPixelX = dx * tileSize;
                            float worldPixelY = dy * tileSize;
                            batch.draw(region, worldPixelX, worldPixelY, tileSize, tileSize);
                        }
                    }
                }
            }
        }


        Set<String> processedChunks = new HashSet<>();
        for (int dy = 0; dy < previewSize; dy++) {
            for (int dx = 0; dx < previewSize; dx++) {
                int tileX = centerX + dx - previewSize / 2;
                int tileY = centerY + dy - previewSize / 2;
                int chunkX = tileX / 16;
                int chunkY = tileY / 16;
                String key = chunkX + "," + chunkY;
                if (!processedChunks.contains(key)) {
                    List<WorldObject> objs = worldObjectManager.getObjectsForChunk(chunkX, chunkY);
                    for (WorldObject obj : objs) {
                        int objTileX = obj.getTileX();
                        int objTileY = obj.getTileY();
                        if (objTileX >= centerX - previewSize / 2 && objTileX < centerX + previewSize / 2 &&
                                objTileY >= centerY - previewSize / 2 && objTileY < centerY + previewSize / 2) {
                            float worldPixelX = (objTileX - (centerX - (float) previewSize / 2)) * tileSize;
                            float worldPixelY = (objTileY - (centerY - (float) previewSize / 2)) * tileSize;


                            TextureRegion objTexture = objectTextureManager.getTexture(obj.getType().getTextureRegionName());
                            if (objTexture != null) {
                                batch.draw(objTexture, worldPixelX, worldPixelY,
                                        obj.getType().getWidthInTiles() * tileSize,
                                        obj.getType().getHeightInTiles() * tileSize);
                            }
                        }
                    }
                    processedChunks.add(key);
                }
            }
        }

        batch.end();

        Pixmap pm = Pixmap.createFromFrameBuffer(0, 0, iconWidth, iconHeight);
        fbo.end();


        FileHandle dir = Gdx.files.local(saveDir + worldName);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        FileHandle iconFile = Gdx.files.local(saveDir + worldName + "/icon.png");
        PixmapIO.writePNG(iconFile, pm);

        pm.dispose();
        batch.dispose();
        fbo.dispose();

        log.info("Generated world thumbnail for '{}'", worldName);
    }

    /**
     * Returns the tiles for a given chunk, handling both singleplayer and multiplayer modes
     */
    @Override
    public int[][] getChunkTiles(int chunkX, int chunkY) {
        String key = chunkX + "," + chunkY;
        ChunkData cData = getWorldData().getChunks().get(key);

        if (cData == null) {
            if (isMultiplayerMode) {
                // Only request if not already pending
                if (!multiplayerClient.isPendingChunkRequest(chunkX, chunkY)) {
                    log.debug("Requesting chunk {},{} from server", chunkX, chunkY);
                    multiplayerClient.requestChunk(chunkX, chunkY);
                } else {
                    log.trace("Chunk {},{} already requested", chunkX, chunkY);
                }
                return null;
            } else {
                // Only generate locally in singleplayer mode
                loadOrGenerateChunk(chunkX, chunkY);
                cData = getWorldData().getChunks().get(key);
            }
        }

        return (cData != null) ? cData.getTiles() : null;
    }

    @Override
    public void loadOrReplaceChunkData(int chunkX, int chunkY, int[][] tiles, List<WorldObject> objects) {
        String key = chunkX + "," + chunkY;
        ChunkData cData = new ChunkData();
        cData.setChunkX(chunkX);
        cData.setChunkY(chunkY);
        cData.setTiles(tiles);
        cData.setObjects(objects);
        getWorldData().getChunks().put(key, cData);
        if (!isMultiplayerMode) {
            try {
                jsonWorldDataService.saveChunk(getWorldData().getWorldName(), cData);
            } catch (IOException e) {
                log.error("Failed to save chunk data for chunk {}: {}", key, e.getMessage());
            }
        } else {
            log.debug("Skipping local chunk save in multiplayer mode for chunk {}", key);
        }
    }

    @Override
    public void updateWorldObjectState(WorldObjectUpdate update) {
        String key = (update.getTileX() / 16) + "," + (update.getTileY() / 16);
        ChunkData chunk = getWorldData().getChunks().get(key);
        if (chunk == null) return; // chunk not loaded

        List<WorldObject> objs = chunk.getObjects();
        if (update.isRemoved()) {
            objs.removeIf(o -> o.getId().equals(update.getObjectId()));
        } else {
            boolean found = false;
            for (WorldObject wo : objs) {
                if (wo.getId().equals(update.getObjectId())) {
                    wo.setTileX(update.getTileX());
                    wo.setTileY(update.getTileY());
                    found = true;
                    break;
                }
            }
            if (!found) {
                ObjectType objType = ObjectType.valueOf(update.getType());
                WorldObject newObj = new WorldObject(
                        update.getTileX(),
                        update.getTileY(),
                        objType,
                        objType.isCollidable()
                );
                objs.add(newObj);
            }
        }

        // Save chunk
        try {
            jsonWorldDataService.saveChunk(getWorldData().getWorldName(), chunk);
        } catch (IOException e) {
            log.error("Failed to save chunk after updateWorldObjectState: {}", e.getMessage());
        }
    }

    @Override
    public TileManager getTileManager() {
        return this.tileManager;
    }

    @Override
    public void initIfNeeded() {
        if (initialized) {
            return;
        }

        Map<BiomeType, Biome> biomes = biomeLoader.loadBiomes("assets/config/biomes.json");
        if (worldData.getSeed() == 0) {
            long randomSeed = new Random().nextLong();
            worldData.setSeed(randomSeed);
            log.info("No existing seed found; using random seed: {}", randomSeed);
        }

        long seed = worldData.getSeed();
        worldGenerator.setSeedAndBiomes(seed, biomes);
        biomeService.initWithSeed(seed);

        worldObjectManager.initialize();
        tileManager.initIfNeeded();

        initialized = true;
        log.info("WorldService (client) initialized with seed {}", seed);
    }

    @Override
    public WorldData getWorldData() {
        return worldData;
    }

    @Override
    public boolean createWorld(String worldName, long seed) {
        // If it already exists on disk
        if (jsonWorldDataService.worldExists(worldName)) {
            log.warn("World '{}' already exists, cannot create", worldName);
            return false;
        }
        long now = System.currentTimeMillis();
        worldData.setWorldName(worldName);
        worldData.setSeed(seed);
        worldData.setCreatedDate(now);
        worldData.setLastPlayed(now);
        worldData.setPlayedTime(0);

        // Save
        try {
            jsonWorldDataService.saveWorld(worldData);
        } catch (IOException e) {
            log.error("Failed to create world '{}': {}", worldName, e.getMessage());
            return false;
        }
        log.info("Created new world '{}' with seed {}", worldName, seed);
        return true;
    }

    @Override
    public void saveWorldData() {
        if (worldData.getWorldName() == null || worldData.getWorldName().isEmpty()) {
            log.info("No world loaded, nothing to save.");
            return;
        }

        try {
            worldData.setLastPlayed(System.currentTimeMillis());
            jsonWorldDataService.saveWorld(worldData);
            log.info("Saved world data for '{}'", worldData.getWorldName());
        } catch (IOException e) {
            log.error("Failed saving world '{}': {}", worldData.getWorldName(), e.getMessage());
        }
    }

    public void loadWorld(String worldName) {
        log.debug("loadWorld called with {}", worldName);

        this.worldData.getChunks().clear();
        this.worldData.getPlayers().clear();
        this.worldData.setSeed(0);
        this.initialized = false;

        try {
            jsonWorldDataService.loadWorld(worldName, this.worldData);
            log.debug("World data read from disk: name={}, seed={}", worldData.getWorldName(), worldData.getSeed());
            initIfNeeded();
            log.info("Loaded world data for world: {}", worldName);
        } catch (IOException e) {
            log.warn("Failed to load world '{}': {}", worldName, e.getMessage());
        }
    }


    @Override
    public void loadWorldData() {
        try {
            jsonWorldDataService.loadWorld(defaultWorldName, worldData);
            initIfNeeded();
            log.info("Loaded default world data for '{}' from JSON", defaultWorldName);
        } catch (IOException e) {
            log.warn("No default world '{}' found in JSON: {}", defaultWorldName, e.getMessage());
        }
    }


    @Override
    public Map<String, ChunkData> getVisibleChunks(Rectangle viewBounds) {
        Map<String, ChunkData> visibleChunks = new HashMap<>();
        int startChunkX = (int) Math.floor(viewBounds.x / (CHUNK_SIZE * TILE_SIZE));
        int startChunkY = (int) Math.floor(viewBounds.y / (CHUNK_SIZE * TILE_SIZE));
        int endChunkX = (int) Math.ceil((viewBounds.x + viewBounds.width) / (CHUNK_SIZE * TILE_SIZE));
        int endChunkY = (int) Math.ceil((viewBounds.y + viewBounds.height) / (CHUNK_SIZE * TILE_SIZE));

        for (int x = startChunkX; x <= endChunkX; x++) {
            for (int y = startChunkY; y <= endChunkY; y++) {
                String key = x + "," + y;
                ChunkData chunk = worldData.getChunks().get(key);
                if (chunk == null) {
                    // In client MP mode, request from server if not found
                    if (isMultiplayerMode) {
                        multiplayerClient.requestChunk(x, y);
                        continue;
                    } else {
                        loadOrGenerateChunk(x, y);
                        chunk = worldData.getChunks().get(key);
                    }
                }
                if (chunk != null) {
                    visibleChunks.put(key, chunk);
                }
            }
        }
        return visibleChunks;
    }

    private void loadOrGenerateChunk(int chunkX, int chunkY) {
        if (isMultiplayerMode) {
            return;
        }
        // 1) Attempt load from JSON
        try {
            ChunkData loaded = jsonWorldDataService.loadChunk(worldData.getWorldName(), chunkX, chunkY);
            if (loaded != null) {
                worldObjectManager.loadObjectsForChunk(chunkX, chunkY, loaded.getObjects());
                worldData.getChunks().put(chunkX + "," + chunkY, loaded);
                return;
            }
        } catch (IOException e) {
            log.warn("Failed reading chunk from JSON: {}", e.getMessage());
        }

        // 2) Generate
        int[][] tiles = worldGenerator.generateChunk(chunkX, chunkY);
        ChunkData cData = new ChunkData();
        cData.setChunkX(chunkX);
        cData.setChunkY(chunkY);

        cData.setTiles(tiles);
        Biome biome = worldGenerator.getBiomeForChunk(chunkX, chunkY);
        List<WorldObject> objs = worldObjectManager.generateObjectsForChunk(
                chunkX, chunkY, tiles, biome, getWorldData().getSeed());
        cData.setObjects(objs);
        worldData.getChunks().put(chunkX + "," + chunkY, cData);

        // 3) Save
        try {
            jsonWorldDataService.saveChunk(worldData.getWorldName(), cData);
        } catch (IOException e) {
            log.error("Failed to save chunk for newly generated chunk: {}", e.getMessage());
        }
    }

    @Override
    public boolean isChunkLoaded(Vector2 chunkPos) {
        String key = String.format("%d,%d", (int) chunkPos.x, (int) chunkPos.y);
        return worldData.getChunks().containsKey(key);
    }

    @Override
    public void loadChunk(Vector2 chunkPos) {
        loadOrGenerateChunk((int) chunkPos.x, (int) chunkPos.y);
    }

    @Override
    public List<WorldObject> getVisibleObjects(Rectangle viewBounds) {
        List<WorldObject> visibleObjects = new ArrayList<>();
        Map<String, ChunkData> visibleChunks = getVisibleChunks(viewBounds);
        for (ChunkData chunk : visibleChunks.values()) {
            if (chunk.getObjects() != null) {
                for (WorldObject obj : chunk.getObjects()) {
                    float pixelX = obj.getTileX() * TILE_SIZE;
                    float pixelY = obj.getTileY() * TILE_SIZE;
                    if (viewBounds.contains(pixelX, pixelY)) {
                        visibleObjects.add(obj);
                    }
                }
            }
        }
        return visibleObjects;
    }

    /**
     * Sets player data with multiplayer awareness
     */
    @Override
    public void setPlayerData(PlayerData playerData) {
        if (playerData == null) {
            log.warn("Attempt to set null player data");
            return;
        }

        // Always update in-memory state
        getWorldData().getPlayers().put(playerData.getUsername(), playerData);

        // Only save to disk in singleplayer mode
        if (!isMultiplayerMode) {
            String wName = getWorldData().getWorldName();
            if (wName == null || wName.isEmpty()) {
                wName = "defaultLocalWorld";
                getWorldData().setWorldName(wName);
                log.warn("Client had no local worldName set; using '{}'.", wName);
            }

            try {
                jsonWorldDataService.savePlayerData(wName, playerData);
                log.debug("Saved player data for {} in singleplayer mode", playerData.getUsername());
            } catch (IOException e) {
                log.error("Failed to save player data: {}", e.getMessage());
            }
        } else {
            log.trace("Skipping local save of player data in multiplayer mode for {}",
                    playerData.getUsername());
        }
    }

    @Override
    public void setMultiplayerMode(boolean multiplayer) {
        this.isMultiplayerMode = multiplayer;
        log.info("Set multiplayer mode to: {}", multiplayer);
    }

    @Override
    public boolean isMultiplayerMode(){
        return this.isMultiplayerMode;
    }

    @Override
    public PlayerData getPlayerData(String username) {
        PlayerData pd = getWorldData().getPlayers().get(username);
        if (pd == null) {
            String wName = getWorldData().getWorldName();
            try {
                pd = jsonWorldDataService.loadPlayerData(wName, username);
                if (pd == null) {
                    pd = new PlayerData(username, 0, 0);
                    jsonWorldDataService.savePlayerData(wName, pd);
                }
                getWorldData().getPlayers().put(username, pd);
            } catch (IOException e) {
                log.error("Failed to load or create player data for {}: {}", username, e.getMessage());
            }
        }
        return pd;
    }


    @Override
    public List<String> getAvailableWorlds() {
        return jsonWorldDataService.listAllWorlds();
    }

    @Override
    public void deleteWorld(String worldName) {
        if (!jsonWorldDataService.worldExists(worldName)) {
            log.warn("World '{}' does not exist, cannot delete", worldName);
            return;
        }
        jsonWorldDataService.deleteWorld(worldName);
        if (worldData.getWorldName() != null && worldData.getWorldName().equals(worldName)) {
            worldData.setWorldName(null);
            worldData.setSeed(0);
            worldData.getPlayers().clear();
            worldData.getChunks().clear();
            worldData.setCreatedDate(0);
            worldData.setLastPlayed(0);
            worldData.setPlayedTime(0);
            log.info("Cleared current loaded world data because it was deleted.");
        }
        log.info("Deleted world '{}'", worldName);
    }

    @Override
    public void regenerateChunk(int chunkX, int chunkY) {
        String key = chunkX + "," + chunkY;
        worldData.getChunks().remove(key);
        jsonWorldDataService.deleteChunk(worldData.getWorldName(), chunkX, chunkY);
        loadOrGenerateChunk(chunkX, chunkY);
    }
}

================
File: main/java/io.github.minemon/world/service/impl/JsonWorldDataService.java
================
package io.github.minemon.world.service.impl;

import com.badlogic.gdx.utils.Json;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.world.model.ChunkData;
import io.github.minemon.world.model.WorldData;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Now it references "saveDir" (by default "assets/save/worlds"),
 * ensuring we store everything in the same place used for icon.png
 */
@Service
@Slf4j
public class JsonWorldDataService {
    private final String baseWorldsDir;

    private final boolean isServer;
    private final Json json;
    private Path playerDataFolderPath(String worldName) {
        return worldFolderPath(worldName).resolve("playerdata");
    }

    @Autowired
    @Lazy
    private WorldService worldService;
    public void savePlayerData(String worldName, PlayerData playerData) throws IOException {
        // Only save if we're the server OR in singleplayer mode
        if (!isServer && worldService.isMultiplayerMode()) {
            log.debug("Skipping player data save in multiplayer client mode");
            return;
        }

        Path folder = playerDataFolderPath(worldName);
        if (!Files.exists(folder)) {
            Files.createDirectories(folder);
        }
        Path file = folder.resolve(playerData.getUsername() + ".json");

        if (isServer) {
            log.debug("Server saving player data for: {}", playerData.getUsername());
        } else {
            log.debug("Local save of player data in singleplayer mode for: {}", playerData.getUsername());
        }

        try (Writer w = Files.newBufferedWriter(file)) {
            json.toJson(playerData, w);
        }
    }

    public PlayerData loadPlayerData(String worldName, String username) throws IOException {
        Path folder = playerDataFolderPath(worldName);
        if (!Files.exists(folder)) {
            return null; // no folder at all
        }
        Path file = folder.resolve(username + ".json");
        if (!Files.exists(file)) {
            return null;
        }

        // Log for debugging
        log.info("Loading player data from {}", file.toAbsolutePath());

        try (Reader r = Files.newBufferedReader(file)) {
            return json.fromJson(PlayerData.class, r);
        }
    }


    public JsonWorldDataService(
            @Value("${world.saveDir:assets/save/worlds/}") String baseWorldsDir
    ) {
        this.isServer = "server".equals(System.getProperty("spring.profiles.active"));
        log.info("JsonWorldDataService initialized with isServer={}", isServer);
        this.baseWorldsDir = baseWorldsDir; // e.g. "assets/save/worlds"
        this.json = new Json();
        this.json.setIgnoreUnknownFields(true);
    }

    // Utility: build [assets/save/worlds + / + worldName] as a Path
    private Path worldFolderPath(String worldName) {
        return Paths.get(baseWorldsDir, worldName);
    }

    // The main world JSON file -> e.g. "assets/save/worlds/<worldName>/<worldName>.json"
    private Path worldFilePath(String worldName) {
        return worldFolderPath(worldName).resolve(worldName + ".json");
    }

    @SuppressWarnings("unused")
    public boolean worldExists(String worldName) {
        Path folder = worldFolderPath(worldName);
        Path worldFile = worldFilePath(worldName);
        return Files.exists(folder) && Files.exists(worldFile);
    }

    public void loadWorld(String worldName, WorldData worldData) throws IOException {
        Path worldFile = worldFilePath(worldName);
        if (!Files.exists(worldFile)) {
            throw new NoSuchFileException("World file not found: " + worldFile);
        }

        try (Reader reader = Files.newBufferedReader(worldFile)) {
            WorldData loaded = json.fromJson(WorldData.class, reader);
            worldData.setWorldName(loaded.getWorldName());
            worldData.setSeed(loaded.getSeed());
            worldData.setCreatedDate(loaded.getCreatedDate());
            worldData.setLastPlayed(loaded.getLastPlayed());
            worldData.setPlayedTime(loaded.getPlayedTime());
            worldData.getPlayers().clear();
            worldData.getPlayers().putAll(loaded.getPlayers());
            worldData.getChunks().clear();
            worldData.getChunks().putAll(loaded.getChunks());
        }
    }

    public void saveWorld(WorldData worldData) throws IOException {
        if (worldData.getWorldName() == null || worldData.getWorldName().isEmpty()) {
            throw new IllegalStateException("Cannot save a world with no name");
        }
        Path folder = worldFolderPath(worldData.getWorldName());
        if (!Files.exists(folder)) {
            Files.createDirectories(folder);
        }

        Path worldFile = worldFilePath(worldData.getWorldName());
        try (Writer writer = Files.newBufferedWriter(worldFile)) {
            json.toJson(worldData, writer);
        }
    }

    // -------------------------------------------------
    // Chunk storage: "assets/save/worlds/<worldName>/chunks/x,y.json"
    // -------------------------------------------------

    public ChunkData loadChunk(String worldName, int chunkX, int chunkY) throws IOException {
        Path p = chunkFilePath(worldName, chunkX, chunkY);
        if (!Files.exists(p)) {
            return null;
        }
        try (Reader r = Files.newBufferedReader(p)) {
            return json.fromJson(ChunkData.class, r);
        }
    }

    public void saveChunk(String worldName, ChunkData chunkData) throws IOException {
        synchronized (this) {
            Path p = chunkFilePath(worldName, chunkData.getChunkX(), chunkData.getChunkY());
            if (!Files.exists(p.getParent())) {
                Files.createDirectories(p.getParent());
            }
            // brand-new 'json' per call:
            Json localJson = new Json();
            localJson.setIgnoreUnknownFields(true);

            try (Writer writer = Files.newBufferedWriter(p)) {
                localJson.toJson(chunkData, writer);
            }
        }
    }


    private Path chunkFilePath(String worldName, int chunkX, int chunkY) {
        // e.g. "assets/save/worlds/<worldName>/chunks/<chunkX>,<chunkY>.json"
        return worldFolderPath(worldName)
                .resolve("chunks")
                .resolve(chunkX + "," + chunkY + ".json");
    }


    public List<String> listAllWorlds() {
        List<String> result = new ArrayList<>();
        Path root = Paths.get(baseWorldsDir);  // e.g. "assets/save/worlds"
        if (!Files.exists(root)) {
            return result;
        }
        try {
            Files.list(root)
                    .filter(Files::isDirectory)
                    .forEach(path -> {
                        // We check if <worldName>/<worldName>.json exists
                        String folderName = path.getFileName().toString();
                        Path worldJson = path.resolve(folderName + ".json");
                        if (Files.exists(worldJson)) {
                            result.add(folderName);
                        }
                    });
        } catch (IOException e) {
            log.warn("Could not list worlds: {}", e.getMessage());
        }
        return result;
    }

    /**
     * Delete entire world folder
     */
    public void deleteWorld(String worldName) {
        Path folder = worldFolderPath(worldName);
        if (!Files.exists(folder)) {
            return;
        }
        try {
            Files.walk(folder)
                    .sorted((p1, p2) -> p2.getNameCount() - p1.getNameCount()) // files first
                    .forEach(f -> {
                        try {
                            Files.delete(f);
                        } catch (IOException e) {
                            log.warn("Failed deleting {}", f);
                        }
                    });
        } catch (IOException e) {
            log.warn("Failed to fully delete world '{}': {}", worldName, e.getMessage());
        }
    }

    /**
     * Delete a chunk JSON
     */
    public void deleteChunk(String worldName, int chunkX, int chunkY) {
        try {
            Path p = chunkFilePath(worldName, chunkX, chunkY);
            Files.deleteIfExists(p);
        } catch (IOException e) {
            log.warn("Failed to delete chunk {}/({},{})", worldName, chunkX, chunkY);
        }
    }
}

================
File: main/java/io.github.minemon/world/service/impl/ObjectTextureManager.java
================
package io.github.minemon.world.service.impl;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;


@Service
@Slf4j
public class ObjectTextureManager {

    private TextureAtlas atlas;
    private final Map<String, TextureRegion> regionCache = new HashMap<>();
    private boolean initialized = false;

    
    public void initializeIfNeeded() {
        if (initialized) return;

        if (Gdx.files == null) {
            log.warn("Gdx environment not ready. Cannot load atlas yet.");
            return;
        }

        String ATLAS_PATH = "assets/atlas/tiles-gfx-atlas.atlas";
        if (!Gdx.files.internal(ATLAS_PATH).exists()) {
            log.error("Atlas file not found at: {}", ATLAS_PATH);
        } else {
            atlas = new TextureAtlas(Gdx.files.internal(ATLAS_PATH));
            log.info("ObjectTextureManager initialized with atlas: {}", ATLAS_PATH);
            initialized = true;
        }
    }

    
    public TextureRegion getTexture(String name) {
        if (!initialized || atlas == null) {
            log.warn("ObjectTextureManager not initialized or atlas not loaded. Name: {}", name);
            return null;
        }


        if (regionCache.containsKey(name)) {
            return regionCache.get(name);
        }

        TextureRegion region = atlas.findRegion(name);
        if (region == null) {
            log.warn("No region found for '{}', trying 'unknown' texture.", name);
            region = atlas.findRegion("unknown");
            if (region == null) {
                log.error("No 'unknown' region found in atlas. Unable to provide fallback.");
                return null;
            }
        }

        regionCache.put(name, region);
        return region;
    }

    public void disposeTextures() {
        if (atlas != null) {
            atlas.dispose();
            atlas = null;
            log.info("ObjectTextureManager atlas disposed.");
        }
    }

}

================
File: main/java/io.github.minemon/world/service/impl/ServerTileManagerImpl.java
================
package io.github.minemon.world.service.impl;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.minemon.world.service.TileManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

@Component
@Slf4j
@Primary
@Profile("server")
@Qualifier("serverTileManagerImpl")
public class ServerTileManagerImpl implements TileManager {

    @Override
    public void initIfNeeded() {
        log.info("ServerTileManagerImpl initialized (no-op).");
    }

    @Override
    public TextureRegion getRegionForTile(int tileId) {
        return null;
    }

    @Override
    public boolean isPassable(int tileId) {
        return true;
    }

    @Override
    public String getTileName(int tileId) {
        return "unknown";
    }
}

================
File: main/java/io.github.minemon/world/service/impl/ServerWorldObjectManagerImpl.java
================
package io.github.minemon.world.service.impl;

import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.model.ObjectType;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.world.service.WorldObjectManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
@Service
@Primary
@Slf4j
@Profile("server")
public class ServerWorldObjectManagerImpl implements WorldObjectManager {

    private final Map<String, List<WorldObject>> objectsByChunk = new ConcurrentHashMap<>();

    @Override
    public void initialize() {
        log.info("ServerWorldObjectManagerImpl initialized (no-op).");
    }

    @Override
    public List<WorldObject> getObjectsForChunk(int chunkX, int chunkY) {
        String key = chunkX + "," + chunkY;
        return objectsByChunk.getOrDefault(key, Collections.emptyList());
    }

    @Override
    public List<WorldObject> generateObjectsForChunk(int chunkX, int chunkY, int[][] tiles, Biome biome, long seed) {
        List<WorldObject> objects = new CopyOnWriteArrayList<>();
        int chunkSize = tiles.length;

        if (biome != null && biome.getSpawnableObjects().contains("TREE_0")) {
            Random random = new Random((chunkX * 341L + chunkY * 773L) ^ seed);
            int spacing = 4;

            for (int lx = 0; lx < chunkSize; lx += spacing) {
                for (int ly = 0; ly < chunkSize; ly += spacing) {
                    int tileId = tiles[lx][ly];

                    if (biome.getAllowedTileTypes().contains(tileId) && random.nextFloat() < 0.1f) {
                        int worldX = chunkX * chunkSize + lx;
                        int worldY = chunkY * chunkSize + ly;
                        if (noTreeNearby(objects, worldX, worldY, spacing)) {
                            WorldObject tree = new WorldObject(worldX, worldY, ObjectType.TREE_0, ObjectType.TREE_0.isCollidable());
                            objects.add(tree);
                        }
                    }
                }
            }
        }

        objectsByChunk.put(chunkX + "," + chunkY, objects);
        log.info("Generated {} objects for chunk {},{} on server.", objects.size(), chunkX, chunkY);
        return objects;
    }

    private boolean noTreeNearby(List<WorldObject> objects, int x, int y, int minDistance) {
        for (WorldObject obj : objects) {
            if (obj.getType().name().startsWith("TREE")) {
                int dx = obj.getTileX() - x;
                int dy = obj.getTileY() - y;
                if (dx * dx + dy * dy < minDistance * minDistance) {
                    return false;
                }
            }
        }
        return true;
    }

    @Override
    public void loadObjectsForChunk(int chunkX, int chunkY, List<WorldObject> objects) {
        String key = chunkX + "," + chunkY;
        objectsByChunk.put(key, objects);
    }

    @Override
    public void addObject(WorldObject object) {
        int chunkX = object.getTileX() / 16;
        int chunkY = object.getTileY() / 16;
        String key = chunkX + "," + chunkY;
        objectsByChunk.computeIfAbsent(key, k -> new CopyOnWriteArrayList<>()).add(object);
    }

    @Override
    public void removeObject(String objectId) {
        for (List<WorldObject> objs : objectsByChunk.values()) {
            objs.removeIf(o -> o.getId().equals(objectId));
        }
    }
}

================
File: main/java/io.github.minemon/world/service/impl/ServerWorldServiceImpl.java
================
package io.github.minemon.world.service.impl;


import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.minemon.multiplayer.model.WorldObjectUpdate;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.world.biome.config.BiomeConfigurationLoader;
import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.model.ChunkData;
import io.github.minemon.world.model.ObjectType;
import io.github.minemon.world.model.WorldData;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.world.service.TileManager;
import io.github.minemon.world.service.WorldGenerator;
import io.github.minemon.world.service.WorldObjectManager;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
@Slf4j
@Primary
@Profile("server")
public class ServerWorldServiceImpl extends BaseWorldServiceImpl implements WorldService {
    private static final int TILE_SIZE = 32;
    private static final int CHUNK_SIZE = 16;

    private final WorldGenerator worldGenerator;
    private final WorldObjectManager worldObjectManager;
    private final TileManager tileManager;
    private final BiomeConfigurationLoader biomeLoader;

    private final JsonWorldDataService jsonWorldDataService; // NEW

    private final WorldData worldData = new WorldData();
    private final Map<String, WorldData> loadedWorlds = new ConcurrentHashMap<>();
    private boolean initialized = false;
    @Value("${world.defaultName:defaultWorld}")
    private String defaultWorldName;

    private OrthographicCamera camera = null;

    public ServerWorldServiceImpl(
            WorldGenerator worldGenerator,
            WorldObjectManager worldObjectManager,
            TileManager tileManager,
            BiomeConfigurationLoader biomeLoader,
            JsonWorldDataService jsonWorldDataService
    ) {
        this.worldGenerator = worldGenerator;
        this.worldObjectManager = worldObjectManager;
        this.tileManager = tileManager;
        this.biomeLoader = biomeLoader;
        this.jsonWorldDataService = jsonWorldDataService;
    }

    @Override
    public void initIfNeeded() {
        if (!loadedWorlds.containsKey("serverWorld")) {
            try {
                WorldData wd = new WorldData();
                jsonWorldDataService.loadWorld("serverWorld", wd);
                loadedWorlds.put("serverWorld", wd);
            } catch (IOException e) {
                WorldData newWorld = new WorldData();
                newWorld.setWorldName("serverWorld");
                try {
                    jsonWorldDataService.saveWorld(newWorld);
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
                loadedWorlds.put("serverWorld", newWorld);
            }
        }
    }

    @Override
    public WorldData getWorldData() {
        return worldData;
    }

    @Override
    public boolean isMultiplayerMode() {
        return true;
    }

    private final boolean isServer = true;
    @Override
    public void setMultiplayerMode(boolean multiplayer) {

    }

    @Override
    public TileManager getTileManager() {
        return tileManager;
    }

    // ------------------------------
    // Saving and Loading from JSON
    // ------------------------------
    @Override
    public void loadWorldData() {
        // Instead of querying from DB, load from JSON
        try {
            jsonWorldDataService.loadWorld(defaultWorldName, worldData);
            initIfNeeded();
            log.info("Loaded default world data for '{}' from JSON (server)", defaultWorldName);
        } catch (IOException e) {
            log.warn("Failed to load default world '{}': {}", defaultWorldName, e.getMessage());
        }
    }

    @Override
    public boolean createWorld(String worldName, long seed) {
        // We simply set in-memory and call save
        if (jsonWorldDataService.worldExists(worldName)) {
            log.warn("World '{}' already exists, cannot create", worldName);
            return false;
        }

        long now = System.currentTimeMillis();
        worldData.setWorldName(worldName);
        worldData.setSeed(seed);
        worldData.setCreatedDate(now);
        worldData.setLastPlayed(now);
        worldData.setPlayedTime(0);

        // Immediately save to JSON
        try {
            jsonWorldDataService.saveWorld(worldData);
        } catch (IOException e) {
            log.error("Failed to create new world '{}': {}", worldName, e.getMessage());
            return false;
        }
        log.info("Created new world '{}' with seed {} in JSON (server)", worldName, seed);
        return true;
    }

    @Override
    public void saveWorldData() {
        WorldData wd = loadedWorlds.get("serverWorld");
        if (wd != null) {
            try {
                jsonWorldDataService.saveWorld(wd);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public void loadWorld(String worldName) {
        try {
            jsonWorldDataService.loadWorld(worldName, worldData);
            initIfNeeded();
            log.info("Loaded world data for '{}' from JSON (server)", worldName);
        } catch (IOException e) {
            log.warn("World '{}' does not exist in JSON or failed to load: {}", worldName, e.getMessage());
        }
    }

    // Return chunk tiles from loaded chunk or generate if missing
    @Override
    public int[][] getChunkTiles(int chunkX, int chunkY) {
        WorldData wd = loadedWorlds.get("serverWorld");
        if (wd == null) return null;

        String key = chunkX + "," + chunkY;
        if (!wd.getChunks().containsKey(key)) {
            try {
                var chunkData = jsonWorldDataService.loadChunk("serverWorld", chunkX, chunkY);
                if (chunkData != null) {
                    wd.getChunks().put(key, chunkData);
                    return chunkData.getTiles();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            return null;
        }
        return wd.getChunks().get(key).getTiles();
    }

    private void loadOrGenerateChunk(int chunkX, int chunkY) {
        String key = chunkX + "," + chunkY;
        // 1) Attempt to load from JSON
        try {
            ChunkData loaded = jsonWorldDataService.loadChunk(worldData.getWorldName(), chunkX, chunkY);
            if (loaded != null) {
                worldObjectManager.loadObjectsForChunk(chunkX, chunkY, loaded.getObjects());
                worldData.getChunks().put(key, loaded);
                return;
            }
        } catch (IOException e) {
            log.warn("Failed reading chunk from JSON: {}", e.getMessage());
        }

        // 2) Not found or no chunk file => generate
        int[][] tiles = worldGenerator.generateChunk(chunkX, chunkY);
        ChunkData cData = new ChunkData();
        cData.setChunkX(chunkX);
        cData.setChunkY(chunkY);

        cData.setTiles(tiles);

        Biome biome = worldGenerator.getBiomeForChunk(chunkX, chunkY);
        List<WorldObject> objs =
                worldObjectManager.generateObjectsForChunk(chunkX, chunkY, tiles, biome, worldData.getSeed());
        cData.setObjects(objs);

        worldData.getChunks().put(key, cData);

        // 3) Save newly generated chunk to JSON
        try {
            jsonWorldDataService.saveChunk(worldData.getWorldName(), cData);
        } catch (IOException e) {
            log.error("Failed to save newly generated chunk: {}", e.getMessage());
        }
    }

    @Override
    public boolean isChunkLoaded(Vector2 chunkPos) {
        String key = String.format("%d,%d", (int) chunkPos.x, (int) chunkPos.y);
        return worldData.getChunks().containsKey(key);
    }

    @Override
    public void loadChunk(Vector2 chunkPos) {
        loadOrGenerateChunk((int) chunkPos.x, (int) chunkPos.y);
    }

    @Override
    public List<WorldObject> getVisibleObjects(Rectangle viewBounds) {
        // Implementation unchanged, except no DB call
        List<WorldObject> visibleObjects = new ArrayList<>();
        Map<String, ChunkData> visibleChunks = getVisibleChunks(viewBounds);
        for (ChunkData chunk : visibleChunks.values()) {
            if (chunk.getObjects() != null) {
                visibleObjects.addAll(chunk.getObjects());
            }
        }
        return visibleObjects;
    }

    @Override
    public Map<String, ChunkData> getVisibleChunks(Rectangle viewBounds) {
        // Implementation is basically the same
        Map<String, ChunkData> visibleChunks = new HashMap<>();

        int startChunkX = (int) Math.floor(viewBounds.x / (CHUNK_SIZE * TILE_SIZE));
        int startChunkY = (int) Math.floor(viewBounds.y / (CHUNK_SIZE * TILE_SIZE));
        int endChunkX = (int) Math.ceil((viewBounds.x + viewBounds.width) / (CHUNK_SIZE * TILE_SIZE));
        int endChunkY = (int) Math.ceil((viewBounds.y + viewBounds.height) / (CHUNK_SIZE * TILE_SIZE));

        for (int x = startChunkX; x <= endChunkX; x++) {
            for (int y = startChunkY; y <= endChunkY; y++) {
                String key = x + "," + y;
                if (!worldData.getChunks().containsKey(key)) {
                    loadOrGenerateChunk(x, y);
                }
                ChunkData chunk = worldData.getChunks().get(key);
                if (chunk != null) {
                    visibleChunks.put(key, chunk);
                }
            }
        }

        return visibleChunks;
    }

    @Override
    public void setPlayerData(PlayerData pd) {
        WorldData wd = loadedWorlds.get("serverWorld");
        if (wd == null) return;
        wd.getPlayers().put(pd.getUsername(), pd);
        try {
            jsonWorldDataService.savePlayerData("serverWorld", pd);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }



    @Override
    public PlayerData getPlayerData(String username) {
        WorldData wd = loadedWorlds.get("serverWorld");
        if (wd == null) return null;
        PlayerData existing = wd.getPlayers().get(username);
        if (existing != null) return existing;
        try {
            PlayerData pd = jsonWorldDataService.loadPlayerData("serverWorld", username);
            if (pd != null) {
                wd.getPlayers().put(username, pd);
            }
            return pd;
        } catch (IOException e) {
            return null;
        }
    }


    @Override
    public List<String> getAvailableWorlds() {
        return jsonWorldDataService.listAllWorlds();
    }

    @Override
    public void deleteWorld(String worldName) {
        if (!jsonWorldDataService.worldExists(worldName)) {
            log.warn("World '{}' does not exist in JSON, cannot delete (server)", worldName);
            return;
        }

        jsonWorldDataService.deleteWorld(worldName);

        // If its the currently loaded world, clear it
        if (worldData.getWorldName() != null && worldData.getWorldName().equals(worldName)) {
            worldData.setWorldName(null);
            worldData.setSeed(0);
            worldData.getPlayers().clear();
            worldData.getChunks().clear();
            worldData.setCreatedDate(0);
            worldData.setLastPlayed(0);
            worldData.setPlayedTime(0);
            log.info("Cleared current loaded world data because it was deleted (server).");
        }
        log.info("Deleted world '{}' from JSON (server)", worldName);
    }

    @Override
    public void regenerateChunk(int chunkX, int chunkY) {
        String key = chunkX + "," + chunkY;
        worldData.getChunks().remove(key);
        // Also delete chunk JSON if present
        jsonWorldDataService.deleteChunk(worldData.getWorldName(), chunkX, chunkY);
        loadOrGenerateChunk(chunkX, chunkY);
    }

    @Override
    public void generateWorldThumbnail(String worldName) {
        log.info("Skipping world thumbnail generation on server.");
    }


    @Override
    public void loadOrReplaceChunkData(int chunkX, int chunkY, int[][] tiles, List<WorldObject> objects) {
        // Server should generate its own chunks, not accept them from clients
        log.warn("Client attempted to send chunk data to server - ignoring");

    }
    @Override
    public void updateWorldObjectState(WorldObjectUpdate update) {
        // Example: move or remove an object in the chunk
        WorldData wd = loadedWorlds.get("serverWorld");
        if (wd == null) return;
        String chunkKey = (update.getTileX() / 16) + "," + (update.getTileY() / 16);

        var chunkData = wd.getChunks().get(chunkKey);
        if (chunkData != null) {
            if (update.isRemoved()) {
                chunkData.getObjects().removeIf(o -> o.getId().equals(update.getObjectId()));
            } else {
                // Possibly find or create
                var existing = chunkData.getObjects().stream()
                        .filter(o -> o.getId().equals(update.getObjectId()))
                        .findFirst();
                if (existing.isPresent()) {
                    // update position
                    var wo = existing.get();
                    wo.setTileX(update.getTileX());
                    wo.setTileY(update.getTileY());
                } else {
                    // create new
                    WorldObject obj = new WorldObject(
                            update.getTileX(),
                            update.getTileY(),
                            // parse from update.getType()
                            ObjectType.valueOf(update.getType()),
                            true // or read from config
                    );
                    obj.setId(update.getObjectId());
                    chunkData.getObjects().add(obj);
                }
            }
        }
        // Optionally save chunk to disk
        try {
            jsonWorldDataService.saveChunk("serverWorld", chunkData);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @Override
    public OrthographicCamera getCamera() {
        return camera;
    }

    @Override
    public void setCamera(OrthographicCamera camera) {
        this.camera = camera;
    }
}

================
File: main/java/io.github.minemon/world/service/impl/WorldGeneratorImpl.java
================
package io.github.minemon.world.service.impl;

import io.github.minemon.utils.OpenSimplex2;
import io.github.minemon.world.biome.model.BiomeType;
import io.github.minemon.world.config.WorldConfig;
import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.service.WorldGenerator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.Random;

@Service
public class WorldGeneratorImpl implements WorldGenerator {
    private long seed;
    private Map<BiomeType, Biome> biomes;
    private final WorldConfig config;

    @Autowired
    public WorldGeneratorImpl(WorldConfig config) {
        this.config = config;
    }

    @Override
    public void setSeedAndBiomes(long seed, Map<BiomeType, Biome> biomes) {
        this.seed = seed;
        this.biomes = biomes;
    }

    @Override
    public Biome getBiomeForChunk(int chunkX, int chunkY) {
        if (biomes == null || biomes.isEmpty()) {
            return null;
        }

        float NOISE_SCALE = 0.005f;
        float n = OpenSimplex2.noise2(seed, chunkX * NOISE_SCALE, chunkY * NOISE_SCALE);
        BiomeType selectedBiome = n > 0 ? BiomeType.PLAINS : BiomeType.DESERT;
        return biomes.get(selectedBiome);
    }

    @Override
    public int[][] generateChunk(int chunkX, int chunkY) {
        // Optionally get the biome for the chunk
        Biome biome = getBiomeForChunk(chunkX, chunkY);
        int chunkSize = config.getChunkSize();

        int[][] tiles = new int[chunkSize][chunkSize];
        if (biome == null) {
            // Fallback if no biome found
            for (int x = 0; x < chunkSize; x++) {
                for (int y = 0; y < chunkSize; y++) {
                    tiles[x][y] = 1;
                }
            }
            return tiles;
        }

        Random chunkRandom = new Random(seed ^ (chunkX * 341_757L) ^ (chunkY * 132_721L));
        double total = biome.getTileDistribution().values().stream().mapToDouble(Double::doubleValue).sum();

        for (int x = 0; x < chunkSize; x++) {
            for (int y = 0; y < chunkSize; y++) {
                double roll = chunkRandom.nextDouble() * total;
                double cumulative = 0;
                for (Map.Entry<Integer, Double> entry : biome.getTileDistribution().entrySet()) {
                    cumulative += entry.getValue();
                    if (roll < cumulative) {
                        tiles[x][y] = entry.getKey();
                        break;
                    }
                }
            }
        }
        return tiles;
    }

}

================
File: main/java/io.github.minemon/world/service/impl/WorldObjectManagerImpl.java
================
package io.github.minemon.world.service.impl;

import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.model.ObjectType;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.world.service.WorldObjectManager;
import io.github.minemon.world.service.WorldService;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

@Service
@Slf4j
@Profile("client")
public class WorldObjectManagerImpl implements WorldObjectManager {

    private static final int CHUNK_SIZE = 16;
    private final boolean isServer;

    private final Map<String, List<WorldObject>> objectsByChunk = new ConcurrentHashMap<>();

    @Autowired
    @Lazy  // Add this to break the cycle
    private WorldService worldService;
    @Getter
    @Setter
    private boolean singlePlayer = true;

    public WorldObjectManagerImpl() {
        this.isServer = "server".equals(System.getProperty("spring.profiles.active"));
        log.info("WorldObjectManager initialized with isServer={}", isServer);
    }

    @Override
    public void initialize() {

        log.info("WorldObjectManagerImpl initialized. singlePlayer={}", singlePlayer);
    }

    @Override
    public void loadObjectsForChunk(int chunkX, int chunkY, List<WorldObject> objects) {
        if (!isServer && worldService.isMultiplayerMode()) {
            log.debug("Client skipping local object loading in multiplayer mode");
            return;
        }
        if (objects == null) {
            objects = Collections.emptyList();
        }
        String key = chunkX + "," + chunkY;
        objectsByChunk.put(key, objects);
        log.debug("Loaded {} objects for chunk {}", objects.size(), key);
    }

    @Override
    public List<WorldObject> generateObjectsForChunk(int chunkX, int chunkY, int[][] tiles, Biome biome, long seed) {

        List<WorldObject> objects = new CopyOnWriteArrayList<>();
        if (biome == null) {
            String key = chunkX + "," + chunkY;
            objectsByChunk.put(key, objects);
            return objects;
        }

        long combinedSeed = seed * 31 + chunkX * 341873128712L + chunkY * 132897987541L;
        Random random = new Random(combinedSeed);
        int chunkSize = tiles.length;

        for (String objName : biome.getSpawnableObjects()) {
            ObjectType type;
            try {
                type = ObjectType.valueOf(objName);
            } catch (Exception e) {
                log.warn("Unknown object type: '{}' in biome '{}'", objName, biome.getType());
                continue;
            }

            double chance = biome.getSpawnChanceForObject(type);
            int attempts = (int) (chance * (chunkSize * chunkSize));

            for (int i = 0; i < attempts; i++) {
                int lx = random.nextInt(chunkSize);
                int ly = random.nextInt(chunkSize);

                int tileType = tiles[lx][ly];
                if (!biome.getAllowedTileTypes().contains(tileType)) {
                    continue;
                }

                if (canPlaceObject(objects, chunkX, chunkY, lx, ly, type)) {
                    int worldX = chunkX * CHUNK_SIZE + lx;
                    int worldY = chunkY * CHUNK_SIZE + ly;

                    WorldObject obj = new WorldObject(worldX, worldY, type, type.isCollidable());
                    objects.add(obj);
                }
            }
        }

        String key = chunkX + "," + chunkY;
        objectsByChunk.put(key, objects);
        log.info("Generated {} objects for chunk {},{} using biome '{}'", objects.size(), chunkX, chunkY, biome.getType());
        return objects;
    }

    private boolean canPlaceObject(List<WorldObject> currentObjects, int chunkX, int chunkY, int lx, int ly, ObjectType newType) {
        int worldX = chunkX * CHUNK_SIZE + lx;
        int worldY = chunkY * CHUNK_SIZE + ly;

        int minDistance = 3;
        if (newType.name().contains("TREE")) {
            for (WorldObject obj : currentObjects) {
                if (obj.getType().name().contains("TREE")) {
                    int dx = obj.getTileX() - worldX;
                    int dy = obj.getTileY() - worldY;
                    if (dx * dx + dy * dy < minDistance * minDistance) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    @Override
    public List<WorldObject> getObjectsForChunk(int chunkX, int chunkY) {
        String key = chunkX + "," + chunkY;
        return objectsByChunk.getOrDefault(key, Collections.emptyList());
    }

    @Override
    public void addObject(WorldObject object) {
        int chunkX = object.getTileX() / CHUNK_SIZE;
        int chunkY = object.getTileY() / CHUNK_SIZE;
        String key = chunkX + "," + chunkY;
        objectsByChunk.computeIfAbsent(key, k -> new CopyOnWriteArrayList<>()).add(object);
        log.debug("Added object {} to chunk {}", object.getId(), key);
    }

    @Override
    public void removeObject(String objectId) {
        for (Map.Entry<String, List<WorldObject>> entry : objectsByChunk.entrySet()) {
            List<WorldObject> objs = entry.getValue();
            boolean removed = objs.removeIf(o -> o.getId().equals(objectId));
            if (removed) {
                log.debug("Removed object {} from chunk {}", objectId, entry.getKey());
                break;
            }
        }
    }
}

================
File: main/java/io.github.minemon/world/service/TileManager.java
================
package io.github.minemon.world.service;

import com.badlogic.gdx.graphics.g2d.TextureRegion;

public interface TileManager {
    void initIfNeeded();
    TextureRegion getRegionForTile(int tileId);
    boolean isPassable(int tileId);
    String getTileName(int tileId);
}

================
File: main/java/io.github.minemon/world/service/WorldGenerator.java
================
package io.github.minemon.world.service;

import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.biome.model.BiomeType;

public interface WorldGenerator {
    void setSeedAndBiomes(long seed, java.util.Map<BiomeType, Biome> biomes);
    int[][] generateChunk(int chunkX, int chunkY);
    Biome getBiomeForChunk(int chunkX, int chunkY);
}

================
File: main/java/io.github.minemon/world/service/WorldObjectManager.java
================
package io.github.minemon.world.service;

import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.model.WorldObject;

import java.util.List;

public interface WorldObjectManager {
    void initialize();
    List<WorldObject> generateObjectsForChunk(int chunkX, int chunkY, int[][] tiles, Biome biome, long seed);
    List<WorldObject> getObjectsForChunk(int chunkX, int chunkY);
    void addObject(WorldObject object);
    void removeObject(String objectId);
    void loadObjectsForChunk(int chunkX, int chunkY, List<WorldObject> objects);
}

================
File: main/java/io.github.minemon/world/service/WorldService.java
================
package io.github.minemon.world.service;

import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.minemon.multiplayer.model.WorldObjectUpdate;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.world.model.ChunkData;
import io.github.minemon.world.model.WorldData;
import io.github.minemon.world.model.WorldObject;

import java.util.List;
import java.util.Map;

public interface WorldService {
    void initIfNeeded();
    WorldData getWorldData();
    boolean isMultiplayerMode();
    void setMultiplayerMode(boolean multiplayer);
    void loadOrReplaceChunkData(int chunkX, int chunkY, int[][] tiles, List<WorldObject> objects);
    void updateWorldObjectState(WorldObjectUpdate update);
    TileManager getTileManager();
    boolean createWorld(String worldName, long seed);
    void loadWorld(String worldName);
    List<WorldObject> getVisibleObjects(Rectangle viewBounds);
    OrthographicCamera getCamera();
    boolean isChunkLoaded(Vector2 chunkPos);
    void loadChunk(Vector2 chunkPos);
    void setCamera(OrthographicCamera camera);
    Map<String, ChunkData> getVisibleChunks(Rectangle viewBounds);
    void saveWorldData();
    void loadWorldData();

    List<String> getAvailableWorlds();
    void deleteWorld(String worldName);


    void setPlayerData(PlayerData playerData);
    PlayerData getPlayerData(String username);


    int[][] getChunkTiles(int chunkX, int chunkY);
    void regenerateChunk(int chunkX, int chunkY);


    void generateWorldThumbnail(String worldName);
}
