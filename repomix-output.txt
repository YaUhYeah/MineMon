This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-04T01:58:16.914Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
main/java/io.github.minemon/audio/config/AudioConfig.java
main/java/io.github.minemon/audio/model/SoundEffect.java
main/java/io.github.minemon/audio/model/WeatherSoundEffect.java
main/java/io.github.minemon/audio/service/AudioService.java
main/java/io.github.minemon/audio/service/impl/AudioServiceImpl.java
main/java/io.github.minemon/chat/commands/Command.java
main/java/io.github.minemon/chat/commands/SetSpawnCommand.java
main/java/io.github.minemon/chat/commands/SpawnCommand.java
main/java/io.github.minemon/chat/config/ChatConfig.java
main/java/io.github.minemon/chat/event/ChatListener.java
main/java/io.github.minemon/chat/event/ChatMessageReceivedEvent.java
main/java/io.github.minemon/chat/model/ChatMessage.java
main/java/io.github.minemon/chat/service/ChatService.java
main/java/io.github.minemon/chat/service/CommandService.java
main/java/io.github.minemon/chat/service/impl/ChatServiceImpl.java
main/java/io.github.minemon/chat/service/impl/CommandServiceImpl.java
main/java/io.github.minemon/chat/ui/ChatTable.java
main/java/io.github.minemon/core/config/GameConfig.java
main/java/io.github.minemon/core/config/GameSettings.java
main/java/io.github.minemon/core/config/ScreenConfig.java
main/java/io.github.minemon/core/screen/GameScreen.java
main/java/io.github.minemon/core/screen/LoginScreen.java
main/java/io.github.minemon/core/screen/ModeSelectionScreen.java
main/java/io.github.minemon/core/screen/ServerDisconnectScreen.java
main/java/io.github.minemon/core/screen/ServerListView.java
main/java/io.github.minemon/core/screen/SettingsScreen.java
main/java/io.github.minemon/core/screen/WorldSelectionScreen.java
main/java/io.github.minemon/core/service/BackgroundService.java
main/java/io.github.minemon/core/service/FileAccessService.java
main/java/io.github.minemon/core/service/impl/LocalFileAccessService.java
main/java/io.github.minemon/core/service/impl/ScreenManagerImpl.java
main/java/io.github.minemon/core/service/impl/SpringFileAccessService.java
main/java/io.github.minemon/core/service/ScreenManager.java
main/java/io.github.minemon/core/service/SettingsService.java
main/java/io.github.minemon/core/service/UiService.java
main/java/io.github.minemon/core/ui/DialogCloseListener.java
main/java/io.github.minemon/core/ui/DialogFactory.java
main/java/io.github.minemon/core/ui/ServerConfigDialog.java
main/java/io.github.minemon/core/ui/StyleFactory.java
main/java/io.github.minemon/event/Event.java
main/java/io.github.minemon/event/EventBus.java
main/java/io.github.minemon/event/EventListener.java
main/java/io.github.minemon/input/InputConfiguration.java
main/java/io.github.minemon/input/InputService.java
main/java/io.github.minemon/multiplayer/model/ChunkUpdate.java
main/java/io.github.minemon/multiplayer/model/PlayerSyncData.java
main/java/io.github.minemon/multiplayer/model/ServerConnectionConfig.java
main/java/io.github.minemon/multiplayer/model/WorldObjectUpdate.java
main/java/io.github.minemon/multiplayer/service/impl/ClientConnectionManager.java
main/java/io.github.minemon/multiplayer/service/impl/MultiplayerClientImpl.java
main/java/io.github.minemon/multiplayer/service/impl/ServerConnectionServiceImpl.java
main/java/io.github.minemon/multiplayer/service/MultiplayerClient.java
main/java/io.github.minemon/multiplayer/service/ServerConnectionService.java
main/java/io.github.minemon/NetworkProtocol.java
main/java/io.github.minemon/player/config/PlayerConfig.java
main/java/io.github.minemon/player/config/PlayerProperties.java
main/java/io.github.minemon/player/event/PlayerJoinEvent.java
main/java/io.github.minemon/player/event/PlayerLeaveEvent.java
main/java/io.github.minemon/player/event/PlayerMoveEvent.java
main/java/io.github.minemon/player/model/PlayerData.java
main/java/io.github.minemon/player/model/PlayerDirection.java
main/java/io.github.minemon/player/model/PlayerModel.java
main/java/io.github.minemon/player/model/RemotePlayerAnimator.java
main/java/io.github.minemon/player/model/RemotePlayerModel.java
main/java/io.github.minemon/player/service/impl/PlayerAnimationServiceImpl.java
main/java/io.github.minemon/player/service/impl/PlayerServiceImpl.java
main/java/io.github.minemon/player/service/PlayerAnimationService.java
main/java/io.github.minemon/player/service/PlayerService.java
main/java/io.github.minemon/plugin/Plugin.java
main/java/io.github.minemon/plugin/PluginManager.java
main/java/io.github.minemon/utils/OpenSimplex2.java
main/java/io.github.minemon/utils/UUIDSerializer.java
main/java/io.github.minemon/weather/config/WeatherConfig.java
main/java/io.github.minemon/weather/model/WeatherType.java
main/java/io.github.minemon/weather/service/WeatherAudioService.java
main/java/io.github.minemon/world/biome/config/BiomeConfig.java
main/java/io.github.minemon/world/biome/config/BiomeConfigurationLoader.java
main/java/io.github.minemon/world/biome/model/Biome.java
main/java/io.github.minemon/world/biome/model/BiomeTransitionResult.java
main/java/io.github.minemon/world/biome/model/BiomeType.java
main/java/io.github.minemon/world/biome/service/BiomeService.java
main/java/io.github.minemon/world/biome/service/impl/BiomeServiceImpl.java
main/java/io.github.minemon/world/config/TileConfig.java
main/java/io.github.minemon/world/config/WorldConfig.java
main/java/io.github.minemon/world/config/WorldConfiguration.java
main/java/io.github.minemon/world/event/ChunkLoadEvent.java
main/java/io.github.minemon/world/event/WorldObjectRemoveEvent.java
main/java/io.github.minemon/world/event/WorldObjectSpawnEvent.java
main/java/io.github.minemon/world/model/ChunkData.java
main/java/io.github.minemon/world/model/ObjectRenderState.java
main/java/io.github.minemon/world/model/ObjectType.java
main/java/io.github.minemon/world/model/WorldData.java
main/java/io.github.minemon/world/model/WorldMetadata.java
main/java/io.github.minemon/world/model/WorldObject.java
main/java/io.github.minemon/world/model/WorldRenderer.java
main/java/io.github.minemon/world/service/ChunkLoaderService.java
main/java/io.github.minemon/world/service/ChunkLoadingManager.java
main/java/io.github.minemon/world/service/ChunkPreloaderService.java
main/java/io.github.minemon/world/service/impl/BaseWorldServiceImpl.java
main/java/io.github.minemon/world/service/impl/ChunkCacheManager.java
main/java/io.github.minemon/world/service/impl/ClientTileManagerImpl.java
main/java/io.github.minemon/world/service/impl/ClientWorldServiceImpl.java
main/java/io.github.minemon/world/service/impl/JsonWorldDataService.java
main/java/io.github.minemon/world/service/impl/ObjectTextureManager.java
main/java/io.github.minemon/world/service/impl/WorldGeneratorImpl.java
main/java/io.github.minemon/world/service/impl/WorldObjectManagerImpl.java
main/java/io.github.minemon/world/service/TileManager.java
main/java/io.github.minemon/world/service/WorldGenerator.java
main/java/io.github.minemon/world/service/WorldObjectManager.java
main/java/io.github.minemon/world/service/WorldService.java
main/java/io.github.minemon/world/SpawnPoint.java
main/java/io.github.minemon/world/SpawnService.java

================================================================
Files
================================================================

================
File: main/java/io.github.minemon/audio/config/AudioConfig.java
================
package io.github.minemon.audio.config;

import io.github.minemon.audio.service.AudioService;
import io.github.minemon.audio.service.impl.AudioServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AudioConfig {

    @Bean
    public AudioService audioService() {
        return new AudioServiceImpl();
    }
}

================
File: main/java/io.github.minemon/audio/model/SoundEffect.java
================
package io.github.minemon.audio.model;

import lombok.Getter;

@Getter
public enum SoundEffect {
    ITEM_PICKUP("sounds/pickup.ogg"),
    MENU_SELECT("sounds/select.ogg"),
    MENU_BACK("sounds/back.ogg"),
    BATTLE_WIN("sounds/battle_win.ogg"),
    CRITICAL_HIT("sounds/critical_hit.ogg"),
    CURSOR_MOVE("sounds/cursor_move.ogg"),
    DAMAGE("sounds/damage.ogg"),
    COLLIDE("sounds/player-bump.ogg"),
    MOVE_SELECT("sounds/move_select.ogg"),
    NOT_EFFECTIVE("sounds/not_effective.ogg"),
    SUPER_EFFECTIVE("sounds/super_effective.ogg"),
    CRAFT("sounds/crafting.ogg"),
    BLOCK_PLACE_0("sounds/block_place_0.ogg"),
    BLOCK_PLACE_1("sounds/block_place_1.ogg"),
    BLOCK_PLACE_2("sounds/block_place_2.ogg"),
    BLOCK_BREAK_WOOD("sounds/break_wood.ogg"),
    TOOL_BREAK("sounds/tool_break.ogg"),
    BLOCK_BREAK_WOOD_HAND("sounds/break_wood_hand.ogg"),
    PUDDLE("sounds/puddle.ogg"),
    CHEST_OPEN("sounds/chest-open.ogg"),
    CHEST_CLOSE("sounds/chest-close.ogg"),
    HOUSE_BUILD("sounds/house_build.ogg");

    private final String path;

    SoundEffect(String path) {
        this.path = path;
    }

}

================
File: main/java/io.github.minemon/audio/model/WeatherSoundEffect.java
================
package io.github.minemon.audio.model;

import lombok.Getter;

@Getter
public enum WeatherSoundEffect {
    LIGHT_RAIN("sounds/weather/rain.ogg"),
    THUNDER("sounds/weather/thunder.ogg"),
    WIND("sounds/weather/wind.ogg"),
    SAND_WIND("sounds/weather/sandwind.ogg");

    private final String path;

    WeatherSoundEffect(String path) {
        this.path = path;
    }

}

================
File: main/java/io.github.minemon/audio/service/AudioService.java
================
package io.github.minemon.audio.service;

import io.github.minemon.audio.model.SoundEffect;
import io.github.minemon.audio.model.WeatherSoundEffect;

public interface AudioService {

    void initAudio();

    void playMenuMusic();
    void stopMenuMusic();
    void fadeOutMenuMusic();
    void update(float delta);

    void playSound(SoundEffect effect);


    
    void playWeatherSound(WeatherSoundEffect effect, float volume, float pitch);

    
    void updateWeatherLoop(WeatherSoundEffect effect, float volume);

    
    void stopWeatherLoop(WeatherSoundEffect effect);

    float getMusicVolume();
    void setMusicVolume(float musicVolume);
    float getSoundVolume();
    void setSoundVolume(float soundVolume);
    boolean isMusicEnabled();
    void setMusicEnabled(boolean musicEnabled);
    boolean isSoundEnabled();
    void setSoundEnabled(boolean soundEnabled);

    void dispose();
}

================
File: main/java/io.github.minemon/audio/service/impl/AudioServiceImpl.java
================
package io.github.minemon.audio.service.impl;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.math.MathUtils;
import io.github.minemon.audio.model.SoundEffect;
import io.github.minemon.audio.model.WeatherSoundEffect;
import io.github.minemon.audio.service.AudioService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
@Primary
public class AudioServiceImpl implements AudioService {
    private static final Logger logger = LoggerFactory.getLogger(AudioServiceImpl.class);

    private final Map<SoundEffect, Sound> sounds = new EnumMap<>(SoundEffect.class);

    private final Map<WeatherSoundEffect, Music> weatherLoops = new EnumMap<>(WeatherSoundEffect.class);
    private final Map<WeatherSoundEffect, Sound> weatherSounds = new EnumMap<>(WeatherSoundEffect.class);

    private List<Music> menuMusicList;
    private Music currentMusic;

    private final float masterVolume = 1.0f;
    private float musicVolume = 0.7f;
    private float soundVolume = 1.0f;
    private boolean musicEnabled = true;
    private boolean soundEnabled = true;

    private static final float MUSIC_FADE_DURATION = 2.0f;
    private static final float FADE_OUT_DURATION = 2f;

    private boolean isFadingOutMusic = false;
    private float fadeOutMusicTimer = 0f;
    private boolean isFadingInMusic = false;
    private float fadeInMusicTimer = 0f;

    public AudioServiceImpl() {
    }

    @Override
    public void initAudio() {
        initializeAudio();
    }

    private void initializeAudio() {

        for (SoundEffect effect : SoundEffect.values()) {
            try {
                Sound sound = Gdx.audio.newSound(Gdx.files.internal("" + effect.getPath()));
                sounds.put(effect, sound);
            } catch (Exception e) {
                logger.error("Failed to load sound: {}", effect.getPath(), e);
            }
        }




        for (WeatherSoundEffect wEffect : WeatherSoundEffect.values()) {
            String path = wEffect.getPath();
            if (wEffect == WeatherSoundEffect.THUNDER) {

                try {
                    Sound wSound = Gdx.audio.newSound(Gdx.files.internal(path));
                    weatherSounds.put(wEffect, wSound);
                } catch (Exception e) {
                    logger.error("Failed to load weather sound: {}", path, e);
                }
            } else {

                try {
                    Music wMusic = Gdx.audio.newMusic(Gdx.files.internal(path));
                    wMusic.setLooping(true);
                    wMusic.setVolume(0f);
                    weatherLoops.put(wEffect, wMusic);
                } catch (Exception e) {
                    logger.error("Failed to load weather loop: {}", path, e);
                }
            }
        }

        menuMusicList = new ArrayList<>();
        loadMenuMusic(Arrays.asList(
                "music/Menu-Music-1.mp3",
                "music/Menu-Music-2.mp3",
                "music/Menu-Music-0.mp3",
                "music/Menu-Music-3.mp3",
                "music/Menu-Music-4.mp3"
        ));
    }

    private void loadMenuMusic(List<String> paths) {
        for (String path : paths) {
            try {
                Music music = Gdx.audio.newMusic(Gdx.files.internal( path));
                music.setVolume(musicVolume * masterVolume);
                menuMusicList.add(music);
            } catch (Exception e) {
                logger.error("Failed to load menu music: {}", path, e);
            }
        }
    }

    @Override
    public void playMenuMusic() {
        if (!musicEnabled || menuMusicList == null || menuMusicList.isEmpty()) {
            return;
        }

        if (currentMusic == null || !currentMusic.isPlaying()) {
            stopCurrentMusic();
            int index = MathUtils.random(menuMusicList.size() - 1);
            currentMusic = menuMusicList.get(index);
            currentMusic.setVolume(0f);
            currentMusic.setLooping(false);
            currentMusic.play();
            isFadingInMusic = true;
            fadeInMusicTimer = MUSIC_FADE_DURATION;
            setMusicCompletionListenerForMenu();
        }
    }

    private void setMusicCompletionListenerForMenu() {
        if (currentMusic != null) {
            currentMusic.setOnCompletionListener(music -> playMenuMusic());
        }
    }

    @Override
    public void stopMenuMusic() {
        if (currentMusic != null && currentMusic.isPlaying()) {
            isFadingOutMusic = true;
            fadeOutMusicTimer = MUSIC_FADE_DURATION;
        }
    }

    @Override
    public void fadeOutMenuMusic() {
        if (currentMusic != null && currentMusic.isPlaying()) {
            isFadingOutMusic = true;
            fadeOutMusicTimer = FADE_OUT_DURATION;
        }
    }

    @Override
    public void update(float delta) {
        if (isFadingInMusic && currentMusic != null) {
            fadeInMusicTimer -= delta;
            float progress = 1 - Math.max(0, fadeInMusicTimer / MUSIC_FADE_DURATION);
            float volume = progress * musicVolume * masterVolume;
            currentMusic.setVolume(volume);

            if (fadeInMusicTimer <= 0) {
                isFadingInMusic = false;
                currentMusic.setVolume(musicVolume * masterVolume);
            }
        }

        if (isFadingOutMusic && currentMusic != null) {
            fadeOutMusicTimer -= delta;
            float volume = Math.max(0, (fadeOutMusicTimer / MUSIC_FADE_DURATION) * musicVolume * masterVolume);
            currentMusic.setVolume(volume);

            if (fadeOutMusicTimer <= 0) {
                currentMusic.stop();
                isFadingOutMusic = false;
                currentMusic = null;
            }
        }
    }

    @Override
    public void playSound(SoundEffect effect) {
        if (!soundEnabled) return;
        Sound sound = sounds.get(effect);
        if (sound != null) {
            sound.play(soundVolume * masterVolume);
        }
    }

    @Override
    public void playWeatherSound(WeatherSoundEffect effect, float volume, float pitch) {
        if (!soundEnabled) return;

        Sound wSound = weatherSounds.get(effect);
        if (wSound != null) {
            long id = wSound.play(volume * soundVolume * masterVolume);
            wSound.setPitch(id, pitch);
        } else {
            logger.debug("Weather sound {} not found or not loaded as Sound.", effect);
        }
    }

    @Override
    public void updateWeatherLoop(WeatherSoundEffect effect, float volume) {
        if (!soundEnabled) return;

        Music loop = weatherLoops.get(effect);
        if (loop != null) {
            if (!loop.isPlaying()) {
                loop.play();
            }
            float finalVolume = volume * soundVolume * masterVolume;
            loop.setVolume(finalVolume);

            if (finalVolume <= 0.01f) {
                loop.pause();
            }
        } else {
            logger.debug("Weather loop {} not found or not loaded as Music.", effect);
        }
    }

    @Override
    public void stopWeatherLoop(WeatherSoundEffect effect) {
        Music loop = weatherLoops.get(effect);
        if (loop != null && loop.isPlaying()) {
            loop.stop();
        }
    }

    @Override
    public float getMusicVolume() {
        return musicVolume;
    }

    @Override
    public void setMusicVolume(float musicVolume) {
        this.musicVolume = musicVolume;
        if (currentMusic != null) {
            currentMusic.setVolume(musicVolume * masterVolume);
        }
    }

    @Override
    public float getSoundVolume() {
        return soundVolume;
    }

    @Override
    public void setSoundVolume(float soundVolume) {
        this.soundVolume = soundVolume;

        for (Music loop : weatherLoops.values()) {
            if (loop.isPlaying()) {



                float currentVol = loop.getVolume() / (masterVolume);
                loop.setVolume(currentVol * soundVolume);
            }
        }
    }

    @Override
    public boolean isMusicEnabled() {
        return musicEnabled;
    }

    @Override
    public void setMusicEnabled(boolean musicEnabled) {
        this.musicEnabled = musicEnabled;
        if (currentMusic != null) {
            if (musicEnabled) {
                if (!currentMusic.isPlaying()) {
                    currentMusic.play();
                }
                currentMusic.setVolume(musicVolume * masterVolume);
            } else {
                currentMusic.pause();
            }
        }
    }

    @Override
    public boolean isSoundEnabled() {
        return soundEnabled;
    }

    @Override
    public void setSoundEnabled(boolean soundEnabled) {
        this.soundEnabled = soundEnabled;

        if (!soundEnabled) {
            for (Music loop : weatherLoops.values()) {
                if (loop.isPlaying()) {
                    loop.pause();
                }
            }
        } else {


        }
    }

    private void stopCurrentMusic() {
        if (currentMusic != null) {
            currentMusic.stop();
            currentMusic = null;
        }
    }

    @Override
    public void dispose() {
        for (Sound sound : sounds.values()) {
            sound.dispose();
        }
        sounds.clear();

        if (currentMusic != null) {
            currentMusic.stop();
            currentMusic.dispose();
            currentMusic = null;
        }

        if (menuMusicList != null) {
            for (Music music : menuMusicList) {
                music.dispose();
            }
            menuMusicList.clear();
        }


        for (Sound wSound : weatherSounds.values()) {
            wSound.dispose();
        }
        weatherSounds.clear();

        for (Music loop : weatherLoops.values()) {
            loop.dispose();
        }
        weatherLoops.clear();
    }
}

================
File: main/java/io.github.minemon/chat/commands/Command.java
================
package io.github.minemon.chat.commands;

import io.github.minemon.chat.service.ChatService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.service.PlayerService;

public interface Command {
    String getName();
    String[] getAliases();
    String getDescription();
    String getUsage();
    boolean isMultiplayerOnly();

    
    void execute(String args, PlayerService playerService, ChatService chatService, MultiplayerClient multiplayerClient);
}

================
File: main/java/io.github.minemon/chat/commands/SetSpawnCommand.java
================
package io.github.minemon.chat.commands;

import io.github.minemon.chat.service.ChatService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.world.SpawnService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Slf4j
@Component
public class SetSpawnCommand implements Command {

    @Autowired
    private SpawnService spawnService;

    @Override
    public String getName() {
        return "setspawn";
    }

    @Override
    public String[] getAliases() {
        return new String[0];
    }

    @Override
    public String getDescription() {
        return "Sets spawn point to current location or specified coordinates";
    }

    @Override
    public String getUsage() {
        return "/setspawn [x] [y]";
    }

    @Override
    public boolean isMultiplayerOnly() {
        return false;
    }

    @Override
    public void execute(String args, PlayerService playerService,
                        ChatService chatService, MultiplayerClient multiplayerClient) {

        float x, y;

        if (args == null || args.trim().isEmpty()) {
            // Use current position
            PlayerData player = playerService.getPlayerData();
            if (player == null) {
                chatService.addSystemMessage("Error: Player not found");
                return;
            }
            x = player.getX();
            y = player.getY();
        } else {
            // Parse coordinates
            String[] parts = args.trim().split("\\s+");
            if (parts.length != 2) {
                chatService.addSystemMessage("Usage: " + getUsage());
                return;
            }

            try {
                x = Float.parseFloat(parts[0]);
                y = Float.parseFloat(parts[1]);
            } catch (NumberFormatException e) {
                chatService.addSystemMessage("Invalid coordinates. Use numbers only.");
                return;
            }
        }

        // Update spawn point
        spawnService.setSpawn(x, y);

        // Notify player
        String message = String.format("Spawn point set to (%.1f, %.1f)", x, y);
        chatService.addSystemMessage(message);

        // In multiplayer, notify server (if you want to implement server-side spawn points)
        if (multiplayerClient.isConnected()) {
            // You could add a custom network message for this
            log.debug("Spawn point updated in multiplayer mode");
        }
    }
}

================
File: main/java/io.github.minemon/chat/commands/SpawnCommand.java
================
package io.github.minemon.chat.commands;

import io.github.minemon.chat.service.ChatService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.world.service.ChunkLoadingManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Slf4j
@Component
public class SpawnCommand implements Command {
    private static final float SPAWN_X = 0f;
    private static final float SPAWN_Y = 0f;
    private static final long CHUNK_LOAD_TIMEOUT = 2000; // 2 seconds max wait

    @Override
    public String getName() { return "spawn"; }

    @Override
    public String[] getAliases() { return new String[0]; }

    @Override
    public String getDescription() { return "Teleports player to spawn point"; }

    @Override
    public String getUsage() { return "/spawn"; }

    @Override
    public boolean isMultiplayerOnly() { return false; }

    @Autowired
    private ChunkLoadingManager chunkLoadingManager;

    @Override
    public void execute(String args, PlayerService playerService,
                        ChatService chatService, MultiplayerClient multiplayerClient) {

        PlayerData player = playerService.getPlayerData();
        if (player == null) {
            chatService.addSystemMessage("Error: Player not found");
            return;
        }

        chatService.addSystemMessage("Preparing spawn area...");

        // Start preloading chunks
        chunkLoadingManager.preloadChunksAroundPosition(SPAWN_X, SPAWN_Y);

        // Give chunks a moment to start loading
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        // Set position
        player.setX(SPAWN_X);
        player.setY(SPAWN_Y);
        playerService.setPosition(0, 0);

        // Sync with server if needed
        if (multiplayerClient.isConnected()) {
            multiplayerClient.sendPlayerMove(
                player.getX(),
                player.getY(),
                player.isWantsToRun(),
                false,
                player.getDirection().name().toLowerCase()
            );
        }

        chatService.addSystemMessage("Teleported to spawn point!");
    }
}

================
File: main/java/io.github.minemon/chat/config/ChatConfig.java
================
package io.github.minemon.chat.config;

import io.github.minemon.chat.commands.SetSpawnCommand;
import io.github.minemon.chat.commands.SpawnCommand;
import io.github.minemon.chat.service.CommandService;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ChatConfig {

    @Autowired
    private CommandService commandService;

    @Autowired
    private SpawnCommand spawnCommand;

    @Autowired
    private SetSpawnCommand setSpawnCommand;

    @PostConstruct
    public void registerCommands() {
        commandService.registerCommand(spawnCommand);
        commandService.registerCommand(setSpawnCommand);
    }
}

================
File: main/java/io.github.minemon/chat/event/ChatListener.java
================
package io.github.minemon.chat.event;

import io.github.minemon.chat.model.ChatMessage;

public interface ChatListener {
    void onNewMessage(ChatMessage msg);
}

================
File: main/java/io.github.minemon/chat/event/ChatMessageReceivedEvent.java
================
package io.github.minemon.chat.event;

import io.github.minemon.chat.model.ChatMessage;
import lombok.Getter;
import org.springframework.context.ApplicationEvent;

@Getter
public class ChatMessageReceivedEvent extends ApplicationEvent {
    private final ChatMessage chatMessage;

    public ChatMessageReceivedEvent(Object source, ChatMessage chatMessage) {
        super(source);
        this.chatMessage = chatMessage;
    }

}

================
File: main/java/io.github.minemon/chat/model/ChatMessage.java
================
package io.github.minemon.chat.model;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class ChatMessage {
    private String sender;
    private String content;
    private long timestamp;
    private Type type;
    public enum Type {
        NORMAL, SYSTEM
    }
}

================
File: main/java/io.github.minemon/chat/service/ChatService.java
================
package io.github.minemon.chat.service;

import io.github.minemon.chat.model.ChatMessage;
import io.github.minemon.chat.event.ChatListener;

import java.util.List;
import java.util.Queue;

public interface ChatService {
    void sendMessage(String content);
    void addSystemMessage(String message);
    void handleIncomingMessage(ChatMessage message);
    void activateChat();
    void deactivateChat();
    boolean isActive();
    List<ChatMessage> pollMessages();
    Queue<ChatMessage> getMessages();

    String getPreviousHistoryMessage(String currentText);
    String getNextHistoryMessage();

    // **Add the following methods**
    void addListener(ChatListener listener);
    void removeListener(ChatListener listener);
}

================
File: main/java/io.github.minemon/chat/service/CommandService.java
================
package io.github.minemon.chat.service;

import io.github.minemon.chat.commands.Command;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.service.PlayerService;

public interface CommandService {
    void registerCommand(Command command);
    boolean executeCommand(String name, String args, PlayerService playerService, ChatService chatService, MultiplayerClient multiplayerClient);
}

================
File: main/java/io.github.minemon/chat/service/impl/ChatServiceImpl.java
================
package io.github.minemon.chat.service.impl;

import io.github.minemon.chat.event.ChatListener;
import io.github.minemon.chat.event.ChatMessageReceivedEvent;
import io.github.minemon.chat.model.ChatMessage;
import io.github.minemon.chat.service.ChatService;
import io.github.minemon.chat.service.CommandService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.service.PlayerService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;

@Service
@Slf4j
public class ChatServiceImpl implements ChatService {

    private final PlayerService playerService;
    @Autowired
    @Lazy
    private MultiplayerClient multiplayerClient;
    private final CommandService commandService;
    private final ConcurrentLinkedQueue<ChatMessage> messages = new ConcurrentLinkedQueue<>();
    private final List<String> messageHistory = new ArrayList<>();
    private boolean isActive;
    private int messageHistoryIndex = -1;
    private String currentInputBeforeHistory = "";

    private final List<ChatListener> listeners = new CopyOnWriteArrayList<>();

    @Autowired
    public ChatServiceImpl(PlayerService playerService, MultiplayerClient multiplayerClient, CommandService commandService) {
        this.playerService = playerService;
        this.multiplayerClient = multiplayerClient;
        this.commandService = commandService;
    }

    @EventListener 
    public void onChatMessageReceived(ChatMessageReceivedEvent event) {
        ChatMessage chatMessage = event.getChatMessage();
        handleIncomingMessage(chatMessage);
    }

    @Override
    public List<ChatMessage> pollMessages() {
        List<ChatMessage> newMessages = new ArrayList<>();
        ChatMessage msg;
        while ((msg = messages.poll()) != null) {
            newMessages.add(msg);
        }
        return newMessages;
    }

    @Override
    public void sendMessage(String content) {
        if (content.isEmpty()) return;

        if (messageHistory.isEmpty() || !content.equals(messageHistory.get(messageHistory.size() - 1))) {
            messageHistory.add(content);
            messageHistoryIndex = messageHistory.size();
        }

        boolean isMultiplayer = multiplayerClient.isConnected();

        if (content.startsWith("/")) {
            String[] parts = content.substring(1).split(" ", 2);
            String commandName = parts[0].toLowerCase();
            String args = (parts.length > 1) ? parts[1] : "";
            if (!commandService.executeCommand(commandName, args, playerService, this, multiplayerClient)) {
                addSystemMessage("Unknown command: " + commandName);
            }
            return;
        }

        String username = playerService.getPlayerData().getUsername();
        if (username == null || username.isEmpty()) {
            username = "Player";
        }

        ChatMessage msg = new ChatMessage(username, content, System.currentTimeMillis(), ChatMessage.Type.NORMAL);
        handleIncomingMessage(msg);

        if (isMultiplayer) {
            multiplayerClient.sendMessage(msg);
        }
    }

    @Override
    public void addSystemMessage(String message) {
        ChatMessage sysMsg = new ChatMessage("System", message, System.currentTimeMillis(), ChatMessage.Type.SYSTEM);
        handleIncomingMessage(sysMsg);
    }

    @Override
    public void handleIncomingMessage(ChatMessage message) {
        messages.add(message);
        log.info("Received chat message from: {} content: {}", message.getSender(), message.getContent());

        for (ChatListener listener : listeners) {
            listener.onNewMessage(message);
        }
    }

    @Override
    public void activateChat() {
        isActive = true;
        messageHistoryIndex = messageHistory.size();
        currentInputBeforeHistory = "";
    }

    @Override
    public void deactivateChat() {
        isActive = false;
        messageHistoryIndex = messageHistory.size();
        currentInputBeforeHistory = "";
    }

    @Override
    public boolean isActive() {
        return isActive;
    }

    @Override
    public Queue<ChatMessage> getMessages() {
        return messages;
    }

    @Override
    public String getPreviousHistoryMessage(String currentText) {
        if (messageHistoryIndex == messageHistory.size()) {
            currentInputBeforeHistory = currentText;
        }

        if (messageHistory.isEmpty()) {
            return currentText;
        }

        if (messageHistoryIndex > 0) {
            messageHistoryIndex--;
            return messageHistory.get(messageHistoryIndex);
        } else {
            return messageHistory.get(0);
        }
    }

    @Override
    public String getNextHistoryMessage() {
        if (messageHistory.isEmpty()) {
            return "";
        }

        if (messageHistoryIndex < messageHistory.size()) {
            messageHistoryIndex++;
        }

        if (messageHistoryIndex == messageHistory.size()) {
            return currentInputBeforeHistory;
        } else {
            return messageHistory.get(messageHistoryIndex);
        }
    }
    public void addListener(ChatListener listener) {
        listeners.add(listener);
    }


    public void removeListener(ChatListener listener) {
        listeners.remove(listener);
    }
}

================
File: main/java/io.github.minemon/chat/service/impl/CommandServiceImpl.java
================
package io.github.minemon.chat.service.impl;

import io.github.minemon.chat.commands.Command;
import io.github.minemon.chat.service.ChatService;
import io.github.minemon.chat.service.CommandService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.service.PlayerService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;

@Service
@Slf4j
public class CommandServiceImpl implements CommandService {
    private final Map<String, Command> commands = new HashMap<>();

    @Override
    public void registerCommand(Command command) {
        commands.put(command.getName().toLowerCase(), command);
        for (String alias : command.getAliases()) {
            commands.put(alias.toLowerCase(), command);
        }
        log.info("Registered command: {}", command.getName());
    }

    @Override
    public boolean executeCommand(String name, String args, PlayerService playerService, ChatService chatService, MultiplayerClient multiplayerClient) {
        Command cmd = commands.get(name.toLowerCase());
        if (cmd == null) {
            return false;
        }
        try {
            if (cmd.isMultiplayerOnly() && !multiplayerClient.isConnected()) {
                chatService.addSystemMessage("This command can only be used in multiplayer.");
                return true;
            }
            cmd.execute(args, playerService, chatService, multiplayerClient);
            return true;
        } catch (Exception e) {
            log.error("Command execution failed: {}", e.getMessage(), e);
            chatService.addSystemMessage("Error executing command: " + e.getMessage());
            return true;
        }
    }
}

================
File: main/java/io.github.minemon/chat/ui/ChatTable.java
================
package io.github.minemon.chat.ui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import io.github.minemon.chat.event.ChatListener;
import io.github.minemon.chat.model.ChatMessage;
import io.github.minemon.chat.service.ChatService;
import lombok.Getter;

public class ChatTable extends Table implements ChatListener {

    private final ChatService chatService;
    private final Skin skin;
    private final ScrollPane messageScroll;
    private final Table messageTable;
    private final TextField inputField;

    @Getter
    private boolean active;

    public ChatTable(Skin skin, ChatService chatService) {
        super(skin);
        this.skin = skin;
        this.chatService = chatService;
        this.chatService.addListener(this);

        setFillParent(false);
        pad(10);

        messageTable = new Table(skin);
        messageTable.top().left();
        messageScroll = new ScrollPane(messageTable, skin);
        messageScroll.setFadeScrollBars(false);
        messageScroll.setScrollingDisabled(true, false);

        TextField.TextFieldStyle textFieldStyle = new TextField.TextFieldStyle(skin.get(TextField.TextFieldStyle.class));
        inputField = new TextField("", textFieldStyle);
        inputField.setMessageText("Press T to chat...");
        inputField.setFocusTraversal(false);

        inputField.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if (!active) return false;
                if (keycode == Input.Keys.ENTER) {
                    String content = inputField.getText().trim();
                    if (!content.isEmpty()) {
                        chatService.sendMessage(content);
                        inputField.setText("");
                    }
                    deactivate();
                    return true;
                } else if (keycode == Input.Keys.ESCAPE) {
                    deactivate();
                    return true;
                } else if (keycode == Input.Keys.UP) {
                    String previousMessage = chatService.getPreviousHistoryMessage(inputField.getText());
                    inputField.setText(previousMessage);
                    inputField.setCursorPosition(previousMessage.length());
                    return true;
                } else if (keycode == Input.Keys.DOWN) {
                    String nextMessage = chatService.getNextHistoryMessage();
                    inputField.setText(nextMessage);
                    inputField.setCursorPosition(nextMessage.length());
                    return true;
                }
                return false;
            }
        });

        row().expand().fill().padBottom(5);
        add(messageScroll).expand().fill().row();

        add(inputField).expandX().fillX().height(30);

        // Initial call to ensure existing messages are displayed
        updateMessages();
    }

    @Override
    public void onNewMessage(ChatMessage msg) {
        Gdx.app.postRunnable(() -> addMessage(msg));
    }

    private void addMessage(ChatMessage msg) {
        Label nameLabel = new Label(msg.getSender() + ": ", skin);
        Label contentLabel = new Label(msg.getContent(), skin);
        contentLabel.setWrap(true);

        Table msgTable = new Table(skin);
        msgTable.left().top();
        msgTable.add(nameLabel).padRight(5);
        msgTable.add(contentLabel).expandX().fillX();

        messageTable.add(msgTable).expandX().fillX().padBottom(2).row();

        // Delay the scroll to ensure the layout is updated
        Gdx.app.postRunnable(() -> {
            messageTable.layout();
            messageScroll.layout();
            messageScroll.scrollTo(0, 0, 0, 0);
        });
    }

    public void activate() {
        active = true;
        chatService.activateChat();
        inputField.setVisible(true);

        Gdx.app.postRunnable(() -> {
            Stage stage = getStage();
            if (stage != null) {
                stage.setKeyboardFocus(inputField);
            }
        });
    }

    public void deactivate() {
        active = false;
        chatService.deactivateChat();
        inputField.setText("");
        Stage stage = getStage();
        if (stage != null) {
            stage.unfocus(inputField);
        }
    }

    public void updateMessages() {
        Gdx.app.postRunnable(() -> {
            messageTable.layout();
            messageScroll.layout();
            messageScroll.scrollTo(0, 0, 0, 0);
        });
    }

    @Override
    public void layout() {
        super.layout();
        // Ensure scroll is at bottom after layout changes
        messageScroll.scrollTo(0, 0, 0, 0);
    }
}

================
File: main/java/io.github.minemon/core/config/GameConfig.java
================
package io.github.minemon.core.config;

import jakarta.annotation.PostConstruct;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import java.util.ArrayList;
import java.util.List;

@Data
@Configuration
@Primary
@ConfigurationProperties(prefix = "game")
public class GameConfig {
    private List<String> motds;

    @PostConstruct
    public void init() {
        if (motds == null) {
            motds = new ArrayList<>();
            motds.add("Welcome to MineMon - Catch them all in an open world!");
            motds.add("Explore, battle, and collect in a vast world!");
            motds.add("New updates coming soon!");
            motds.add("Can you catch them all?");
            motds.add("Adventure awaits in the world of MineMon!");
            motds.add("Become the ultimate trainer!");
            motds.add("Build, battle, explore!");
        }
    }

    public String getRandomMotd() {
        if (motds == null || motds.isEmpty()) {
            init();
        }
        return motds.get((int) (Math.random() * motds.size()));
    }
}

================
File: main/java/io.github.minemon/core/config/GameSettings.java
================
package io.github.minemon.core.config;

import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
public class GameSettings {
    private float musicVolume = 0.7f;
    private float soundVolume = 1.0f;
    private boolean vSync = true;
    private int renderDistance = 8;
    private boolean particles = true;
    private boolean smoothLighting = true;
}

================
File: main/java/io.github.minemon/core/config/ScreenConfig.java
================
package io.github.minemon.core.config;

import com.badlogic.gdx.Game;
import io.github.minemon.core.service.*;
import io.github.minemon.core.service.impl.ScreenManagerImpl;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ScreenConfig {

    @Bean
    public ScreenManager screenManager(ApplicationContext applicationContext, Game game) {
        return new ScreenManagerImpl(applicationContext, game);
    }



}

================
File: main/java/io.github.minemon/core/screen/GameScreen.java
================
package io.github.minemon.core.screen;

import com.badlogic.gdx.*;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.*;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.minemon.audio.service.AudioService;
import io.github.minemon.chat.service.ChatService;
import io.github.minemon.chat.ui.ChatTable;
import io.github.minemon.core.service.ScreenManager;
import io.github.minemon.input.InputService;
import io.github.minemon.multiplayer.model.PlayerSyncData;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.multiplayer.service.impl.ClientConnectionManager;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.model.PlayerDirection;
import io.github.minemon.player.model.RemotePlayerAnimator;
import io.github.minemon.player.service.PlayerAnimationService;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.world.biome.service.BiomeService;
import io.github.minemon.world.model.WorldRenderer;
import io.github.minemon.world.service.ChunkLoaderService;
import io.github.minemon.world.service.ChunkLoadingManager;
import io.github.minemon.world.service.ChunkPreloaderService;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Component
@Slf4j
public class GameScreen implements Screen {
    private static final int CHUNK_SIZE = 16;
    private final float TARGET_VIEWPORT_WIDTH_TILES = 24f;
    private final int TILE_SIZE = 32;
    private final PlayerService playerService;
    private final WorldService worldService;
    private final AudioService audioService;
    private final InputService inputService;
    private final ChatService chatService;
    private final BiomeService biomeService;
    private final WorldRenderer worldRenderer;
    private final ChunkLoaderService chunkLoaderService;
    private final ScreenManager screenManager;
    private final MultiplayerClient multiplayerClient;
    private final PlayerAnimationService animationService;
    private final Map<String, RemotePlayerAnimator> remotePlayerAnimators = new ConcurrentHashMap<>();
    private boolean handlingDisconnect = false;
    private OrthographicCamera camera;
    private SpriteBatch batch;
    @Autowired
    @Lazy
    private ClientConnectionManager connectionManager;
    private BitmapFont font;
    private Stage pauseStage;
    private Skin pauseSkin;
    private Stage hudStage;
    private Skin hudSkin;
    private ChatTable chatTable;
    private boolean showDebug = false;
    private boolean paused = false;
    private float cameraPosX, cameraPosY;
    private Image pauseOverlay;
    private InputMultiplexer multiplexer;
    private boolean isActuallyMultiplayer = false;
    @Autowired
    private ChunkLoadingManager chunkLoadingManager;

    @Autowired
    public GameScreen(PlayerService playerService,
                      WorldService worldService,
                      AudioService audioService,
                      InputService inputService,
                      ScreenManager screenManager,
                      ChatService chatService,
                      BiomeService biomeService,
                      WorldRenderer worldRenderer,
                      ChunkLoaderService chunkLoaderService,
                      ChunkPreloaderService chunkPreloaderService, PlayerAnimationService animationService, MultiplayerClient client) {
        this.playerService = playerService;
        this.worldService = worldService;
        this.audioService = audioService;
        this.inputService = inputService;
        this.animationService = animationService;
        this.chatService = chatService;
        this.screenManager = screenManager;
        this.biomeService = biomeService;
        this.worldRenderer = worldRenderer;
        this.chunkLoaderService = chunkLoaderService;
        this.multiplayerClient = client;
    }

    private void handleDisconnection() {
        // Skip disconnect handling for singleplayer worlds
        if (!isActuallyMultiplayer) {
            return;
        }

        // Only handle actual multiplayer disconnects
        if (!handlingDisconnect && multiplayerClient != null
            && !multiplayerClient.isConnected()
            && worldService.isMultiplayerMode()) {

            handlingDisconnect = true;
            worldService.saveWorldData();
            worldService.handleDisconnect();

            ServerDisconnectScreen disconnectScreen = screenManager.getScreen(ServerDisconnectScreen.class);
            disconnectScreen.setDisconnectReason("TIMEOUT");
            screenManager.showScreen(ServerDisconnectScreen.class);
        }
    }

    @Override
    public void show() {
        handlingDisconnect = false;
        isActuallyMultiplayer = worldService.isMultiplayerMode();
        log.debug("GameScreen.show() >> current worldName={}, seed={}",
            worldService.getWorldData().getWorldName(),
            worldService.getWorldData().getSeed());

        // Ensure the world is initialized
        if (worldService.isMultiplayerMode() &&
            worldService.getWorldData().getWorldName() == null) {
            worldService.getWorldData().setWorldName("serverWorld");
            worldService.getWorldData().setSeed(System.currentTimeMillis());
            log.info("Initialized multiplayer world in GameScreen");
        }

        // Who is the current player?
        PlayerData pd = playerService.getPlayerData().getUsername() != null
            ? playerService.getPlayerData()
            : null;
        if (pd != null) {
            log.debug("Player data: username={}, x={}, y={}",
                pd.getUsername(), pd.getX(), pd.getY());
        }
        animationService.initAnimationsIfNeeded();
        if (worldRenderer != null) {
            worldRenderer.initialize();
        }

        float baseWidth = TARGET_VIEWPORT_WIDTH_TILES * TILE_SIZE;
        float aspect = (float) Gdx.graphics.getHeight() / (float) Gdx.graphics.getWidth();
        float baseHeight = baseWidth * aspect;

        camera = new OrthographicCamera();
        camera.setToOrtho(false, baseWidth, baseHeight);
        worldService.setCamera(camera);

        batch = new SpriteBatch();
        font = new BitmapFont();

        audioService.playMenuMusic();
        initializeUI();
        initializePlayerPosition();
    }

    private void initializeUI() {
        pauseStage = new Stage(new ScreenViewport());
        pauseSkin = new Skin(Gdx.files.internal("Skins/uiskin.json"));

        pauseOverlay = new Image(new NinePatch(pauseSkin.getSprite("white"), 0, 0, 0, 0));
        pauseOverlay.setColor(new Color(0, 0, 0, 0.6f));
        pauseOverlay.setFillParent(true);
        pauseOverlay.setVisible(false);
        pauseStage.addActor(pauseOverlay);

        setupPauseMenu();

        hudStage = new Stage(new ScreenViewport());
        hudSkin = new Skin(Gdx.files.internal("Skins/uiskin.json"));

        chatTable = new ChatTable(hudSkin, chatService);
        chatTable.setPosition(10, Gdx.graphics.getHeight() - 210);
        chatTable.setSize(400, 200);
        hudStage.addActor(chatTable);

        multiplexer = new InputMultiplexer();
        multiplexer.addProcessor(hudStage);
        multiplexer.addProcessor(inputService);

        Gdx.input.setInputProcessor(multiplexer);
    }

    private void setupPauseMenu() {
        Window.WindowStyle windowStyle = new Window.WindowStyle();
        windowStyle.titleFont = pauseSkin.getFont("default-font");
        windowStyle.titleFontColor = Color.WHITE;
        windowStyle.background = pauseSkin.newDrawable("white", new Color(0, 0, 0, 0.7f));

        Window pauseWindow = new Window("Paused", windowStyle);
        pauseWindow.setModal(true);
        pauseWindow.setMovable(false);

        TextButton resumeButton = new TextButton("Resume", pauseSkin);
        TextButton settingsButton = new TextButton("Settings", pauseSkin);
        TextButton exitButton = new TextButton("Exit to Menu", pauseSkin);

        resumeButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                togglePause();
            }
        });

        settingsButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                screenManager.showScreen(SettingsScreen.class);
            }
        });


        exitButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                goBackToMenu();
            }
        });


        pauseWindow.row().pad(10);
        pauseWindow.add(resumeButton).width(180).height(40).pad(5).row();
        pauseWindow.add(settingsButton).width(180).height(40).pad(5).row();
        pauseWindow.add(exitButton).width(180).height(40).pad(5).row();

        pauseWindow.pack();
        pauseWindow.setPosition(
            (pauseStage.getViewport().getWorldWidth() - pauseWindow.getWidth()) / 2f,
            (pauseStage.getViewport().getWorldHeight() - pauseWindow.getHeight()) / 2f
        );
        pauseWindow.setVisible(false);

        pauseStage.addActor(pauseWindow);
        pauseOverlay.setUserObject(pauseWindow);
    }

    private void togglePause() {
        paused = !paused;
        Window pauseWindow = (Window) pauseOverlay.getUserObject();
        pauseOverlay.setVisible(paused);
        pauseWindow.setVisible(paused);

        if (paused) {
            multiplexer.addProcessor(0, pauseStage);


            worldService.saveWorldData();
        } else {
            multiplexer.removeProcessor(pauseStage);
        }
    }
    private void updateChunkLoading() {
        long now = System.currentTimeMillis();
        if (now - lastChunkUpdate > CHUNK_UPDATE_INTERVAL) {
            lastChunkUpdate = now;

            PlayerData player = playerService.getPlayerData();
            if (player != null) {
                // Update chunk loading manager with player position
                chunkLoadingManager.preloadChunksAroundPosition(
                    player.getX(),
                    player.getY()
                );
            }

            // Update chunk loading manager state
            chunkLoadingManager.update();
        }
    }

    private boolean chunksLoading = false;
    private long lastChunkUpdate = 0;
    private static final long CHUNK_UPDATE_INTERVAL = 250; // ms

    @Override
    public void render(float delta) {
        // Check for disconnection first
        handleDisconnection();

        if (!handlingDisconnect) {

            // Update chunk loading
            updateChunkLoading();

            // Update game state
            if (!paused) {

                updateGame(delta);
            }

            // Render everything
            renderGame(delta);
        }
    }

    private void handleInput() {
        if (Gdx.input.isKeyJustPressed(Input.Keys.F3)) {
            showDebug = !showDebug;
        }

        if (!chatService.isActive() && Gdx.input.isKeyJustPressed(Input.Keys.T)) {
            chatTable.activate();
        }

        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            if (chatService.isActive()) {
                chatTable.deactivate();
            } else {
                togglePause();
            }
        }
    }


    private void initializePlayerPosition() {
        String playerName = playerService.getPlayerData().getUsername();
        PlayerData pd = worldService.getPlayerData(playerName);
        log.debug("initializePlayerPosition -> from worldService: username={}, x={}, y={}",
            pd != null ? pd.getUsername() : "(null)",
            pd != null ? pd.getX() : 0f,
            pd != null ? pd.getY() : 0f);

        if (pd == null) {
            log.error("Could not load player data for {}", playerName);
            return;
        }

        // Ensure coordinates are properly bounded
        float maxCoord = 1000000f;
        float boundedX = Math.max(-maxCoord, Math.min(maxCoord, pd.getX()));
        float boundedY = Math.max(-maxCoord, Math.min(maxCoord, pd.getY()));

        // Convert world coordinates
        float playerPixelX = boundedX * TILE_SIZE;
        float playerPixelY = boundedY * TILE_SIZE;

        // Validate conversion
        if (Float.isNaN(playerPixelX) || Float.isInfinite(playerPixelX) ||
            Float.isNaN(playerPixelY) || Float.isInfinite(playerPixelY)) {
            log.error("Invalid position conversion: {},{} -> {},{}",
                boundedX, boundedY, playerPixelX, playerPixelY);
            playerPixelX = 0;
            playerPixelY = 0;
        }

        // Update camera and player position
        cameraPosX = playerPixelX;
        cameraPosY = playerPixelY;
        camera.position.set(cameraPosX, cameraPosY, 0);
        camera.update();

        // Ensure player service has correct position
        playerService.setPosition((int)(boundedX), (int)(boundedY));

        // Pre-load chunks around new position
        chunkLoadingManager.preloadChunksAroundPosition(boundedX, boundedY);

        // Mark that we're loading chunks
        chunksLoading = true;
    }

    private void teleportPlayer(float x, float y) {
        // Start loading chunks first
        chunkLoadingManager.preloadChunksAroundPosition(x, y);
        chunksLoading = true;

        // Update player position
        PlayerData player = playerService.getPlayerData();
        player.setX(x);
        player.setY(y);
        playerService.setPosition((int)x, (int)y);

        // Update camera
        float pixelX = x * TILE_SIZE;
        float pixelY = y * TILE_SIZE;
        cameraPosX = pixelX;
        cameraPosY = pixelY;
        camera.position.set(cameraPosX, cameraPosY, 0);
        camera.update();

        // Sync with server if needed
        if (multiplayerClient.isConnected()) {
            multiplayerClient.sendPlayerMove(
                x, y,
                player.isWantsToRun(),
                false,
                player.getDirection().name().toLowerCase()
            );
        }
    }

    private void updateGame(float delta) {
        if (!paused) {
            handleInput();
            PlayerData player = playerService.getPlayerData();
            updateCamera();
            chunkLoaderService.updatePlayerPosition(
                player.getX() * TILE_SIZE,
                player.getY() * TILE_SIZE
            );
            playerService.update(delta);

        }

        pauseStage.act(delta);
        hudStage.act(delta);
        audioService.update(delta);
    }

    private void renderRemotePlayers(SpriteBatch batch, float delta) {
        Map<String, PlayerSyncData> states = multiplayerClient.getPlayerStates();
        String localUsername = playerService.getPlayerData().getUsername();

        // Process all remote players
        for (Map.Entry<String, PlayerSyncData> entry : states.entrySet()) {
            String otherUsername = entry.getKey();
            if (otherUsername.equals(localUsername)) continue;

            PlayerSyncData psd = entry.getValue();

            RemotePlayerAnimator animator = remotePlayerAnimators.computeIfAbsent(
                otherUsername,
                k -> {
                    RemotePlayerAnimator newAnimator = new RemotePlayerAnimator();
                    // Initialize at exact position to avoid interpolation at start
                    newAnimator.setPosition(psd.getX() * TILE_SIZE, psd.getY() * TILE_SIZE);
                    return newAnimator;
                }
            );

            // Get exact tile-centered position
            float targetTileX = psd.getX() * TILE_SIZE;
            float targetTileY = psd.getY() * TILE_SIZE;

            // Update animator with exact tile positions
            animator.updateState(
                targetTileX,
                targetTileY,
                psd.isRunning(),
                PlayerDirection.valueOf(psd.getDirection().toUpperCase()),
                psd.isMoving() && isTrulyMoving(psd), // Additional movement check
                delta
            );

            // Get animation frame
            TextureRegion frame = animationService.getCurrentFrame(
                animator.getDirection(),
                animator.isMoving(),
                animator.isRunning(),
                animator.getAnimationTime()
            );

            // Draw centered on tile
            float drawX = animator.getCurrentX();
            float drawY = animator.getCurrentY();

            float width = frame.getRegionWidth();
            float height = frame.getRegionHeight();
            batch.draw(frame, drawX, drawY, width, height);

        }

        // Clean up disconnected players
        remotePlayerAnimators.keySet().removeIf(username -> !states.containsKey(username));
    }

    // Helper method to determine if a player is actually moving
    private boolean isTrulyMoving(PlayerSyncData psd) {
        float lastX = psd.getLastX();
        float lastY = psd.getLastY();
        float currentX = psd.getX();
        float currentY = psd.getY();

        float dx = Math.abs(currentX - lastX);
        float dy = Math.abs(currentY - lastY);

        return dx > 0.001f || dy > 0.001f;
    }private void renderGame(float delta) {
        Gdx.gl.glClearColor(0, 0, 0, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        // Draw world and object bases
        worldRenderer.render(camera,delta);

        // Draw local player
        batch.setProjectionMatrix(camera.combined);
        batch.begin();
        playerService.render(batch);

        // Draw remote players
        renderRemotePlayers(batch, delta);
        batch.end();

        // Draw tree tops on top of players
        worldRenderer.renderTreeTops(delta);

        // Draw UI elements last
        if (paused) {
            pauseStage.draw();
        }

        hudStage.act(delta);
        hudStage.draw();

        if (showDebug) {
            renderDebugInfo();
        }
    }

    private void updateCamera() {
        float playerPixelX = playerService.getPlayerData().getX() * TILE_SIZE + TILE_SIZE / 2f;
        float playerPixelY = playerService.getPlayerData().getY() * TILE_SIZE + TILE_SIZE / 2f;

        cameraPosX = lerp(cameraPosX, playerPixelX);
        cameraPosY = lerp(cameraPosY, playerPixelY);

        cameraPosX = Math.round(cameraPosX);
        cameraPosY = Math.round(cameraPosY);

        camera.position.set(cameraPosX, cameraPosY, 0);
        camera.update();
    }


    private void renderDebugInfo() {
        batch.setProjectionMatrix(hudStage.getCamera().combined);
        batch.begin();

        PlayerData player = playerService.getPlayerData();
        final int TILE_SIZE = 32;
        final int CHUNK_SIZE = 16;
        final int WORLD_WIDTH_TILES = 100000;
        final int WORLD_HEIGHT_TILES = 100000;

        float pixelX = player.getX() * TILE_SIZE;
        float pixelY = player.getY() * TILE_SIZE;
        int tileX = (int) player.getX();
        int tileY = (int) player.getY();
        int chunkX = tileX / CHUNK_SIZE;
        int chunkY = tileY / CHUNK_SIZE;
        int totalChunksX = WORLD_WIDTH_TILES / CHUNK_SIZE;
        int totalChunksY = WORLD_HEIGHT_TILES / CHUNK_SIZE;

        font.setColor(Color.WHITE);
        float y = 25;

        font.draw(batch, "FPS: " + Gdx.graphics.getFramesPerSecond(), 10, y);
        y += 20;
        font.draw(batch, String.format("Pixel Pos: (%.1f, %.1f)", pixelX, pixelY), 10, y);
        y += 20;
        font.draw(batch, String.format("Tile Pos: (%d, %d)", tileX, tileY), 10, y);
        y += 20;
        font.draw(batch, String.format("Chunk Pos: (%d, %d)", chunkX, chunkY), 10, y);
        y += 20;
        font.draw(batch, String.format("Total Tiles: %d x %d", WORLD_WIDTH_TILES, WORLD_HEIGHT_TILES), 10, y);
        y += 20;
        font.draw(batch, String.format("Total Chunks: %d x %d", totalChunksX, totalChunksY), 10, y);
        y += 20;
        font.draw(batch, "Biome: " + getBiomeName(pixelX, pixelY), 10, y);
        y += 20;
        font.draw(batch, "Direction: " + player.getDirection(), 10, y);

        batch.end();
    }

    private String getBiomeName(float pixelX, float pixelY) {
        var biomeResult = biomeService.getBiomeAt(pixelX, pixelY);
        return biomeResult.getPrimaryBiome() != null ? biomeResult.getPrimaryBiome().getName() : "Unknown";
    }

    private float lerp(float a, float b) {
        float CAMERA_LERP_FACTOR = 0.1f;
        return a + (b - a) * CAMERA_LERP_FACTOR;
    }

    @Override
    public void resize(int width, int height) {
        camera.viewportWidth = TARGET_VIEWPORT_WIDTH_TILES * TILE_SIZE;
        camera.viewportHeight = camera.viewportWidth * ((float) height / width);
        camera.update();

        pauseStage.getViewport().update(width, height, true);
        hudStage.getViewport().update(width, height, true);

        if (chatTable != null) {
            chatTable.setPosition(10, height - 210);
        }

        if (pauseOverlay != null && pauseOverlay.isVisible()) {
            Window pauseWindow = (Window) pauseOverlay.getUserObject();
            if (pauseWindow != null) {
                pauseWindow.pack();
                pauseWindow.setPosition(
                    (pauseStage.getViewport().getWorldWidth() - pauseWindow.getWidth()) / 2f,
                    (pauseStage.getViewport().getWorldHeight() - pauseWindow.getHeight()) / 2f
                );
            }
        }
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void hide() {
        // If we're in multiplayer and the screen is being hidden (e.g., going to main menu),
        // then do a proper cleanup and revert to singleplayer mode:
        if (multiplayerClient.isConnected()) {
            // Gracefully disconnect from server
            multiplayerClient.disconnect();

            // Let the world service handle any leftover server references
            worldService.handleDisconnect();
        }

        // Reset multiplayer mode
        worldService.setMultiplayerMode(false);

        // Stop music
        audioService.stopMenuMusic();

        // Reset disconnect handling flag
        handlingDisconnect = false;
    }

    private void goBackToMenu() {
        if (multiplayerClient.isConnected()) {
            multiplayerClient.disconnect();
            worldService.handleDisconnect();
        }

        // Clear world data before switching screens
        worldService.clearWorldData();
        worldService.setMultiplayerMode(false);

        // Release the connection lock
        connectionManager.releaseInstanceLock();

        // Switch to mode selection screen
        screenManager.showScreen(ModeSelectionScreen.class);
    }


    @Override
    public void dispose() {
        if (multiplayerClient.isConnected()) {
            multiplayerClient.disconnect();
            log.info("Disconnected from server during screen disposal");
        }

        // Dispose resources
        batch.dispose();
        font.dispose();
        pauseStage.dispose();
        hudStage.dispose();
        pauseSkin.dispose();
        hudSkin.dispose();
        worldRenderer.dispose();

        // Cleanup chunk loading
        chunkLoadingManager.dispose();
    }
}

================
File: main/java/io.github.minemon/core/screen/LoginScreen.java
================
package io.github.minemon.core.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.*;
import com.badlogic.gdx.utils.Scaling;
import com.badlogic.gdx.utils.viewport.ExtendViewport;
import io.github.minemon.audio.service.AudioService;
import io.github.minemon.core.service.ScreenManager;
import io.github.minemon.core.service.UiService;
import io.github.minemon.core.ui.DialogCloseListener;
import io.github.minemon.core.ui.ServerConfigDialog;
import io.github.minemon.multiplayer.model.ServerConnectionConfig;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.multiplayer.service.ServerConnectionService;
import io.github.minemon.multiplayer.service.impl.ClientConnectionManager;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

@Component
@Slf4j
public class LoginScreen implements Screen, MultiplayerClient.LoginResponseListener, MultiplayerClient.CreateUserResponseListener {

    private static final float MIN_WIDTH = 800;
    private static final float MIN_HEIGHT = 480;
    private static final String BACKGROUND_PATH = "Textures/UI/ethereal.png";

    private final AudioService audioService;
    private final ScreenManager screenManager;
    private final ServerConnectionService serverConnectionService;
    private final MultiplayerClient multiplayerClient;
    private final UiService uiService;

    @Autowired
    private PlayerService playerService;

    private Stage stage;
    private Skin skin;
    private ServerListView serverListView;
    private Table root;
    private Dialog connectingDialog;
    private Dialog loginDialog;
    @Autowired
    private WorldService worldService;
    @Autowired
    private ClientConnectionManager connectionManager;

    @Autowired
    public LoginScreen(
        AudioService audioService,
        ScreenManager screenManager,
        ServerConnectionService serverConnectionService,
        MultiplayerClient multiplayerClient,
        UiService uiService) {
        this.audioService = audioService;
        this.screenManager = screenManager;
        this.serverConnectionService = serverConnectionService;
        this.multiplayerClient = multiplayerClient;
        this.uiService = uiService;
    }

    @Override
    public void show() {
        stage = new Stage(new ExtendViewport(MIN_WIDTH, MIN_HEIGHT));
        uiService.initialize();
        uiService.getDialogFactory().setStage(stage);
        skin = uiService.getSkin();
        Gdx.input.setInputProcessor(stage);

        audioService.playMenuMusic();

        createUI();
        setupInputHandling();
    }

    private void createUI() {
        setBackground();

        root = new Table(skin);
        root.setFillParent(true);
        stage.addActor(root);

        Table topBar = new Table(skin);
        topBar.setBackground(uiService.getStyleFactory().createPanelBackground());
        topBar.pad(10);

        TextButton backButton = createSimpleButton("Back to Menu", this::handleBack);
        topBar.add(backButton).left().padRight(20);

        Label titleLabel = uiService.getStyleFactory().createTitleLabel("PokéMeetup Server List", skin);
        topBar.add(titleLabel).expandX().center();
        topBar.add().width(100);

        root.add(topBar).expandX().fillX().row();

        Table headerRow = new Table(skin);
        headerRow.setBackground(skin.newDrawable("white", 0.2f, 0.2f, 0.2f, 0.8f));
        headerRow.pad(10);
        Label nameHeader = new Label("Server Name", skin);
        nameHeader.setColor(Color.GOLD);
        Label playersHeader = new Label("Players", skin);
        playersHeader.setColor(Color.GOLD);

        headerRow.add(nameHeader).expandX().left().padLeft(80);
        headerRow.add(playersHeader).width(100).right().padRight(10);

        root.add(headerRow).expandX().fillX().height(40).row();

        serverListView = new ServerListView(skin, loadServers());
        ScrollPane scrollPane = new ScrollPane(serverListView, skin);
        scrollPane.setFadeScrollBars(false);
        scrollPane.setScrollingDisabled(true, false);
        scrollPane.setForceScroll(false, true);
        scrollPane.setSmoothScrolling(true);

        Table serverContainer = new Table(skin);
        serverContainer.setBackground(uiService.getStyleFactory().createPanelBackground());
        serverContainer.add(scrollPane).expand().fill().pad(15);

        root.add(serverContainer).expand().fill().pad(20).row();

        Table buttonPanel = new Table(skin);
        buttonPanel.setBackground(uiService.getStyleFactory().createPanelBackground());
        buttonPanel.pad(10);

        float buttonWidth = 150;
        float buttonHeight = 50;

        TextButton joinButton = createSimpleButton("Join Server", this::handleJoinServer);
        TextButton addButton = createSimpleButton("Add Server", this::handleAddServer);
        TextButton editButton = createSimpleButton("Edit Server", this::handleEditServer);
        TextButton deleteButton = createSimpleButton("Delete Server", this::handleDeleteServer);

        buttonPanel.add(joinButton).width(buttonWidth).height(buttonHeight).pad(10);
        buttonPanel.add(addButton).width(buttonWidth).height(buttonHeight).pad(10);
        buttonPanel.add(editButton).width(buttonWidth).height(buttonHeight).pad(10);
        buttonPanel.add(deleteButton).width(buttonWidth).height(buttonHeight).pad(10);

        root.add(buttonPanel).expandX().fillX().padBottom(20);
    }

    private void setBackground() {
        Texture bgTexture = new Texture(Gdx.files.internal(BACKGROUND_PATH));
        Image backgroundImage = new Image(new TextureRegionDrawable(bgTexture));
        backgroundImage.setFillParent(true);
        backgroundImage.setScaling(Scaling.fill);
        backgroundImage.setTouchable(Touchable.disabled);
        stage.addActor(backgroundImage);
    }

    private TextButton createSimpleButton(String text, Runnable action) {
        TextButton button = uiService.getStyleFactory().createGameButton(text, skin);

        final Color NORMAL_COLOR = Color.WHITE;
        final Color HOVER_COLOR = new Color(0.9f, 0.9f, 0.9f, 1f);
        final Color PRESSED_COLOR = new Color(0.8f, 0.8f, 0.8f, 1f);

        button.setColor(NORMAL_COLOR);

        button.addListener(new InputListener() {
            boolean pressed = false;

            @Override
            public boolean touchDown(InputEvent event, float x, float y, int pointer, int buttonCode) {
                button.setColor(PRESSED_COLOR);
                pressed = true;
                return true;
            }

            @Override
            public void touchUp(InputEvent event, float x, float y, int pointer, int buttonCode) {
                if (pressed) {
                    if (x >= 0 && x <= button.getWidth() && y >= 0 && y <= button.getHeight()) {
                        action.run();
                        button.setColor(HOVER_COLOR);
                    } else {
                        button.setColor(NORMAL_COLOR);
                    }
                    pressed = false;
                }
            }

            @Override
            public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {
                if (!pressed) {
                    button.setColor(HOVER_COLOR);
                }
            }

            @Override
            public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {
                if (!pressed) {
                    button.setColor(NORMAL_COLOR);
                }
            }
        });

        return button;
    }

    private void handleBack() {
        screenManager.goBack();
    }

    private void handleJoinServer() {
        ServerConnectionConfig selected = serverListView.getSelected();
        if (selected == null) {
            uiService.getDialogFactory().showWarning("No Server Selected", "Please select a server to join.");
            return;
        }
        showLoginDialog(selected);
    }

    private void showLoginDialog(ServerConnectionConfig config) {
        try {
            // Clean up any existing locks first
            connectionManager.releaseInstanceLock();

            // Then try to acquire new lock
            if (!connectionManager.acquireInstanceLock()) {
                uiService.getDialogFactory().showError("Connection Error",
                    "Another instance of the game is already running on this machine.");
                return;
            }
        } catch (Exception e) {
            log.error("Lock error: {}", e.getMessage());
            uiService.getDialogFactory().showError("Connection Error",
                "Failed to establish connection lock. Please restart the game.");
            return;
        }

        if (loginDialog != null && loginDialog.isVisible()) {
            loginDialog.hide();
        }

        if (!connectionManager.acquireInstanceLock()) {
            uiService.getDialogFactory().showError("Connection Error",
                "Another instance of the game is already running on this machine.");
            return;
        }

        if (loginDialog != null && loginDialog.isVisible()) {
            loginDialog.hide();
        }

        String prefillUsername = config.isRememberMe() ? config.getSavedUsername() : "";
        String prefillPassword = config.isRememberMe() ? config.getSavedPassword() : "";

        Window.WindowStyle windowStyle = skin.get(Window.WindowStyle.class);
        loginDialog = new Dialog("Login to " + config.getServerName(), windowStyle);
        loginDialog.pad(20);

        TextField usernameField = new TextField(prefillUsername, skin);
        usernameField.setMessageText("Username");
        TextField passwordField = new TextField(prefillPassword, skin);
        passwordField.setMessageText("Password");
        passwordField.setPasswordCharacter('*');
        passwordField.setPasswordMode(true);

        CheckBox rememberMeCheck = new CheckBox(" Remember Me", skin);
        rememberMeCheck.setChecked(config.isRememberMe());

        Table contentTable = loginDialog.getContentTable();
        contentTable.add(new Label("Username:", skin)).left().pad(5);
        contentTable.row();
        contentTable.add(usernameField).width(200).pad(5);
        contentTable.row();
        contentTable.add(new Label("Password:", skin)).left().pad(5);
        contentTable.row();
        contentTable.add(passwordField).width(200).pad(5);
        contentTable.row();
        contentTable.add(rememberMeCheck).pad(5);

        TextButton loginButton = new TextButton("Login", skin);
        TextButton createButton = new TextButton("Create Account", skin);
        TextButton cancelButton = new TextButton("Cancel", skin);

        loginButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                String user = usernameField.getText().trim();
                String pass = passwordField.getText();
                boolean rm = rememberMeCheck.isChecked();
                if (user.isEmpty() || pass.isEmpty()) {
                    uiService.getDialogFactory().showWarning("Invalid Input", "Username and password cannot be empty.");
                    return;
                }

                config.setRememberMe(rm);
                if (rm) {
                    config.setSavedUsername(user);
                    config.setSavedPassword(pass);
                } else {
                    config.setSavedUsername("");
                    config.setSavedPassword("");
                }
                serverConnectionService.saveConfig(config);

                loginDialog.hide();
                if (!multiplayerClient.isConnected()) {
                    multiplayerClient.setPendingLoginRequest(() -> multiplayerClient.login(user, pass));
                    connectToServer(config);
                } else {
                    multiplayerClient.login(user, pass);
                }
            }
        });

        loginDialog.addListener((DialogCloseListener) () -> {
            if (!multiplayerClient.isConnected()) {
                connectionManager.releaseInstanceLock();
            }
        });

        // Existing button setup code remains the same
        createButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                showCreateAccountDialog(config);
                loginDialog.hide();
            }
        });

        cancelButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                loginDialog.hide();
                connectionManager.releaseInstanceLock();
            }
        });

        loginDialog.button(loginButton);
        loginDialog.button(createButton);
        loginDialog.button(cancelButton);

        loginDialog.show(stage);
    }

    // Add cleanup on screen disposal
    @Override
    public void dispose() {
        connectionManager.releaseInstanceLock();
        if (stage != null) {
            stage.dispose();
        }
        if (skin != null) {
            skin.dispose();
        }
    }

    private void showCreateAccountDialog(ServerConnectionConfig config) {
        Dialog createDialog = new Dialog("Create Account for " + config.getServerName(), skin);
        createDialog.pad(20);

        TextField usernameField = new TextField("", skin);
        usernameField.setMessageText("Username");
        TextField passwordField = new TextField("", skin);
        passwordField.setMessageText("Password");
        passwordField.setPasswordCharacter('*');
        passwordField.setPasswordMode(true);

        TextField confirmField = new TextField("", skin);
        confirmField.setMessageText("Confirm Password");
        confirmField.setPasswordCharacter('*');
        confirmField.setPasswordMode(true);

        Table contentTable = createDialog.getContentTable();
        contentTable.add(new Label("Username:", skin)).left().pad(5);
        contentTable.row();
        contentTable.add(usernameField).width(200).pad(5);
        contentTable.row();
        contentTable.add(new Label("Password:", skin)).left().pad(5);
        contentTable.row();
        contentTable.add(passwordField).width(200).pad(5);
        contentTable.row();
        contentTable.add(new Label("Confirm Password:", skin)).left().pad(5);
        contentTable.row();
        contentTable.add(confirmField).width(200).pad(5);

        TextButton createBtn = new TextButton("Create", skin);
        TextButton cancelBtn = new TextButton("Cancel", skin);

        createBtn.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                String user = usernameField.getText().trim();
                String pass = passwordField.getText();
                String conf = confirmField.getText();
                if (user.isEmpty() || pass.isEmpty()) {
                    uiService.getDialogFactory().showWarning("Invalid Input", "Username and password cannot be empty.");
                    return;
                }
                if (!pass.equals(conf)) {
                    uiService.getDialogFactory().showWarning("Mismatch", "Passwords do not match.");
                    return;
                }

                createDialog.hide();
                if (!multiplayerClient.isConnected()) {
                    // Connect first, then send CreateUserRequest
                    multiplayerClient.setPendingCreateUserRequest(() -> multiplayerClient.createUser(user, pass));
                    connectToServer(config);
                } else {
                    // Already connected, send CreateUserRequest directly
                    multiplayerClient.createUser(user, pass);
                }
            }
        });

        cancelBtn.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                createDialog.hide();
            }
        });

        createDialog.button(createBtn);
        createDialog.button(cancelBtn);

        createDialog.show(stage);
    }

    private void connectToServer(ServerConnectionConfig config) {
        connectingDialog = uiService.getDialogFactory().showLoading("Connecting to " + config.getServerName());
        multiplayerClient.setLoginResponseListener(this);
        multiplayerClient.setCreateUserResponseListener(this);

        // Set multiplayer mode before connecting
        worldService.setMultiplayerMode(true);

        multiplayerClient.connect(config.getServerIP(), config.getTcpPort(), config.getUdpPort());
    }

    @Override
    public void onLoginResponse(boolean success, String message, String username, int startX, int startY) {
        Gdx.app.postRunnable(() -> {
            if (connectingDialog != null) {
                connectingDialog.hide();
            }

            // Check if we got disconnected
            if (!success && message != null && message.contains("Disconnected")) {
                // Return to login screen
                screenManager.showScreen(LoginScreen.class);
                return;
            }

            if (success) {
                PlayerData pd = playerService.getPlayerData();
                pd.setUsername(username);
                pd.setX(startX);
                pd.setY(startY);
                playerService.setPlayerData(pd);

                uiService.getDialogFactory().showSuccess("Connected", message);
                screenManager.showScreen(GameScreen.class);
            } else {
                uiService.getDialogFactory().showError("Connection Failed", message);
            }
        });
    }


    private void handleAddServer() {
        ServerConfigDialog dialog = new ServerConfigDialog(
            skin,
            uiService.getDialogFactory(),
            null,
            config -> {
                serverConnectionService.addServer(config);
                refreshServerList();
                uiService.getDialogFactory().showSuccess("Server Added", "Server successfully added!");
            }
        );
        dialog.show(stage);
    }

    private void handleEditServer() {
        ServerConnectionConfig selected = serverListView.getSelected();
        if (selected == null) {
            uiService.getDialogFactory().showWarning("No Server Selected", "Please select a server to edit.");
            return;
        }

        ServerConfigDialog dialog = new ServerConfigDialog(
            skin,
            uiService.getDialogFactory(),
            selected,
            config -> {
                serverConnectionService.saveConfig(config);
                refreshServerList();
                uiService.getDialogFactory().showSuccess("Server Updated", "Server successfully updated!");
            }
        );
        dialog.show(stage);
    }

    private void handleDeleteServer() {
        ServerConnectionConfig selected = serverListView.getSelected();
        if (selected == null) {
            uiService.getDialogFactory().showWarning("No Server Selected", "Please select a server to delete.");
            return;
        }

        uiService.getDialogFactory().showConfirmation(
            "Delete Server",
            "Are you sure you want to delete '" + selected.getServerName() + "'?",
            () -> {
                serverConnectionService.deleteServer(selected);
                refreshServerList();
            }
        );
    }

    private List<ServerConnectionConfig> loadServers() {
        return new ArrayList<>(serverConnectionService.listServers());
    }

    private void refreshServerList() {
        serverListView.setServers(loadServers());
    }

    private void setupInputHandling() {
        stage.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if (keycode == Input.Keys.ESCAPE) {
                    handleBack();
                    return true;
                }
                return false;
            }
        });
    }

    @Override
    public void render(float delta) {
        Gdx.gl.glClearColor(0, 0, 0, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        stage.act(delta);
        stage.draw();
        audioService.update(delta);
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
        root.invalidateHierarchy();
        root.layout();
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void hide() {
        audioService.stopMenuMusic();
        connectionManager.releaseInstanceLock();
    }

    @Override
    public void onCreateUserResponse(boolean success, String message) {
        Gdx.app.postRunnable(() -> {
                if (connectingDialog != null) {
                    connectingDialog.hide();
                }

                if (success) {
                    uiService.getDialogFactory().showSuccess("Account Created", message);
                } else {
                    uiService.getDialogFactory().showError("Registration Failed", message);
                }
            }
        );
    }

}

================
File: main/java/io.github.minemon/core/screen/ModeSelectionScreen.java
================
package io.github.minemon.core.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.minemon.audio.service.AudioService;
import io.github.minemon.core.service.BackgroundService;
import io.github.minemon.core.service.ScreenManager;
import io.github.minemon.core.service.SettingsService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.world.service.WorldService;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;


@Component
@RequiredArgsConstructor
public class ModeSelectionScreen implements Screen {
    private final AudioService audioService;
    private final ScreenManager screenManager;
    private final SettingsService settingsService;
    private final BackgroundService backgroundAnimation;
    @Autowired
    @Lazy
    private MultiplayerClient multiplayerClient;
    @Autowired
    @Lazy
    private WorldService worldService;
    private Stage stage;
    private Skin skin;
    private Window settingsWindow;

    @Override
    public void show() {
        audioService.playMenuMusic();
        backgroundAnimation.initialize();

        stage = new Stage(new ScreenViewport());
        Gdx.input.setInputProcessor(stage);
        skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));

        createMainMenu();
        createSettingsWindow();
    }

    private void createMainMenu() {
        Table mainTable = new Table();
        mainTable.setFillParent(true);


        Label titleLabel = new Label("MineMon", skin);
        titleLabel.setFontScale(2.0f);


        Label versionLabel = new Label("Version 1.0", skin);


        TextButton singlePlayerButton = createStyledButton("Single Player");
        TextButton multiplayerButton = createStyledButton("Multiplayer");
        TextButton settingsButton = createStyledButton("Settings");
        TextButton exitButton = createStyledButton("Exit Game");


        Label motdLabel = new Label("Welcome to MineMon - Catch them all in an open world!", skin);
        motdLabel.setWrap(true);


        mainTable.add(titleLabel).pad(50).row();
        mainTable.add(versionLabel).padBottom(20).row();
        mainTable.add(motdLabel).width(400).pad(20).row();
        mainTable.add(singlePlayerButton).width(300).pad(10).row();
        mainTable.add(multiplayerButton).width(300).pad(10).row();
        mainTable.add(settingsButton).width(300).pad(10).row();
        mainTable.add(exitButton).width(300).pad(10).row();

        singlePlayerButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (multiplayerClient.isConnected()) {
                    multiplayerClient.disconnect();
                }
                worldService.handleDisconnect();
                worldService.setMultiplayerMode(false);

                screenManager.showScreen(WorldSelectionScreen.class);
            }
        });

        multiplayerButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                screenManager.showScreen(LoginScreen.class);
            }
        });

        settingsButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                toggleSettingsWindow();
            }
        });

        exitButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                Gdx.app.exit();
            }
        });

        stage.addActor(mainTable);
    }

    private TextButton createStyledButton(String text) {
        TextButton button = new TextButton(text, skin);
        button.addListener(new ClickListener() {
            @Override
            public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {
                button.setColor(1, 1, 0.8f, 1);
            }

            @Override
            public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {
                button.setColor(1, 1, 1, 1);
            }
        });
        return button;
    }

    private void createSettingsWindow() {
        settingsWindow = new Window("Settings", skin);
        settingsWindow.setVisible(false);
        settingsWindow.setModal(true);


        Label musicLabel = new Label("Music Volume:", skin);
        Slider musicSlider = new Slider(0, 1, 0.1f, false, skin);
        musicSlider.setValue(settingsService.getMusicVolume());
        musicSlider.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeListener.ChangeEvent event, Actor actor) {
                float newVolume = musicSlider.getValue();
                // 1. Update in SettingsService
                settingsService.updateMusicVolume(newVolume);
                // 2. Also update the AudioService so the in-game volume changes
                audioService.setMusicVolume(newVolume);
            }
        });



        Label soundLabel = new Label("Sound Volume:", skin);
        Slider soundSlider = new Slider(0, 1, 0.1f, false, skin);
        soundSlider.setValue(settingsService.getSoundVolume());
        soundSlider.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                float newVolume = soundSlider.getValue();
                settingsService.updateSoundVolume(newVolume);
                audioService.setSoundVolume(newVolume);
            }
        });



        CheckBox vsyncCheck = new CheckBox(" VSync", skin);
        vsyncCheck.setChecked(settingsService.getVSync());
        vsyncCheck.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                settingsService.setVSync(vsyncCheck.isChecked());
                Gdx.graphics.setVSync(vsyncCheck.isChecked());
            }
        });


        TextButton closeButton = new TextButton("Close", skin);
        closeButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                settingsWindow.setVisible(false);
            }
        });


        Table settingsTable = new Table();
        settingsTable.add(musicLabel).pad(10);
        settingsTable.add(musicSlider).width(200).pad(10).row();
        settingsTable.add(soundLabel).pad(10);
        settingsTable.add(soundSlider).width(200).pad(10).row();
        settingsTable.add(vsyncCheck).colspan(2).pad(10).row();
        settingsTable.add(closeButton).colspan(2).pad(10);

        settingsWindow.add(settingsTable);
        settingsWindow.pack();
        settingsWindow.setPosition(
                (stage.getWidth() - settingsWindow.getWidth()) / 2,
                (stage.getHeight() - settingsWindow.getHeight()) / 2
        );

        stage.addActor(settingsWindow);
    }

    private void toggleSettingsWindow() {
        settingsWindow.setVisible(!settingsWindow.isVisible());
    }

    @Override
    public void render(float delta) {
        Gdx.gl.glClearColor(0.1f, 0.1f, 0.1f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        backgroundAnimation.render(false);

        stage.act(delta);
        stage.draw();
        audioService.update(delta);
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
        settingsWindow.setPosition(
                (width - settingsWindow.getWidth()) / 2,
                (height - settingsWindow.getHeight()) / 2
        );
    }

    @Override
    public void pause() {}

    @Override
    public void resume() {}

    @Override
    public void hide() {
        audioService.stopMenuMusic();
    }

    @Override
    public void dispose() {
        stage.dispose();
        skin.dispose();
        backgroundAnimation.dispose();
    }
}

================
File: main/java/io.github.minemon/core/screen/ServerDisconnectScreen.java
================
package io.github.minemon.core.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.InputListener;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.minemon.core.service.ScreenManager;
import io.github.minemon.core.service.UiService;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Slf4j
@Component
public class ServerDisconnectScreen implements Screen {
    private final ScreenManager screenManager;
    private final UiService uiService;
    private Stage stage;
    @Setter
    private String disconnectReason;
    private Skin skin;

    @Autowired
    public ServerDisconnectScreen(ScreenManager screenManager, UiService uiService) {
        this.screenManager = screenManager;
        this.uiService = uiService;
    }


    @Override
    public void show() {
        stage = new Stage(new ScreenViewport());
        skin = uiService.getSkin();

        Table mainTable = new Table(skin);
        mainTable.setFillParent(true);
        stage.addActor(mainTable);

        // Set dark semi-transparent background
        mainTable.setBackground(skin.newDrawable("white", 0.2f, 0.2f, 0.2f, 0.9f));

        // Title
        Label titleLabel = new Label(getDisconnectTitle(), skin);
        titleLabel.setAlignment(Align.center);
        mainTable.add(titleLabel).pad(40).row();

        // Message
        Label messageLabel = new Label(getDisconnectMessage(), skin);
        messageLabel.setAlignment(Align.center);
        messageLabel.setWrap(true);
        mainTable.add(messageLabel).width(400).pad(20).row();

        // Back button
        TextButton backButton = new TextButton("Back to Menu", skin);
        backButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                screenManager.showScreen(ModeSelectionScreen.class);
            }
        });
        mainTable.add(backButton).pad(40).width(200).height(50).row();

        // ESC key handler
        stage.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if (keycode == Input.Keys.ESCAPE) {
                    screenManager.showScreen(ModeSelectionScreen.class);
                    return true;
                }
                return false;
            }
        });

        Gdx.input.setInputProcessor(stage);
    }

    private void goToModeSelection() {
        screenManager.showScreen(ModeSelectionScreen.class);
    }

    @Override
    public void render(float delta) {
        Gdx.gl.glClearColor(0.1f, 0.1f, 0.1f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        stage.act(delta);
        stage.draw();
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
    }
    private String getDisconnectTitle() {
        if (disconnectReason == null) {
            return "Disconnected from Server";
        }
        return switch (disconnectReason) {
            case "QUIT" -> "Left Game";
            case "KICKED" -> "Kicked from Server";
            case "SERVER_CLOSED" -> "Server Closed";
            case "TIMEOUT" -> "Connection Timed Out";
            default -> "Disconnected from Server";
        };
    }

    private String getDisconnectMessage() {
        if (disconnectReason == null) {
            return "You have been disconnected from the server.\nPlease try connecting again later.";
        }
        return switch (disconnectReason) {
            case "QUIT" -> "Thanks for playing!\nYou can rejoin the server at any time.";
            case "KICKED" -> "You were kicked from the server.\nPlease contact the server administrator.";
            case "SERVER_CLOSED" -> "The server has been shut down.\nPlease try again later.";
            case "TIMEOUT" -> "Lost connection to the server.\nPlease check your internet connection.";
            default -> "Connection to the server was lost.\nPlease try connecting again later.";
        };
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void hide() {
    }

    @Override
    public void dispose() {
        if (stage != null) {
            stage.dispose();
        }
    }
}

================
File: main/java/io.github.minemon/core/screen/ServerListView.java
================
package io.github.minemon.core.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import io.github.minemon.multiplayer.model.ServerConnectionConfig;
import lombok.Getter;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class ServerListView extends Table {
    private static final float ROW_HEIGHT = 80f;
    private static final float ICON_SIZE = 48f;
    private static final float PADDING = 10f;
    private static final String DEFAULT_ICON_PATH = "icons/default-server-icon.png";
    private static final String DEFAULT_MOTD = "No message of the day provided.";

    private final Skin skin;
    private final List<ServerConnectionConfig> servers;
    private final ButtonGroup<TextButton> buttonGroup;

    @Getter
    private ServerConnectionConfig selected;

    public ServerListView(Skin skin, List<ServerConnectionConfig> servers) {
        super(skin);
        this.skin = skin;
        this.servers = new ArrayList<>(servers);
        this.buttonGroup = new ButtonGroup<>();
        buttonGroup.setMaxCheckCount(1);
        buttonGroup.setMinCheckCount(0);
        buttonGroup.setUncheckLast(true);

        setFillParent(true);
        rebuild();
    }

    private void rebuild() {
        clear();
        buttonGroup.clear();



        for (ServerConnectionConfig server : servers) {
            createServerRow(server);
        }

        if (servers.isEmpty()) {
            Label noServersLabel = new Label("No servers added yet.", skin);
            noServersLabel.setColor(Color.LIGHT_GRAY);
            add(noServersLabel).pad(20).center().row();
        }

        pack();
    }

    private void createServerRow(ServerConnectionConfig server) {
        final Color normalColor = new Color(0.2f, 0.2f, 0.2f, 1f);
        final Color hoverColor = new Color(0.3f, 0.3f, 0.3f, 1f);
        final Color selectedColor = new Color(0.4f, 0.6f, 0.9f, 0.7f);

        Table rowTable = new Table(skin);
        rowTable.setBackground(skin.newDrawable("white", normalColor));

        Image icon = createServerIcon(server);
        rowTable.add(icon).size(ICON_SIZE).pad(PADDING);

        Table infoTable = new Table(skin);
        Label nameLabel = new Label(server.getServerName(), skin);
        nameLabel.setColor(Color.WHITE);

        Label motdLabel = new Label(getMotd(server), skin);
        motdLabel.setWrap(true);
        motdLabel.setColor(new Color(0.8f, 0.8f, 0.8f, 1f));

        infoTable.add(nameLabel).left().expandX().row();
        infoTable.add(motdLabel).left().expandX().padTop(5).width(400);

        rowTable.add(infoTable).expandX().fillX().pad(PADDING);

        Table playerCountTable = new Table(skin);
        playerCountTable.setBackground(skin.newDrawable("white", new Color(0.2f, 0.2f, 0.2f, 0.7f)));
        Label playersLabel = new Label(
                String.format("%d/%d", server.getCurrentPlayers(), server.getMaxPlayers()),
                skin
        );
        playersLabel.setColor(Color.WHITE);
        playerCountTable.add(playersLabel).pad(5);
        rowTable.add(playerCountTable).right().padRight(PADDING);

        TextButton rowButton = new TextButton("", skin);
        rowButton.add(rowTable).expand().fill();

        rowButton.addListener(new ClickListener() {
            @Override
            public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {
                if (!rowButton.isChecked()) {
                    rowTable.setBackground(skin.newDrawable("white", hoverColor));
                }
            }

            @Override
            public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {
                if (!rowButton.isChecked()) {
                    rowTable.setBackground(skin.newDrawable("white", normalColor));
                }
            }

            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (rowButton.isChecked()) {
                    selected = server;
                    rowTable.setBackground(skin.newDrawable("white", selectedColor));
                } else {
                    if (selected == server) selected = null;
                    rowTable.setBackground(skin.newDrawable("white", normalColor));
                }
            }
        });

        buttonGroup.add(rowButton);

        add(rowButton).expandX().fillX().height(ROW_HEIGHT).padBottom(2).row();
    }

    private Image createServerIcon(ServerConnectionConfig server) {
        String iconPath = server.getIconPath();
        if (iconPath == null || iconPath.trim().isEmpty() || !new File(iconPath).exists()) {
            iconPath = DEFAULT_ICON_PATH;
        }
        return new Image(new Texture(Gdx.files.internal(iconPath)));
    }

    private String getMotd(ServerConnectionConfig server) {
        String motd = server.getMotd();
        return (motd == null || motd.trim().isEmpty()) ? DEFAULT_MOTD : motd;
    }

    public void setServers(List<ServerConnectionConfig> newServers) {
        servers.clear();
        servers.addAll(newServers);
        selected = null;
        rebuild();
    }
}

================
File: main/java/io.github.minemon/core/screen/SettingsScreen.java
================
package io.github.minemon.core.screen;

import com.badlogic.gdx.*;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.minemon.audio.service.AudioService;
import io.github.minemon.core.service.BackgroundService;
import io.github.minemon.core.service.ScreenManager;
import io.github.minemon.core.service.SettingsService;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class SettingsScreen implements Screen {
    private final ScreenManager screenManager;
    private final SettingsService settingsService;
    private final BackgroundService backgroundService;

    private Stage stage;
    private Skin skin;
    private Window settingsWindow;
    private boolean isGameScreen;
    @Autowired
    private AudioService audioService;

    @Override
    public void show() {
        stage = new Stage(new ScreenViewport());
        skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));


        isGameScreen = screenManager.getPreviousScreen() instanceof GameScreen;

        createSettingsWindow();


        InputMultiplexer multiplexer = new InputMultiplexer();
        multiplexer.addProcessor(stage);
        multiplexer.addProcessor(new InputAdapter() {
            @Override
            public boolean keyDown(int keycode) {
                if (keycode == Input.Keys.ESCAPE) {
                    goBack();
                    return true;
                }
                return false;
            }
        });
        Gdx.input.setInputProcessor(multiplexer);
    }

    private void createSettingsWindow() {
        settingsWindow = new Window("Settings", skin);
        settingsWindow.setMovable(false);
        settingsWindow.setKeepWithinStage(true);

        Table content = new Table(skin);
        content.defaults().pad(5).spaceBottom(10);


        content.add("Audio Settings").colspan(2).align(Align.left).row();
        addVolumeSlider(content, "Music Volume", settingsService.getMusicVolume(),
            settingsService::updateMusicVolume);
        addVolumeSlider(content, "Sound Volume", settingsService.getSoundVolume(),
            settingsService::updateSoundVolume);

        content.add().row();


        content.add("Video Settings").colspan(2).align(Align.left).row();
        addCheckbox(content, "VSync", settingsService.getVSync(),
            settingsService::updateVSync);
        addCheckbox(content, "Particles", settingsService.getSettings().isParticles(),
            settingsService::updateParticles);
        addCheckbox(content, "Smooth Lighting", settingsService.getSettings().isSmoothLighting(),
            settingsService::updateSmoothLighting);


        content.add("Controls").colspan(2).align(Align.left).row();
        addKeyBinding(content, "Move Up", "UP");
        addKeyBinding(content, "Move Down", "DOWN");
        addKeyBinding(content, "Move Left", "LEFT");
        addKeyBinding(content, "Move Right", "RIGHT");
        addKeyBinding(content, "Run", "RUN");


        TextButton doneButton = new TextButton("Done", skin);
        doneButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                goBack();
            }
        });
        content.add(doneButton).colspan(2).width(200).pad(20).row();

        settingsWindow.add(content).pad(20);
        settingsWindow.pack();


        settingsWindow.setPosition(
            (Gdx.graphics.getWidth() - settingsWindow.getWidth()) / 2,
            (Gdx.graphics.getHeight() - settingsWindow.getHeight()) / 2
        );

        stage.addActor(settingsWindow);
    }

    private void addVolumeSlider(Table table, String label, float initialValue,
                                 VolumeChangeListener listener) {
        table.add(label).left();
        Slider slider = new Slider(0, 1, 0.01f, false, skin);
        slider.setValue(initialValue);
        slider.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                float newValue = slider.getValue();
                // 1) Update SettingsService
                listener.onVolumeChanged(newValue);

                // 2) Also update the AudioService instantly
                if ("Music Volume".equals(label)) {
                    audioService.setMusicVolume(newValue);
                } else if ("Sound Volume".equals(label)) {
                    audioService.setSoundVolume(newValue);
                }
            }
        });
        table.add(slider).width(200).row();
    }


    private void addCheckbox(Table table, String label, boolean initialValue,
                             CheckboxChangeListener listener) {
        CheckBox checkbox = new CheckBox(" " + label, skin);
        checkbox.setChecked(initialValue);
        checkbox.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                listener.onCheckboxChanged(checkbox.isChecked());
            }
        });
        table.add(checkbox).colspan(2).left().row();
    }

    private void addKeyBinding(Table table, String label, String binding) {
        table.add(label).left();
        TextButton bindButton = new TextButton(
            Input.Keys.toString(settingsService.getKeyBindings().get(binding)),
            skin
        );

        bindButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                startKeyBinding(bindButton, binding);
            }
        });

        table.add(bindButton).width(100).row();
    }

    private void startKeyBinding(TextButton button, String binding) {
        button.setText("Press any key...");
        stage.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if (keycode != Input.Keys.ESCAPE) {
                    settingsService.setKeyBinding(binding, keycode);
                    button.setText(Input.Keys.toString(keycode));
                }
                stage.removeListener(this);
                return true;
            }
        });
    }

    private void goBack() {
        if (isGameScreen) {
            screenManager.goBack();
        } else {
            screenManager.showScreen(ModeSelectionScreen.class);
        }
    }

    @Override
    public void render(float delta) {
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);


        backgroundService.render(isGameScreen);

        stage.act(delta);
        stage.draw();
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
        settingsWindow.setPosition(
            (width - settingsWindow.getWidth()) / 2,
            (height - settingsWindow.getHeight()) / 2
        );
    }

    @Override
    public void pause() {

    }

    @Override
    public void resume() {

    }

    @Override
    public void hide() {
        Gdx.input.setInputProcessor(null);
    }

    @Override
    public void dispose() {
        stage.dispose();
        skin.dispose();
    }

    private interface VolumeChangeListener {
        void onVolumeChanged(float value);
    }

    private interface CheckboxChangeListener {
        void onCheckboxChanged(boolean value);
    }
}

================
File: main/java/io.github.minemon/core/screen/WorldSelectionScreen.java
================
package io.github.minemon.core.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.Scaling;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.minemon.audio.service.AudioService;
import io.github.minemon.core.service.ScreenManager;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.world.model.WorldData;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Random;

@Component
@Slf4j
public class WorldSelectionScreen implements Screen {
    private final AudioService audioService;
    private final WorldService worldService;
    private final ScreenManager screenManager;

    @Value("${world.saveDir:save/worlds/}")
    private String saveDir;

    private Stage stage;
    private Skin skin;
    private Table worldListTable;
    private String selectedWorldName;

    private Table infoPanel;
    private TextButton playButton;
    private TextButton deleteButton;
    private float fontScale;
    @Autowired
    @Lazy
    private MultiplayerClient multiplayerClient;

    @Autowired
    public WorldSelectionScreen(AudioService audioService,
                                WorldService worldService,
                                ScreenManager screenManager) {
        this.audioService = audioService;
        this.worldService = worldService;
        this.screenManager = screenManager;
    }

    @Override
    public void show() {
        worldService.setMultiplayerMode(false);
        if (multiplayerClient != null && multiplayerClient.isConnected()) {
            multiplayerClient.disconnect();
        }
        audioService.playMenuMusic();

        stage = new Stage(new ScreenViewport());
        Gdx.input.setInputProcessor(stage);
        skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));

        createUI();
        refreshWorldList();
    }

    private void createUI() {

        float width = Gdx.graphics.getWidth();
        float height = Gdx.graphics.getHeight();
        float maxUIWidth = 1400f;
        float maxUIHeight = 900f;



        fontScale = MathUtils.clamp(Math.min(width, height) / 900f, 0.8f, 1.5f);


        Table rootContainer = new Table(skin);
        rootContainer.setFillParent(true);
        stage.addActor(rootContainer);


        rootContainer.setBackground(skin.newDrawable("white", 0.1f,0.1f,0.1f,1f));


        Table mainTable = new Table(skin);
        mainTable.defaults().pad(10 * fontScale);
        rootContainer.add(mainTable)
                .width(Math.min(width * 0.9f, maxUIWidth))
                .height(Math.min(height * 0.9f, maxUIHeight))
                .center();


        Label titleLabel = new Label("Select World", skin);
        titleLabel.setFontScale(1.5f * fontScale);
        mainTable.add(titleLabel).colspan(2).padBottom(20 * fontScale).center().row();


        worldListTable = new Table(skin);
        worldListTable.top().defaults().pad(5 * fontScale);

        ScrollPane scrollPane = new ScrollPane(worldListTable, skin);
        scrollPane.setFadeScrollBars(false);
        scrollPane.setScrollingDisabled(true, false);


        Table worldListContainer = new Table(skin);
        worldListContainer.setBackground(skin.newDrawable("white", 0.15f,0.15f,0.15f,1f));
        worldListContainer.add(scrollPane).expand().fill();

        infoPanel = new Table(skin);
        infoPanel.defaults().left().pad(5 * fontScale);
        infoPanel.setBackground(skin.newDrawable("white", 0.15f,0.15f,0.15f,1f));
        infoPanel.add(new Label("Select a world to view details", skin)).expand().fill();

        Table contentTable = new Table(skin);
        float contentWidth = Math.min((Math.min(width, maxUIWidth)) * 0.9f, 1200f);
        float infoPanelWidth = Math.min(contentWidth * 0.35f, 350f);
        float worldListWidth = Math.min(contentWidth * 0.6f, 600f);

        contentTable.add(worldListContainer).expandY().fillY().width(worldListWidth).padRight(20 * fontScale);
        contentTable.add(infoPanel).expandY().fillY().width(infoPanelWidth);

        mainTable.add(contentTable).colspan(2).expand().fill().row();


        TextButton createButton = new TextButton("Create New World", skin);
        playButton = new TextButton("Play Selected World", skin);
        deleteButton = new TextButton("Delete World", skin);
        TextButton backButton = new TextButton("Back", skin);


        createButton.getLabel().setFontScale(fontScale);
        playButton.getLabel().setFontScale(fontScale);
        deleteButton.getLabel().setFontScale(fontScale);
        backButton.getLabel().setFontScale(fontScale);


        playButton.setDisabled(true);
        deleteButton.setDisabled(true);


        createButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                showCreateWorldDialog();
            }
        });

        playButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (selectedWorldName != null) {
                    log.debug("PLAY requested for world '{}'", selectedWorldName);
                    worldService.loadWorld(selectedWorldName);
                    screenManager.showScreen(GameScreen.class);
                }
            }
        });


        deleteButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (selectedWorldName != null) {
                    showDeleteConfirmDialog();
                }
            }
        });

        backButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                screenManager.goBack();
            }
        });

        Table buttonTable = new Table(skin);
        buttonTable.defaults().pad(10 * fontScale);
        buttonTable.add(createButton);
        buttonTable.add(playButton);
        buttonTable.add(deleteButton);
        buttonTable.row();
        buttonTable.add(backButton).colspan(3).center().padTop(10 * fontScale);

        mainTable.row();
        mainTable.add(buttonTable).colspan(2).padTop(20 * fontScale).center();
    }

    private void showDeleteConfirmDialog() {
        if (selectedWorldName == null) return;
        Dialog dialog = new Dialog("Delete World", skin) {
            @Override
            protected void result(Object object) {
                if ((Boolean) object) {

                    worldService.deleteWorld(selectedWorldName);
                    refreshWorldList();
                    selectedWorldName = null;
                    updateInfoPanel(null);
                    updateButtonsState();
                }
            }
        };
        dialog.text("Are you sure you want to delete world '" + selectedWorldName + "'?\nThis action cannot be undone!");
        dialog.button("Delete", true);
        dialog.button("Cancel", false);
        dialog.show(stage);
    }

    private Table createWorldEntry(final String worldName) {
        Table entry = new Table(skin);
        entry.setBackground(skin.newDrawable("white", 0.1f,0.1f,0.1f,1f));

        WorldData meta = loadWorldMetadata(worldName);

        FileHandle iconFile = Gdx.files.local(saveDir + worldName + "/icon.png");
        Image icon;
        if (iconFile.exists()) {
            Texture tex = new Texture(iconFile);
            icon = new Image(new TextureRegion(tex));
        } else {

            FileHandle fallbackFile = Gdx.files.internal("icons/default_world_icon.png");
            Texture fallback = new Texture(fallbackFile);
            icon = new Image(new TextureRegion(fallback));
        }

        icon.setScaling(Scaling.fit);
        float iconSize = 64f * fontScale;
        entry.add(icon).size(iconSize, iconSize).pad(10 * fontScale);

        Table infoTable = new Table(skin);
        Label nameLabel = new Label(worldName, skin);
        nameLabel.setFontScale(fontScale);

        Label createdLabel = new Label("Created: " + formatDate(meta.getCreatedDate()), skin);
        createdLabel.setFontScale(fontScale);

        Label lastPlayedLabel = new Label("Last Played: " + formatDate(meta.getLastPlayed()), skin);
        lastPlayedLabel.setFontScale(fontScale);

        Label playedTimeLabel = new Label("Played Time: " + formatPlayedTime(meta.getPlayedTime()), skin);
        playedTimeLabel.setFontScale(fontScale);

        infoTable.add(nameLabel).left().row();
        infoTable.add(createdLabel).left().row();
        infoTable.add(lastPlayedLabel).left().row();
        infoTable.add(playedTimeLabel).left().row();

        entry.add(infoTable).expand().fill().pad(10 * fontScale);

        entry.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                selectedWorldName = worldName;
                highlightSelectedEntry(entry);
                updateInfoPanel(meta);
                updateButtonsState();
            }
        });
        return entry;
    }

    private void highlightSelectedEntry(Table selectedEntry) {
        for (Actor actor : worldListTable.getChildren()) {
            if (actor instanceof Table t) {
                t.setBackground(skin.newDrawable("white", 0.1f,0.1f,0.1f,1f));
            }
        }
        selectedEntry.setBackground(skin.newDrawable("white", 0.3f,0.6f,1f,1f));
    }

    private WorldData loadWorldMetadata(String worldName) {
        FileHandle worldFile = Gdx.files.local(saveDir + worldName + "/" + worldName + ".json");
        if (!worldFile.exists()) {
            WorldData wd = new WorldData();
            wd.setWorldName(worldName);
            wd.setSeed(0);
            wd.setCreatedDate(0);
            wd.setLastPlayed(0);
            wd.setPlayedTime(0);
            return wd;
        }
        Json json = new Json();
        return json.fromJson(WorldData.class, worldFile.readString());
    }

    private String formatPlayedTime(long millis) {
        long seconds = millis / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;
        seconds %= 60;
        minutes %= 60;
        return String.format("%02dh %02dm %02ds", hours, minutes, seconds);
    }

    private String formatDate(long timestamp) {
        if (timestamp == 0) return "Never";
        return new SimpleDateFormat("MMM d, yyyy HH:mm").format(new Date(timestamp));
    }

    private void refreshWorldList() {
        worldListTable.clear();
        List<String> worldNames = worldService.getAvailableWorlds();
        for (String worldName : worldNames) {
            Table entry = createWorldEntry(worldName);
            worldListTable.add(entry).expandX().fillX().row();
        }
        selectedWorldName = null;
        updateButtonsState();
        updateInfoPanel(null);
    }

    private void updateButtonsState() {
        boolean hasSelection = selectedWorldName != null;
        playButton.setDisabled(!hasSelection);
        deleteButton.setDisabled(!hasSelection);
    }private void showCreateWorldDialog() {
        Dialog dialog = new Dialog("Create New World", skin) {
            @Override
            protected void result(Object object) {
                if ((Boolean) object) {
                    TextField nameField = findActor("worldNameField");
                    TextField seedField = findActor("seedField");

                    String worldName = nameField.getText().trim();
                    if (worldName.isEmpty()) {
                        showErrorDialog("World name cannot be empty");
                        return;
                    }

                    long seed;
                    String seedText = seedField.getText().trim();
                    if (seedText.isEmpty()) {
                        seed = new Random().nextLong();
                    } else {
                        try {
                            seed = Long.parseLong(seedText);
                        } catch (NumberFormatException e) {
                            showErrorDialog("Seed must be a valid number");
                            return;
                        }
                    }

                    boolean success = worldService.createWorld(worldName, seed);
                    if (!success) {
                        showErrorDialog("Failed to create the world. The name might already exist or another error occurred.");
                        return;
                    }


                    worldService.generateWorldThumbnail(worldName);

                    refreshWorldList();
                    selectedWorldName = worldName;
                    highlightNewlyCreatedEntry(worldName);
                    updateButtonsState();
                    updateInfoPanel(loadWorldMetadata(worldName));
                }
            }
        };

        dialog.getContentTable().pad(10 * fontScale);

        Label worldNameLabel = new Label("World Name:", skin);
        worldNameLabel.setFontScale(fontScale);
        dialog.getContentTable().add(worldNameLabel).left().row();

        TextField nameField = new TextField("", skin);
        nameField.setName("worldNameField");
        nameField.setMessageText("Enter world name");
        dialog.getContentTable().add(nameField).width(300 * fontScale).padBottom(10 * fontScale).row();

        Label seedLabel = new Label("Seed (optional):", skin);
        seedLabel.setFontScale(fontScale);
        dialog.getContentTable().add(seedLabel).left().row();

        TextField seedField = new TextField("", skin);
        seedField.setName("seedField");
        seedField.setMessageText("Enter seed or leave empty");
        dialog.getContentTable().add(seedField).width(300 * fontScale).padBottom(10 * fontScale).row();

        dialog.button("Create", true);
        dialog.button("Cancel", false);
        dialog.key(Input.Keys.ENTER, true);
        dialog.key(Input.Keys.ESCAPE, false);

        dialog.show(stage);
    }


    private void highlightNewlyCreatedEntry(String worldName) {
        for (Actor actor : worldListTable.getChildren()) {
            if (actor instanceof Table entry) {
                Label nameLabel = findNameLabel(entry);
                if (nameLabel != null && worldName.equals(nameLabel.getText().toString())) {
                    highlightSelectedEntry(entry);
                    break;
                }
            }
        }
    }

    private Label findNameLabel(Table entry) {
        for (Actor child : entry.getChildren()) {
            if (child instanceof Table infoTable) {
                for (Actor infoChild : infoTable.getChildren()) {
                    if (infoChild instanceof Label label) {
                        return label;
                    }
                }
            }
        }
        return null;
    }

    private void updateInfoPanel(WorldData meta) {
        infoPanel.clear();
        if (meta == null) {
            Label prompt = new Label("Select a world to view details", skin);
            prompt.setFontScale(fontScale);
            infoPanel.add(prompt).expand().fill();
            return;
        }

        infoPanel.defaults().left().pad(5 * fontScale);
        Label nameLabel = new Label(meta.getWorldName(), skin);
        nameLabel.setFontScale(1.2f * fontScale);
        infoPanel.add(nameLabel).expandX().row();

        Label created = new Label("Created: " + formatDate(meta.getCreatedDate()), skin);
        created.setFontScale(fontScale);
        infoPanel.add(created).row();

        Label lastPlayed = new Label("Last Played: " + formatDate(meta.getLastPlayed()), skin);
        lastPlayed.setFontScale(fontScale);
        infoPanel.add(lastPlayed).row();

        Label playedTime = new Label("Played Time: " + formatPlayedTime(meta.getPlayedTime()), skin);
        playedTime.setFontScale(fontScale);
        infoPanel.add(playedTime).row();
    }

    private void showErrorDialog(String message) {
        Dialog errorDialog = new Dialog("Error", skin);
        errorDialog.text(message);
        errorDialog.button("OK");
        errorDialog.show(stage);
    }

    @Override
    public void render(float delta) {
        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            screenManager.goBack();
        }

        Gdx.gl.glClearColor(0.15f,0.15f,0.15f,1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        stage.act(delta);
        stage.draw();
        audioService.update(delta);
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
    }

    @Override
    public void pause() {}

    @Override
    public void resume() {}

    @Override
    public void hide() {
        audioService.stopMenuMusic();
    }

    @Override
    public void dispose() {
        stage.dispose();
        skin.dispose();
    }
}

================
File: main/java/io.github.minemon/core/service/BackgroundService.java
================
package io.github.minemon.core.service;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.math.Matrix4;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Slf4j
@Service
public class BackgroundService {
    private SpriteBatch batch;
    private TextureRegion backgroundTexture;
    private ShaderProgram shader;
    private float time;
    private Matrix4 transform;
    private boolean useShader = true;

    public void initialize() {
        batch = new SpriteBatch();
        OrthographicCamera camera = new OrthographicCamera();
        camera.setToOrtho(false);
        transform = new Matrix4();


        try {
            shader = new ShaderProgram(
                    Gdx.files.internal("shaders/menu_background.vert"),
                    Gdx.files.internal("shaders/menu_background.frag")
            );

            if (!shader.isCompiled()) {
                log.error("Shader compilation failed: {}", shader.getLog());
                useShader = false;
            }
        } catch (Exception e) {
            log.error("Failed to load shader", e);
            useShader = false;
        }


        try {
            Texture bgTexture = new Texture(Gdx.files.internal("Textures/UI/ethereal.png"));
            backgroundTexture = new TextureRegion(bgTexture);
        } catch (Exception e) {
            log.error("Failed to load background texture", e);
        }
    }

    public void update(float delta) {
        time += delta * 0.02f;
        if (useShader) {
            transform.setToRotation(0, 1, 0, time * 15);
        }
    }

    public void render(boolean transparent) {
        if (backgroundTexture == null) return;

        batch.begin();
        if (transparent) {
            batch.setColor(1, 1, 1, 0.5f);
        }

        batch.draw(backgroundTexture,
                0, 0,
                Gdx.graphics.getWidth(),
                Gdx.graphics.getHeight()
        );

        if (transparent) {
            batch.setColor(Color.WHITE);
        }
        batch.end();
    }

    public void dispose() {
        if (batch != null) batch.dispose();
        if (shader != null) shader.dispose();
        if (backgroundTexture != null) backgroundTexture.getTexture().dispose();
    }
}

================
File: main/java/io.github.minemon/core/service/FileAccessService.java
================
package io.github.minemon.core.service;

public interface FileAccessService {
    boolean exists(String path);
    String readFile(String path);
    void writeFile(String path, String content);
}

================
File: main/java/io.github.minemon/core/service/impl/LocalFileAccessService.java
================
package io.github.minemon.core.service.impl;

import io.github.minemon.core.service.FileAccessService;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@Service
public class LocalFileAccessService implements FileAccessService {

    @Override
    public boolean exists(String path) {
        Path p = Paths.get(path);
        return Files.exists(p);
    }

    @Override
    public String readFile(String path) {
        try {
            Path p = Paths.get(path);
            if (!Files.exists(p)) {
                throw new RuntimeException("File not found: " + path);
            }
            return Files.readString(p, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException("Error reading file " + path + ": " + e.getMessage(), e);
        }
    }

    @Override
    public void writeFile(String path, String content) {
        try {
            Path p = Paths.get(path);
            Files.writeString(p, content, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException("Error writing file " + path + ": " + e.getMessage(), e);
        }
    }
}

================
File: main/java/io.github.minemon/core/service/impl/ScreenManagerImpl.java
================
package io.github.minemon.core.service.impl;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import io.github.minemon.core.service.ScreenManager;
import jakarta.annotation.PreDestroy;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;
import java.util.Stack;

@Service
@Primary
public class ScreenManagerImpl implements ScreenManager {
    private final ApplicationContext applicationContext;
    private final Game game;
    private final Stack<Class<? extends Screen>> screenHistory = new Stack<>();
    private Screen previousScreen;

    @Override
    @SuppressWarnings("unchecked")
    public <T extends Screen> T getScreen(Class<T> screenClass) {
        // Get cached screen or create new one
        return (T) screenCache.computeIfAbsent(screenClass,
            clazz -> applicationContext.getBean(screenClass));
    }
    private final Map<Class<? extends Screen>, Screen> screenCache = new HashMap<>();

    // Clean up method - call this when shutting down
    @PreDestroy
    public void dispose() {
        screenCache.values().forEach(screen -> {
            if (screen != null) {
                screen.dispose();
            }
        });
        screenCache.clear();
    }
    @Autowired
    public ScreenManagerImpl(ApplicationContext applicationContext, Game game) {
        this.applicationContext = applicationContext;
        this.game = game;
    }

    @Override
    public void showScreen(Class<? extends Screen> screenClass) {
        screenHistory.push(screenClass);
        previousScreen = game.getScreen();
        Screen newScreen = getScreen(screenClass);
        System.out.println("ScreenManager.showScreen -> about to set " + newScreen);
        Gdx.app.postRunnable(() -> game.setScreen(newScreen));
    }

    @Override
    public void goBack() {
        Gdx.app.postRunnable(() -> {
            if (screenHistory.size() <= 1) return;
            screenHistory.pop();
            Class<? extends Screen> previous = screenHistory.peek();
            Screen newScreen = applicationContext.getBean(previous);
            previousScreen = game.getScreen();
            game.setScreen(newScreen);
        });
    }

    @Override
    public Screen getPreviousScreen() {
        return previousScreen;
    }
}

================
File: main/java/io.github.minemon/core/service/impl/SpringFileAccessService.java
================
package io.github.minemon.core.service.impl;

import io.github.minemon.core.service.FileAccessService;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@Service
@Primary
public class SpringFileAccessService implements FileAccessService {

    public SpringFileAccessService() {
    }

    @Override
    public boolean exists(String path) {
        Path p = Paths.get(path).toAbsolutePath();
        return Files.exists(p);
    }

    @Override
    public String readFile(String path) {
        Path p = Paths.get(path).toAbsolutePath();
        try {
            if (!Files.exists(p)) {
                throw new RuntimeException("File not found: " + path);
            }
            return Files.readString(p, StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new RuntimeException("Failed to read file " + path + ": " + e.getMessage(), e);
        }
    }

    @Override
    public void writeFile(String path, String content) {
        Path p = Paths.get(path).toAbsolutePath();
        try {
            if (p.getParent() != null) {
                Files.createDirectories(p.getParent());
            }
            Files.writeString(p, content, StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new RuntimeException("Failed to write file: " + path, e);
        }
    }
}

================
File: main/java/io.github.minemon/core/service/ScreenManager.java
================
package io.github.minemon.core.service;

import com.badlogic.gdx.Screen;

public interface ScreenManager {
    void showScreen(Class<? extends Screen> screenClass);
    void goBack();
    Screen getPreviousScreen();
    <T extends Screen> T getScreen(Class<T> screenClass);
}

================
File: main/java/io.github.minemon/core/service/SettingsService.java
================
package io.github.minemon.core.service;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Preferences;
import io.github.minemon.core.config.GameSettings;
import io.github.minemon.input.InputConfiguration;
import io.github.minemon.player.model.PlayerDirection;
import lombok.Getter;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;

@Service
public class SettingsService {
    private static final String PREFS_NAME = "pokemeetup_settings";
    private final InputConfiguration inputConfig;
    private final float DEFAULT_MUSIC_VOLUME = 0.7f;
    private final float DEFAULT_SOUND_VOLUME = 1.0f;
    private final boolean DEFAULT_VSYNC = true;
    private final int DEFAULT_RENDER_DISTANCE = 12;
    private final boolean DEFAULT_PARTICLES = true;
    private final boolean DEFAULT_SMOOTH_LIGHTING = true;
    private Preferences prefs;
    private GameSettings currentSettings;
    private boolean initialized = false;
    @Getter
    private Map<String, Integer> keyBindings;

    public SettingsService(InputConfiguration inputConfig) {
        this.inputConfig = inputConfig;
        this.keyBindings = new HashMap<>();
        initializeDefaultKeyBindings();
        createDefaultSettings();
    }

    private void initializeDefaultKeyBindings() {
        keyBindings.put("UP", Input.Keys.W);
        keyBindings.put("DOWN", Input.Keys.S);
        keyBindings.put("LEFT", Input.Keys.A);
        keyBindings.put("RIGHT", Input.Keys.D);
        keyBindings.put("RUN", Input.Keys.Z);
        updateInputConfiguration();
    }

    private void createDefaultSettings() {
        currentSettings = new GameSettings();
        currentSettings.setMusicVolume(DEFAULT_MUSIC_VOLUME);
        currentSettings.setSoundVolume(DEFAULT_SOUND_VOLUME);
        currentSettings.setVSync(DEFAULT_VSYNC);
        currentSettings.setRenderDistance(DEFAULT_RENDER_DISTANCE);
        currentSettings.setParticles(DEFAULT_PARTICLES);
        currentSettings.setSmoothLighting(DEFAULT_SMOOTH_LIGHTING);
    }

    public void initialize() {
        if (initialized || Gdx.app == null) return;

        prefs = Gdx.app.getPreferences(PREFS_NAME);
        loadAllSettings();
        initialized = true;
    }

    private void loadAllSettings() {

        currentSettings.setMusicVolume(prefs.getFloat("music_volume", DEFAULT_MUSIC_VOLUME));
        currentSettings.setSoundVolume(prefs.getFloat("sound_volume", DEFAULT_SOUND_VOLUME));
        currentSettings.setVSync(prefs.getBoolean("vsync", DEFAULT_VSYNC));
        currentSettings.setRenderDistance(prefs.getInteger("render_distance", DEFAULT_RENDER_DISTANCE));
        currentSettings.setParticles(prefs.getBoolean("particles", DEFAULT_PARTICLES));
        currentSettings.setSmoothLighting(prefs.getBoolean("smooth_lighting", DEFAULT_SMOOTH_LIGHTING));


        keyBindings.put("UP", prefs.getInteger("key_up", Input.Keys.W));
        keyBindings.put("DOWN", prefs.getInteger("key_down", Input.Keys.S));
        keyBindings.put("LEFT", prefs.getInteger("key_left", Input.Keys.A));
        keyBindings.put("RIGHT", prefs.getInteger("key_right", Input.Keys.D));
        keyBindings.put("RUN", prefs.getInteger("key_run", Input.Keys.Z));

        updateInputConfiguration();
    }

    private void updateInputConfiguration() {
        Map<Integer, PlayerDirection> newMovementKeys = new HashMap<>();
        newMovementKeys.put(keyBindings.get("UP"), PlayerDirection.UP);
        newMovementKeys.put(keyBindings.get("DOWN"), PlayerDirection.DOWN);
        newMovementKeys.put(keyBindings.get("LEFT"), PlayerDirection.LEFT);
        newMovementKeys.put(keyBindings.get("RIGHT"), PlayerDirection.RIGHT);
        inputConfig.setMovementKeys(newMovementKeys);
        inputConfig.setRunKey(keyBindings.get("RUN"));
    }

    public GameSettings getSettings() {
        return currentSettings;
    }

    public void updateMusicVolume(float volume) {
        if (initialized && prefs != null) {
            prefs.putFloat("music_volume", volume);
            prefs.flush();
        }
        currentSettings.setMusicVolume(volume);
    }

    public void updateSoundVolume(float volume) {
        if (initialized && prefs != null) {
            prefs.putFloat("sound_volume", volume);
            prefs.flush();
        }
        currentSettings.setSoundVolume(volume);
    }

    public void updateVSync(boolean enabled) {
        if (initialized && prefs != null) {
            prefs.putBoolean("vsync", enabled);
            prefs.flush();
            Gdx.graphics.setVSync(enabled);
        }
        currentSettings.setVSync(enabled);
    }

    public void updateRenderDistance(int distance) {
        if (initialized && prefs != null) {
            prefs.putInteger("render_distance", distance);
            prefs.flush();
        }
        currentSettings.setRenderDistance(distance);
    }

    public void updateParticles(boolean enabled) {
        if (initialized && prefs != null) {
            prefs.putBoolean("particles", enabled);
            prefs.flush();
        }
        currentSettings.setParticles(enabled);
    }

    public void updateSmoothLighting(boolean enabled) {
        if (initialized && prefs != null) {
            prefs.putBoolean("smooth_lighting", enabled);
            prefs.flush();
        }
        currentSettings.setSmoothLighting(enabled);
    }

    public void setKeyBinding(String action, int keycode) {
        keyBindings.put(action, keycode);
        if (initialized && prefs != null) {
            prefs.putInteger("key_" + action.toLowerCase(), keycode);
            prefs.flush();
        }
        updateInputConfiguration();
    }

    public float getMusicVolume() {
        if (initialized && prefs != null) {
            return prefs.getFloat("music_volume", currentSettings.getMusicVolume());
        }
        return currentSettings.getMusicVolume();
    }

    public void setMusicVolume(float volume) {
        if (initialized && prefs != null) {
            prefs.putFloat("music_volume", volume);
            prefs.flush();
        }
        currentSettings.setMusicVolume(volume);
    }

    public float getSoundVolume() {
        if (initialized && prefs != null) {
            return prefs.getFloat("sound_volume", currentSettings.getSoundVolume());
        }
        return currentSettings.getSoundVolume();
    }

    public void setSoundVolume(float volume) {
        if (initialized && prefs != null) {
            prefs.putFloat("sound_volume", volume);
            prefs.flush();
        }
        currentSettings.setSoundVolume(volume);
    }

    public boolean getVSync() {
        if (initialized && prefs != null) {
            return prefs.getBoolean("vsync", currentSettings.isVSync());
        }
        return currentSettings.isVSync();
    }

    public void setVSync(boolean enabled) {
        if (initialized && prefs != null) {
            prefs.putBoolean("vsync", enabled);
            prefs.flush();
            Gdx.graphics.setVSync(enabled);
        }
        currentSettings.setVSync(enabled);
    }
}

================
File: main/java/io.github.minemon/core/service/UiService.java
================
package io.github.minemon.core.service;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import io.github.minemon.core.ui.DialogFactory;
import io.github.minemon.core.ui.StyleFactory;
import lombok.Getter;
import org.springframework.stereotype.Service;

@Getter
@Service
public class UiService {
    private static final String UI_SKIN_PATH = "Skins/uiskin.json";
    private Skin skin;
    private DialogFactory dialogFactory;
    private StyleFactory styleFactory;

    public void initialize() {
        if (skin != null) {
            return;
        }

        skin = new Skin(Gdx.files.internal(UI_SKIN_PATH));
        dialogFactory = new DialogFactory(skin);
        styleFactory = new StyleFactory();
    }

    public void dispose() {
        if (skin != null) {
            skin.dispose();
            skin = null;
        }
    }
}

================
File: main/java/io.github.minemon/core/ui/DialogCloseListener.java
================
package io.github.minemon.core.ui;

import com.badlogic.gdx.scenes.scene2d.Event;
import com.badlogic.gdx.scenes.scene2d.EventListener;

public interface DialogCloseListener extends EventListener {
    void onClose();

    @Override
    default boolean handle(Event event) {
        return false;
    }
}

================
File: main/java/io.github.minemon/core/ui/DialogFactory.java
================
package io.github.minemon.core.ui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.utils.Align;
import lombok.Setter;

public class DialogFactory {
    private static final float DIALOG_PADDING = 20f;

    private final Skin skin;
    @Setter
    private Stage stage;

    public DialogFactory(Skin skin) {
        this.skin = skin;
    }

    public void showWarning(String title, String message) {
        if (stage == null) return;
        createDialog(title, message, DialogType.WARNING);
    }

    public void showError(String title, String message) {
        if (stage == null) return;
        createDialog(title, message, DialogType.ERROR);
    }

    public void showSuccess(String title, String message) {
        if (stage == null) return;
        createDialog(title, message, DialogType.SUCCESS);
    }

    public Dialog showLoading(String message) {
        if (stage == null) return null;
        Dialog dialog = new Dialog("", skin);
        dialog.pad(DIALOG_PADDING);

        Table content = new Table(skin);
        Label messageLabel = new Label(message, skin);
        messageLabel.setWrap(true);
        content.add(messageLabel).pad(10f).width(300f);
        content.row();
        content.add(new ProgressBar(0, 1, 0.01f, false, skin)).width(200f);

        dialog.getContentTable().add(content);
        dialog.setModal(true);
        dialog.show(stage);
        return dialog;
    }

    public void showConfirmation(String title, String message, Runnable onConfirm) {
        if (stage == null) return;
        Dialog dialog = new Dialog(title, skin);
        dialog.pad(DIALOG_PADDING);

        Label messageLabel = new Label(message, skin);
        messageLabel.setWrap(true);
        Cell<?> cell = dialog.getContentTable().add(messageLabel).pad(10f);
        cell.width(300f);

        TextButton confirmButton = new TextButton("Confirm", skin);
        TextButton cancelButton = new TextButton("Cancel", skin);

        confirmButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                onConfirm.run();
                dialog.hide();
            }
        });

        cancelButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                dialog.hide();
            }
        });

        Table buttonTable = new Table();
        buttonTable.add(confirmButton).pad(5).width(100f);
        buttonTable.add(cancelButton).pad(5).width(100f);

        dialog.getButtonTable().add(buttonTable);
        dialog.setModal(true);

        centerDialog(dialog);
        dialog.show(stage);
    }

    private void createDialog(String title, String message, DialogType type) {
        Dialog dialog = new Dialog(title, skin);
        dialog.pad(DIALOG_PADDING);

        Table content = new Table(skin);
        content.add(createIcon(type)).pad(10f).size(32);

        Label messageLabel = new Label(message, skin);
        messageLabel.setWrap(true);
        messageLabel.setAlignment(Align.left);
        content.add(messageLabel).pad(10f).width(300f);

        dialog.getContentTable().add(content);

        TextButton okButton = new TextButton("OK", skin);
        okButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                dialog.hide();
            }
        });

        dialog.getButtonTable().add(okButton).width(100f);
        dialog.setModal(true);

        centerDialog(dialog);
        dialog.show(stage);
    }

    private void centerDialog(Dialog dialog) {
        dialog.setPosition(
                (stage.getWidth() - dialog.getWidth()) / 2,
                (stage.getHeight() - dialog.getHeight()) / 2
        );
    }

    private Image createIcon(DialogType type) {
        String iconPath = switch (type) {
            case WARNING -> "Textures/UI/warning-icon.png";
            case ERROR -> "Textures/UI/error-icon.png";
            case SUCCESS -> "Textures/UI/success-icon.png";
        };
        return new Image(new Texture(Gdx.files.internal(iconPath)));
    }

    private enum DialogType {
        WARNING,
        ERROR,
        SUCCESS
    }
}

================
File: main/java/io.github.minemon/core/ui/ServerConfigDialog.java
================
package io.github.minemon.core.ui;

import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import io.github.minemon.multiplayer.model.ServerConnectionConfig;
import java.util.function.Consumer;

public class ServerConfigDialog extends Dialog {
    private static final int MIN_PORT = 1024;
    private static final int MAX_PORT = 65535;
    private static final String DEFAULT_IP = "127.0.0.1";
    private static final int DEFAULT_TCP_PORT = 54555;
    private static final int DEFAULT_UDP_PORT = 54777;

    private final DialogFactory dialogFactory;
    private final Consumer<ServerConnectionConfig> onSave;
    private final ServerConnectionConfig existingConfig;

    private TextField nameField;
    private TextField ipField;
    private TextField tcpField;
    private TextField udpField;

    public ServerConfigDialog(Skin skin, DialogFactory dialogFactory,
                              ServerConnectionConfig existingConfig,
                              Consumer<ServerConnectionConfig> onSave) {
        super(existingConfig == null ? "Add Server" : "Edit Server", skin);
        this.dialogFactory = dialogFactory;
        this.existingConfig = existingConfig;
        this.onSave = onSave;

        createContent();
        createButtons();
    }

    private void createContent() {
        Table content = new Table(getSkin());
        content.pad(20);


        content.add("Server Name:").left().padRight(10);
        nameField = new TextField(getExistingValue(ServerConnectionConfig::getServerName, ""), getSkin());
        content.add(nameField).width(250).left().row();


        content.add("IP Address:").left().padRight(10).padTop(10);
        ipField = new TextField(getExistingValue(ServerConnectionConfig::getServerIP, DEFAULT_IP), getSkin());
        content.add(ipField).width(250).left().row();


        content.add("TCP Port:").left().padRight(10).padTop(10);
        tcpField = new TextField(getExistingValue(
                config -> String.valueOf(config.getTcpPort()),
                String.valueOf(DEFAULT_TCP_PORT)),
                getSkin());
        content.add(tcpField).width(250).left().row();


        content.add("UDP Port:").left().padRight(10).padTop(10);
        udpField = new TextField(getExistingValue(
                config -> String.valueOf(config.getUdpPort()),
                String.valueOf(DEFAULT_UDP_PORT)),
                getSkin());
        content.add(udpField).width(250).left().row();

        getContentTable().add(content);
    }

    private void createButtons() {
        TextButton saveButton = new TextButton("Save", getSkin());
        TextButton cancelButton = new TextButton("Cancel", getSkin());

        saveButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                handleSave();
            }
        });

        cancelButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                hide();
            }
        });

        button(saveButton);
        button(cancelButton);
    }

    private void handleSave() {

        if (nameField.getText().trim().isEmpty()) {
            dialogFactory.showWarning("Invalid Input", "Server name cannot be empty");
            return;
        }

        if (ipField.getText().trim().isEmpty()) {
            dialogFactory.showWarning("Invalid Input", "IP address cannot be empty");
            return;
        }

        try {
            int tcpPort = Integer.parseInt(tcpField.getText().trim());
            int udpPort = Integer.parseInt(udpField.getText().trim());

            if (!isValidPort(tcpPort) || !isValidPort(udpPort)) {
                dialogFactory.showWarning("Invalid Input",
                        "Ports must be between " + MIN_PORT + " and " + MAX_PORT);
                return;
            }

            ServerConnectionConfig config = existingConfig != null ?
                    existingConfig : new ServerConnectionConfig();

            config.setServerName(nameField.getText().trim());
            config.setServerIP(ipField.getText().trim());
            config.setTcpPort(tcpPort);
            config.setUdpPort(udpPort);

            if (existingConfig == null) {

                config.setMotd("Welcome to " + config.getServerName());
                config.setMaxPlayers(20);
                config.setIconPath("");
                config.setDefault(false);
            }

            onSave.accept(config);
            hide();

        } catch (NumberFormatException e) {
            dialogFactory.showWarning("Invalid Input", "Port numbers must be valid integers");
        }
    }

    private boolean isValidPort(int port) {
        return port >= MIN_PORT && port <= MAX_PORT;
    }

    private <T> String getExistingValue(java.util.function.Function<ServerConnectionConfig, T> getter,
                                        String defaultValue) {
        if (existingConfig != null) {
            T value = getter.apply(existingConfig);
            return value != null ? value.toString() : defaultValue;
        }
        return defaultValue;
    }
}

================
File: main/java/io.github.minemon/core/ui/StyleFactory.java
================
package io.github.minemon.core.ui;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.Gdx;
import org.springframework.stereotype.Component;

@Component
public class StyleFactory {
    private final Color TITLE_COLOR = new Color(1f, 0.95f, 0.8f, 1f);

    public Label createTitleLabel(String text, Skin skin) {
        Label label = new Label(text, skin);
        Label.LabelStyle style = new Label.LabelStyle(label.getStyle());
        style.fontColor = TITLE_COLOR;
        label.setStyle(style);
        float TITLE_SCALE = 1.8f;
        label.setFontScale(TITLE_SCALE);
        return label;
    }

    public TextButton createGameButton(String text, Skin skin) {
        TextButton button = new TextButton(text, skin);
        TextButton.TextButtonStyle style = new TextButton.TextButtonStyle(button.getStyle());
        style.up = createButtonBackground();
        style.down = createButtonBackground();
        style.over = createButtonBackground();
        button.setStyle(style);
        return button;
    }

    public Drawable createPanelBackground() {
        return new TextureRegionDrawable(new Texture(Gdx.files.internal("Textures/UI/window.png")));
    }

    private Drawable createButtonBackground() {
        Texture buttonTexture = new Texture(Gdx.files.internal("Textures/UI/hotbar_bg.png"));
        TextureRegionDrawable drawable = new TextureRegionDrawable(buttonTexture);
        drawable.setMinWidth(150);
        drawable.setMinHeight(50);
        return drawable;
    }
}

================
File: main/java/io.github.minemon/event/Event.java
================
package io.github.minemon.event;

public interface Event {
}

================
File: main/java/io.github.minemon/event/EventBus.java
================
package io.github.minemon.event;

import org.springframework.stereotype.Component;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class EventBus {
    private final Map<Class<? extends Event>, List<EventListener<?>>> listeners = new ConcurrentHashMap<>();

    public <E extends Event> void registerListener(Class<E> eventClass, EventListener<E> listener) {
        listeners.computeIfAbsent(eventClass, k -> Collections.synchronizedList(new ArrayList<>())).add(listener);
    }

    public <E extends Event> void unregisterListener(Class<E> eventClass, EventListener<E> listener) {
        List<EventListener<?>> list = listeners.get(eventClass);
        if (list != null) {
            list.remove(listener);
        }
    }

    @SuppressWarnings("unchecked")
    public <E extends Event> void fireEvent(E event) {
        Class<? extends Event> eventClass = event.getClass();
        List<EventListener<?>> list = listeners.get(eventClass);
        if (list != null) {
            for (EventListener<?> l : list) {
                ((EventListener<E>) l).onEvent(event);
            }
        }
    }
}

================
File: main/java/io.github.minemon/event/EventListener.java
================
package io.github.minemon.event;

public interface EventListener<E extends Event> {
    void onEvent(E event);
}

================
File: main/java/io.github.minemon/input/InputConfiguration.java
================
package io.github.minemon.input;

import com.badlogic.gdx.Input;
import io.github.minemon.player.model.PlayerDirection;
import lombok.Getter;
import lombok.Setter;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

@Setter
@Getter
@Component
public class InputConfiguration {
    private Map<Integer, PlayerDirection> movementKeys = new HashMap<>();

    private int runKey = Input.Keys.Z;

    public InputConfiguration() {

        movementKeys.put(Input.Keys.W, PlayerDirection.UP);
        movementKeys.put(Input.Keys.UP, PlayerDirection.UP);
        movementKeys.put(Input.Keys.S, PlayerDirection.DOWN);
        movementKeys.put(Input.Keys.DOWN, PlayerDirection.DOWN);
        movementKeys.put(Input.Keys.A, PlayerDirection.LEFT);
        movementKeys.put(Input.Keys.LEFT, PlayerDirection.LEFT);
        movementKeys.put(Input.Keys.D, PlayerDirection.RIGHT);
        movementKeys.put(Input.Keys.RIGHT, PlayerDirection.RIGHT);
    }

    public void updateKeyBinding(int oldKey, int newKey, PlayerDirection direction) {
        movementKeys.remove(oldKey);
        movementKeys.put(newKey, direction);
    }

    public PlayerDirection getDirectionForKey(int keyCode) {
        return movementKeys.get(keyCode);
    }
}

================
File: main/java/io.github.minemon/input/InputService.java
================
package io.github.minemon.input;

import com.badlogic.gdx.InputAdapter;
import io.github.minemon.chat.service.ChatService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.model.PlayerDirection;
import io.github.minemon.player.service.PlayerService;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class InputService extends InputAdapter {

    private final InputConfiguration inputConfig;

    private boolean upPressed, downPressed, leftPressed, rightPressed;
    private boolean runPressed;

    private PlayerDirection lastPressedDirection = null;
    @Autowired
    @Lazy
    private ChatService chatService;
    @Autowired
    @Lazy
    private MultiplayerClient multiplayerClient;
    @Autowired
    @Lazy
    private PlayerService playerService;

    /**
     * Returns the current direction, favoring the last pressed direction if multiple are pressed.
     */
    public PlayerDirection getCurrentDirection() {
        if (lastPressedDirection != null) {
            switch (lastPressedDirection) {
                case UP -> {
                    if (upPressed) return PlayerDirection.UP;
                }
                case DOWN -> {
                    if (downPressed) return PlayerDirection.DOWN;
                }
                case LEFT -> {
                    if (leftPressed) return PlayerDirection.LEFT;
                }
                case RIGHT -> {
                    if (rightPressed) return PlayerDirection.RIGHT;
                }
            }
        }
        if (upPressed) return PlayerDirection.UP;
        if (downPressed) return PlayerDirection.DOWN;
        if (leftPressed) return PlayerDirection.LEFT;
        if (rightPressed) return PlayerDirection.RIGHT;
        return null;
    }

    public boolean isRunning() {
        return runPressed;
    }

    @Override
    public boolean keyDown(int keycode) {
        if (chatService.isActive()) {
            return false;
        }
        PlayerDirection dir = inputConfig.getDirectionForKey(keycode);
        if (dir != null) {
            switch (dir) {
                case UP -> upPressed = true;
                case DOWN -> downPressed = true;
                case LEFT -> leftPressed = true;
                case RIGHT -> rightPressed = true;
            }
            lastPressedDirection = dir;
            return true;
        }

        if (keycode == inputConfig.getRunKey()) {
            runPressed = true;
            return true;
        }

        return false;
    }

    @Override
    public boolean keyUp(int keycode) {
        PlayerDirection dir = inputConfig.getDirectionForKey(keycode);
        if (dir != null) {
            switch (dir) {
                case UP -> upPressed = false;
                case DOWN -> downPressed = false;
                case LEFT -> leftPressed = false;
                case RIGHT -> rightPressed = false;
            }
            lastPressedDirection = null;
        }

        if (keycode == inputConfig.getRunKey()) {
            runPressed = false;
        }

        if (!upPressed && !downPressed && !leftPressed && !rightPressed) {
            PlayerData pd = playerService.getPlayerData();
            float x = pd.getX();
            float y = pd.getY();
            String dirName = pd.getDirection().name().toLowerCase();

            // Send "stop" => running = false, moving = false
            multiplayerClient.sendPlayerMove(x, y, false, false, dirName);
        }

        return true;
    }

}

================
File: main/java/io.github.minemon/multiplayer/model/ChunkUpdate.java
================
package io.github.minemon.multiplayer.model;

import lombok.Getter;
import lombok.Setter;
import io.github.minemon.world.model.WorldObject;
import java.util.List;

@Getter @Setter
public class ChunkUpdate {
    private int chunkX;
    private int chunkY;
    private int[][] tiles;
    private List<WorldObject> objects;
}

================
File: main/java/io.github.minemon/multiplayer/model/PlayerSyncData.java
================
package io.github.minemon.multiplayer.model;

import io.github.minemon.player.model.PlayerData;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class PlayerSyncData {
    private String username;
    private float x;
    private float lastX;
    private float lastY;
    private float y;
    private boolean running;
    private String direction;
    private boolean moving;
    private float animationTime = 0f;
    private float lastUpdateTime = 0f;
    private boolean wasMoving;
    private String lastDirection;

    public static PlayerSyncData fromPlayerData(PlayerData pd) {
        PlayerSyncData sync = new PlayerSyncData();
        sync.setUsername(pd.getUsername());
        sync.setX(pd.getX());
        sync.setY(pd.getY());
        sync.setRunning(pd.isWantsToRun());
        sync.setDirection(pd.getDirection() != null ? pd.getDirection().name() : "DOWN");
        sync.setMoving(pd.isMoving());

        if (sync.isMoving() != sync.wasMoving ||
            !sync.direction.equals(sync.lastDirection)) {
            sync.setAnimationTime(0f);
        }

        sync.setWasMoving(sync.isMoving());
        sync.setLastDirection(sync.direction);
        return sync;
    }

    public void updateAnimationTime(float delta) {
        if (moving) {
            animationTime += delta;
        }
    }
}

================
File: main/java/io.github.minemon/multiplayer/model/ServerConnectionConfig.java
================
package io.github.minemon.multiplayer.model;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class ServerConnectionConfig {
    private String serverIP = "127.0.0.1";
    private int tcpPort = 54555;
    private int udpPort = 54777;
    private int maxPlayers = 20;
    private String iconPath = "";
    private String motd = "";
    private String serverName = "Default Server";
    private String version = "1.0";
    private String dataDirectory = "worlds";
    private boolean isDefault = false;
    private int currentPlayers = 0;


    private boolean rememberMe = false;
    private String savedUsername = "";
    private String savedPassword = "";

    @Override
    public String toString() {
        return serverName + " (" + serverIP + ":" + tcpPort + ")";
    }
}

================
File: main/java/io.github.minemon/multiplayer/model/WorldObjectUpdate.java
================
package io.github.minemon.multiplayer.model;

import lombok.Getter;
import lombok.Setter;

@Getter @Setter
public class WorldObjectUpdate {
    private String objectId;
    private String type;
    private int tileX;
    private int tileY;
    private boolean removed;
}

================
File: main/java/io.github.minemon/multiplayer/service/impl/ClientConnectionManager.java
================
package io.github.minemon.multiplayer.service.impl;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.UUID;

@Service
@Slf4j
public class ClientConnectionManager {
    private static final String INSTANCE_FILE = "instance.lock";
    @Getter
    private final String instanceId;
    private FileChannel lockChannel;
    private FileLock lock;

    public ClientConnectionManager() {
        this.instanceId = UUID.randomUUID().toString();
    }

    public boolean acquireInstanceLock() {
        releaseInstanceLock(); // Always release any existing lock first

        try {
            File lockFile = new File(INSTANCE_FILE);

            // Delete the file if it exists but can't be opened
            if (lockFile.exists() && !lockFile.canWrite()) {
                Files.deleteIfExists(lockFile.toPath());
            }

            lockChannel = FileChannel.open(lockFile.toPath(),
                StandardOpenOption.CREATE,
                StandardOpenOption.WRITE,
                StandardOpenOption.DELETE_ON_CLOSE);

            // Try to get exclusive lock
            lock = lockChannel.tryLock();

            if (lock != null) {
                // Write instance ID
                ByteBuffer buffer = ByteBuffer.wrap(instanceId.getBytes());
                lockChannel.truncate(0);
                lockChannel.write(buffer);
                lockChannel.force(true);
                return true;
            }

            return false;
        } catch (IOException e) {
            log.error("Failed to acquire instance lock: {}", e.getMessage());
            releaseInstanceLock();
            return false;
        }
    }

    public void releaseInstanceLock() {
        try {
            if (lock != null) {
                lock.release();
                lock = null;
            }
            if (lockChannel != null) {
                lockChannel.close();
                lockChannel = null;
            }
            // Try to delete the lock file
            Files.deleteIfExists(Path.of(INSTANCE_FILE));
        } catch (IOException e) {
            log.error("Error releasing instance lock: {}", e.getMessage());
        }
    }

}

================
File: main/java/io.github.minemon/multiplayer/service/impl/MultiplayerClientImpl.java
================
package io.github.minemon.multiplayer.service.impl;

import com.badlogic.gdx.Gdx;
import com.esotericsoftware.kryonet.Client;
import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.Listener;
import io.github.minemon.NetworkProtocol;
import io.github.minemon.chat.event.ChatMessageReceivedEvent;
import io.github.minemon.chat.model.ChatMessage;
import io.github.minemon.chat.service.ChatService;
import io.github.minemon.core.screen.ServerDisconnectScreen;
import io.github.minemon.core.service.ScreenManager;
import io.github.minemon.multiplayer.model.ChunkUpdate;
import io.github.minemon.multiplayer.model.PlayerSyncData;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.world.model.ObjectType;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.world.service.ChunkLoadingManager;
import io.github.minemon.world.service.WorldService;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

@Slf4j
@Service
public class MultiplayerClientImpl implements MultiplayerClient {
    // -----------------------
    // Constants & Collections
    // -----------------------
    private static final int MAX_CONCURRENT_REQUESTS = 8;
    private static final int BATCH_SIZE = 8;
    private static final long BATCH_DELAY = 50;
    private static final long CHUNK_REQUEST_TIMEOUT = 5000;

    private final Map<ChunkKey, ChunkBuffer> chunkBuffers = new ConcurrentHashMap<>();
    private final Map<String, PlayerSyncData> playerStates = new ConcurrentHashMap<>();
    private final Map<String, ChunkUpdate> loadedChunks = new ConcurrentHashMap<>();
    private final ApplicationEventPublisher eventPublisher;

    // This set tracks chunk requests currently in flight.
    private final Set<ChunkKey> pendingChunkRequests = ConcurrentHashMap.newKeySet();
    private final Set<String> processedLeaves = Collections.newSetFromMap(new ConcurrentHashMap<>());

    // This set tracks chunk requests being processed in the "batch" logic.
    private final Set<ChunkKey> pendingRequests = ConcurrentHashMap.newKeySet();

    // IMPORTANT: Now store NetworkProtocol.ChunkRequest instead of the local one.
    private final Queue<NetworkProtocol.ChunkRequest> chunkQueue = new ConcurrentLinkedQueue<>();
    private final Map<String, Long> chunkRequestTimes = new ConcurrentHashMap<>();

    // If you also have a separate queue for normal vs. urgent, unify them if needed:
    private final Queue<NetworkProtocol.ChunkRequest> chunkRequestQueue = new ConcurrentLinkedQueue<>();

    // ------------
    // KryoNet Client
    // ------------
    private Client client;
    private boolean connected = false;

    // ------------
    // Listeners
    // ------------
    private LoginResponseListener loginResponseListener;
    private CreateUserResponseListener createUserResponseListener;
    private Runnable pendingCreateUserRequest = null;
    private Runnable pendingLoginRequest = null;

    @Autowired
    @Lazy
    private ScreenManager screenManager;
    @Autowired
    @Lazy
    private WorldService worldService;
    @Autowired
    @Lazy
    private ChatService chatService;
    @Autowired
    @Lazy
    private PlayerService playerService;
    @Autowired
    @Lazy
    private ChunkLoadingManager chunkLoadingManager;

    @Autowired
    public MultiplayerClientImpl(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    // ---------------------------------------------------------------
    //    1) Public method to request a chunk with NetworkProtocol.ChunkRequest
    // ---------------------------------------------------------------

    @Override
    public void requestChunk(int chunkX, int chunkY) {
        if (!isConnected()) {
            log.warn("Cannot request chunk - not connected to server");
            return;
        }

        NetworkProtocol.ChunkRequest req = new NetworkProtocol.ChunkRequest();
        req.setChunkX(chunkX);
        req.setChunkY(chunkY);
        req.setTimestamp(System.currentTimeMillis());

        client.sendTCP(req);
        log.debug("Sent chunk request to server for ({},{})", chunkX, chunkY);
    }
    @Override
    public boolean isPendingChunkRequest(int chunkX, int chunkY) {
        return pendingChunkRequests.contains(new ChunkKey(chunkX, chunkY));
    }

    // ---------------------------------------------------------------
    //    2) Moves the next batch of queued requests into flight
    // ---------------------------------------------------------------
    private void processPendingChunks() {
        if (pendingRequests.size() >= BATCH_SIZE) {
            return;
        }

        int space = BATCH_SIZE - pendingRequests.size();
        for (int i = 0; i < space; i++) {
            NetworkProtocol.ChunkRequest request = chunkQueue.poll();
            if (request == null) break; // no more to process

            ChunkKey key = new ChunkKey(request.getChunkX(), request.getChunkY());
            if (!pendingRequests.contains(key)) {
                sendChunkRequest(request);
                pendingRequests.add(key);
            }
        }
    }

    // ---------------------------------------------------------------
    //    3) Actually sends the chunk request to the server
    // ---------------------------------------------------------------
    private void sendChunkRequest(NetworkProtocol.ChunkRequest request) {
        // Optionally update the timestamp
        request.setTimestamp(System.currentTimeMillis());

        client.sendTCP(request);
        log.debug("Sent chunk request for ({},{})", request.getChunkX(), request.getChunkY());
    }

    // ---------------------------------------------------------------
    //    4) For stale or additional chunk requests, we do the same
    // ---------------------------------------------------------------
    private void handleChunkRequest(int chunkX, int chunkY) {
        ChunkKey key = new ChunkKey(chunkX, chunkY);
        if (!pendingChunkRequests.contains(key)) {
            if (pendingChunkRequests.size() < MAX_CONCURRENT_REQUESTS) {
                // Rebuild the request from the actual protocol class
                NetworkProtocol.ChunkRequest req = new NetworkProtocol.ChunkRequest();
                req.setChunkX(chunkX);
                req.setChunkY(chunkY);
                req.setTimestamp(System.currentTimeMillis());

                sendChunkRequest(req);
                pendingChunkRequests.add(key);
                chunkRequestTimes.put(key.toString(), System.currentTimeMillis());
            } else {
                // Defer if too many requests are in flight:
                NetworkProtocol.ChunkRequest laterReq = new NetworkProtocol.ChunkRequest();
                laterReq.setChunkX(chunkX);
                laterReq.setChunkY(chunkY);
                laterReq.setTimestamp(System.currentTimeMillis());

                chunkRequestQueue.offer(laterReq);
            }
        }
    }

    // ---------------------------------------------------------------
    //    5) Connect, login, creation, etc.
    // ---------------------------------------------------------------
    @Override
    public void connect(String serverIP, int tcpPort, int udpPort) {
        if (connected) {
            log.warn("Already connected to a server.");
            return;
        }
        client = new Client();
        NetworkProtocol.registerClasses(client.getKryo());

        client.addListener(new Listener() {
            @Override
            public void connected(Connection connection) {
                log.info("Connected to server: {}", connection.getRemoteAddressTCP());
                connected = true;
                if (pendingLoginRequest != null) {
                    pendingLoginRequest.run();
                    pendingLoginRequest = null;
                }
                if (pendingCreateUserRequest != null) {
                    pendingCreateUserRequest.run();
                    pendingCreateUserRequest = null;
                }
            }

            @Override
            public void disconnected(Connection connection) {
                log.info("Disconnected from server: {}", connection.getRemoteAddressTCP());
                connected = false;

                if (!worldService.isMultiplayerMode()) {
                    return;
                }
                playerStates.clear();
                loadedChunks.clear();

                Gdx.app.postRunnable(() -> {
                    if (loginResponseListener != null) {
                        loginResponseListener.onLoginResponse(false, "Lost connection to server.", "", 0, 0);
                    }
                    if (createUserResponseListener != null) {
                        createUserResponseListener.onCreateUserResponse(false, "Disconnected before completion.");
                    }
                });
            }

            @Override
            public void received(Connection connection, Object object) {
                handleMessage(object);
            }
        });

        try {
            client.start();
            client.connect(5000, serverIP, tcpPort, udpPort);
            log.info("Client attempting to connect to {}:{} (TCP) and {} (UDP)", serverIP, tcpPort, udpPort);
        } catch (IOException e) {
            log.error("Failed to connect to server: {}", e.getMessage(), e);
            if (loginResponseListener != null) {
                loginResponseListener.onLoginResponse(false,
                    "Connection failed: " + e.getMessage(), "", 0, 0);
            }
            if (createUserResponseListener != null) {
                createUserResponseListener.onCreateUserResponse(false,
                    "Connection failed: " + e.getMessage());
            }
        }
    }

    @Override
    public void login(String username, String password) {
        if (!connected) {
            log.warn("Not connected to server. Cannot send login request.");
            if (loginResponseListener != null) {
                loginResponseListener.onLoginResponse(false, "Not connected to server.", "", 0, 0);
            }
            return;
        }
        NetworkProtocol.LoginRequest req = new NetworkProtocol.LoginRequest();
        req.setUsername(username);
        req.setPassword(password);
        req.setTimestamp(System.currentTimeMillis());
        client.sendTCP(req);
        log.info("Sent LoginRequest for user: {}", username);
    }

    @Override
    public void createUser(String username, String password) {
        if (!connected) {
            log.warn("Not connected to server. Cannot send create user request.");
            if (createUserResponseListener != null) {
                createUserResponseListener.onCreateUserResponse(false, "Not connected to server.");
            }
            return;
        }
        NetworkProtocol.CreateUserRequest req = new NetworkProtocol.CreateUserRequest();
        req.setUsername(username);
        req.setPassword(password);
        client.sendTCP(req);
        log.info("Sent CreateUserRequest for user: {}", username);
    }

    // ---------------------------------------------------------------
    //    6) Clean up chunk requests, handle partial or full data
    // ---------------------------------------------------------------
    private void handleChunkData(NetworkProtocol.ChunkData chunkData) {
        ChunkKey key = new ChunkKey(chunkData.getChunkX(), chunkData.getChunkY());

        log.debug("Received chunk data for ({},{})", chunkData.getChunkX(), chunkData.getChunkY());

        // Update the world data
        worldService.loadOrReplaceChunkData(
            chunkData.getChunkX(),
            chunkData.getChunkY(),
            chunkData.getTiles(),
            chunkData.getObjects()
        );

        // Mark chunk as complete in loading manager
        chunkLoadingManager.markChunkComplete(chunkData.getChunkX(), chunkData.getChunkY());
    }
    private void processChunkQueue() {
        while (pendingChunkRequests.size() < MAX_CONCURRENT_REQUESTS && !chunkRequestQueue.isEmpty()) {
            NetworkProtocol.ChunkRequest request = chunkRequestQueue.poll();
            if (request != null) {
                handleChunkRequest(request.getChunkX(), request.getChunkY());
            }
        }
    }

    @Override
    public void clearPendingChunkRequests() {
        pendingChunkRequests.clear();
        chunkBuffers.clear();
    }

    private void handleMessage(Object object) {
        if (object.getClass().getName().startsWith("com.esotericsoftware.kryonet.FrameworkMessage")) {
            return;
        }

        if (object instanceof NetworkProtocol.LoginResponse resp) {
            log.info("Received LoginResponse: success={}, message={}", resp.isSuccess(), resp.getMessage());
            if (loginResponseListener != null) {
                loginResponseListener.onLoginResponse(
                    resp.isSuccess(),
                    resp.getMessage() != null ? resp.getMessage()
                        : (resp.isSuccess() ? "Success" : "Failed"),
                    resp.getUsername(),
                    resp.getX(),
                    resp.getY()
                );
            }
        } else if (object instanceof NetworkProtocol.CreateUserResponse createResp) {
            log.info("Received CreateUserResponse: success={}, message={}", createResp.isSuccess(), createResp.getMessage());
            if (createUserResponseListener != null) {
                createUserResponseListener.onCreateUserResponse(
                    createResp.isSuccess(),
                    createResp.getMessage() != null ? createResp.getMessage()
                        : (createResp.isSuccess() ? "Account created." : "Failed to create account.")
                );
            }
        } else if (object instanceof NetworkProtocol.PlayerStatesUpdate pUpdate) {
            handlePlayerStatesUpdate(pUpdate);
        } else if (object instanceof NetworkProtocol.ChunkData cData) {
            handleChunkData(cData);
            chunkLoadingManager.markChunkComplete(cData.getChunkX(), cData.getChunkY());
        } else if (object instanceof NetworkProtocol.ChunkRequestAck ack) {
            String key = ack.getChunkX() + "," + ack.getChunkY();
            pendingChunkRequests.remove(key);
        } else if (object instanceof NetworkProtocol.WorldObjectsUpdate wObjects) {
            handleWorldObjectsUpdate(wObjects);
        } else if (object instanceof ChatMessage chatMsg) {
            log.info("Received ChatMessage from {}: {}", chatMsg.getSender(), chatMsg.getContent());
            eventPublisher.publishEvent(new ChatMessageReceivedEvent(this, chatMsg));
        } else if (object instanceof NetworkProtocol.ServerShutdownNotice notice) {
            if (screenManager != null) {
                Gdx.app.postRunnable(() -> {
                    disconnect();
                    screenManager.showScreen(ServerDisconnectScreen.class);
                });
            }
        } else {
            log.warn("Unknown message type received: {}", object.getClass().getName());
        }
    }

    private void handlePlayerStatesUpdate(NetworkProtocol.PlayerStatesUpdate pUpdate) {
        // Compare with previous state to detect joins/leaves
        Set<String> previousPlayers = new HashSet<>(playerStates.keySet());
        Set<String> currentPlayers = new HashSet<>(pUpdate.getPlayers().keySet());

        // Find disconnected players
        Set<String> leaves = new HashSet<>(previousPlayers);
        leaves.removeAll(currentPlayers);

        // Handle player leaves
        for (String username : leaves) {
            if (!processedLeaves.contains(username)) {
                handlePlayerLeave(username);
                processedLeaves.add(username);
            }
        }

        // Clear processed leaves for players that rejoin
        processedLeaves.removeIf(currentPlayers::contains);

        // Find new players
        Set<String> joins = new HashSet<>(currentPlayers);
        joins.removeAll(previousPlayers);

        // Handle new joins
        for (String username : joins) {
            handlePlayerJoin(username);
        }

        // Update all player states
        updatePlayerStates(pUpdate.getPlayers());

        log.debug("Updated player states. Total players: {}", playerStates.size());
    }

    private void handleWorldObjectsUpdate(NetworkProtocol.WorldObjectsUpdate wObjects) {
        wObjects.getObjects().forEach(update -> {
            String key = (update.getTileX() / 16) + "," + (update.getTileY() / 16);
            ChunkUpdate cu = loadedChunks.get(key);
            if (cu != null) {
                if (update.isRemoved()) {
                    cu.getObjects().removeIf(o -> o.getId().equals(update.getObjectId()));
                } else {
                    boolean found = false;
                    for (WorldObject wo : cu.getObjects()) {
                        if (wo.getId().equals(update.getObjectId())) {
                            wo.setTileX(update.getTileX());
                            wo.setTileY(update.getTileY());
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        ObjectType objType = ObjectType.valueOf(update.getType());
                        WorldObject newObj = new WorldObject(
                            update.getTileX(),
                            update.getTileY(),
                            objType,
                            objType.isCollidable()
                        );
                        cu.getObjects().add(newObj);
                    }
                }
            }
            // Update the local world service with the object changes
            Gdx.app.postRunnable(() -> {
                worldService.updateWorldObjectState(update);
            });
        });
    }

    private void handlePlayerLeave(String username) {
        playerStates.remove(username);

        // Send single leave message
        ChatMessage leaveMsg = new ChatMessage();
        leaveMsg.setSender("System");
        leaveMsg.setContent(username + " left the game");
        leaveMsg.setTimestamp(System.currentTimeMillis());
        leaveMsg.setType(ChatMessage.Type.SYSTEM);
        chatService.handleIncomingMessage(leaveMsg);
    }

    private void handlePlayerJoin(String username) {
        ChatMessage joinMsg = new ChatMessage();
        joinMsg.setSender("System");
        joinMsg.setContent(username + " joined the game");
        joinMsg.setTimestamp(System.currentTimeMillis());
        joinMsg.setType(ChatMessage.Type.SYSTEM);
        chatService.handleIncomingMessage(joinMsg);
    }

    private void updatePlayerStates(Map<String, PlayerSyncData> newStates) {
        String localUsername = playerService.getPlayerData().getUsername();

        for (Map.Entry<String, PlayerSyncData> entry : newStates.entrySet()) {
            String username = entry.getKey();
            PlayerSyncData newState = entry.getValue();
            PlayerSyncData oldState = playerStates.get(username);

            // Skip local player's movement state
            if (username.equals(localUsername)) {
                playerStates.put(username, newState);
                continue;
            }

            // For remote players, detect actual movement
            if (oldState != null) {
                float dx = Math.abs(oldState.getX() - newState.getX());
                float dy = Math.abs(oldState.getY() - newState.getY());
                boolean actuallyMoving = dx > 0.001f || dy > 0.001f;

                if (actuallyMoving) {
                    newState.setMoving(true);
                    if (oldState.isMoving()) {
                        newState.setAnimationTime(oldState.getAnimationTime());
                    }
                } else {
                    newState.setMoving(newState.isMoving());
                    if (newState.isMoving()) {
                        newState.setAnimationTime(oldState.getAnimationTime());
                    } else {
                        newState.setAnimationTime(0f);
                    }
                }
            }
            playerStates.put(username, newState);
        }
    }

    // ---------------------------------------------------------------
    //    7) Stale request cleanup
    // ---------------------------------------------------------------
    private void cleanupStaleRequests() {
        long now = System.currentTimeMillis();
        Iterator<Map.Entry<String, Long>> it = chunkRequestTimes.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, Long> entry = it.next();
            if (now - entry.getValue() > CHUNK_REQUEST_TIMEOUT) {
                String[] coords = entry.getKey().split(",");
                int x = Integer.parseInt(coords[0]);
                int y = Integer.parseInt(coords[1]);
                ChunkKey key = new ChunkKey(x, y);
                pendingChunkRequests.remove(key);
                it.remove();

                // Requeue failed request
                NetworkProtocol.ChunkRequest retry = new NetworkProtocol.ChunkRequest();
                retry.setChunkX(x);
                retry.setChunkY(y);
                retry.setTimestamp(now);

                chunkRequestQueue.offer(retry);
            }
        }
    }

    // ---------------------------------------------------------------
    //    8) Helper for verifying server connection
    // ---------------------------------------------------------------
    private boolean checkServerConnection() {
        if (!connected || client == null) {
            log.debug("Lost connection to server");
            Gdx.app.postRunnable(() -> {
                disconnect();
                screenManager.showScreen(ServerDisconnectScreen.class);
            });
            return false;
        }
        return true;
    }

    // ---------------------------------------------------------------
    //    9) Required MultiplayerClient interface methods
    // ---------------------------------------------------------------
    @Override
    public void disconnect() {
        if (connected) {
            log.info("Disconnecting from server...");
            connected = false;
            clearPendingChunkRequests();
            if (client != null) {
                try {
                    client.close();
                } catch (Exception e) {
                    log.error("Error closing client: {}", e.getMessage());
                }
                client.stop();
                client = null;
            }
            // Clear all state on disconnect
            playerStates.clear();
            processedLeaves.clear();
        }
    }

    @Override
    public boolean isConnected() {
        return connected && worldService.isMultiplayerMode();
    }

    @Override
    public void sendPlayerMove(float x, float y, boolean running, boolean moving, String direction) {
        if (!connected) return;
        NetworkProtocol.PlayerMoveRequest req = new NetworkProtocol.PlayerMoveRequest();
        req.setX(x);
        req.setY(y);
        req.setRunning(running);
        req.setMoving(moving);
        req.setDirection(direction);
        client.sendTCP(req);
    }

    @Override
    public void update(float delta) {
        if (!worldService.isMultiplayerMode()) {
            return;
        }
        if (!checkServerConnection()) {
            return;
        }

        // Process chunk queue
        processChunkQueue();

        // Clean up stale requests
        cleanupStaleRequests();

        String localUsername = playerService.getPlayerData().getUsername();
        for (Map.Entry<String, PlayerSyncData> entry : playerStates.entrySet()) {
            String username = entry.getKey();
            PlayerSyncData psd = entry.getValue();

            // Skip local player animation updates
            if (username.equals(localUsername)) {
                continue;
            }
            // Update animation time only if the player is moving
            if (psd.isMoving()) {
                psd.setAnimationTime(psd.getAnimationTime() + delta);
            }
            // Track previous state
            psd.setWasMoving(psd.isMoving());
            psd.setLastDirection(psd.getDirection());
        }
    }


    @Override
    public Map<String, PlayerSyncData> getPlayerStates() {
        return playerStates;
    }

    @Override
    public void setLoginResponseListener(LoginResponseListener listener) {
        this.loginResponseListener = listener;
    }

    @Override
    public void setCreateUserResponseListener(CreateUserResponseListener listener) {
        this.createUserResponseListener = listener;
    }

    @Override
    public void sendMessage(Object msg) {
        if (!connected) return;
        client.sendTCP(msg);
    }

    @Override
    public void setPendingLoginRequest(Runnable action) {
        this.pendingLoginRequest = action;
    }

    @Override
    public void setPendingCreateUserRequest(Runnable action) {
        this.pendingCreateUserRequest = action;
    }

    // ---------------------------------------------------------------
    //    10) Internal support classes
    // ---------------------------------------------------------------
    @Data
    static class ChunkKey {
        private final int x;
        private final int y;
    }

    @Data
    static class ChunkBuffer {
        private final int[][] tiles;
        private final List<WorldObject> objects = new ArrayList<>();
        private final int totalParts;
        private int receivedParts = 0;
    }
}

================
File: main/java/io.github.minemon/multiplayer/service/impl/ServerConnectionServiceImpl.java
================
package io.github.minemon.multiplayer.service.impl;

import com.badlogic.gdx.utils.Json;
import io.github.minemon.multiplayer.model.ServerConnectionConfig;
import io.github.minemon.core.service.FileAccessService;
import io.github.minemon.multiplayer.service.ServerConnectionService;
import jakarta.annotation.PostConstruct;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service
@Primary
public class ServerConnectionServiceImpl implements ServerConnectionService {

    private final List<ServerConnectionConfig> serverList = new ArrayList<>();
    private final FileAccessService fileAccessService;
    private ServerConnectionConfig currentConfig;

    public ServerConnectionServiceImpl(FileAccessService fileAccessService) {
        this.fileAccessService = fileAccessService;
    }

    @PostConstruct
    public void init() {
        loadServersFromFile();

        if (serverList.isEmpty()) {
            ServerConnectionConfig defaultServer = new ServerConnectionConfig();
            defaultServer.setServerName("Localhost");
            defaultServer.setServerIP("127.0.0.1");
            defaultServer.setTcpPort(54555);
            defaultServer.setUdpPort(54777);
            defaultServer.setMotd("Welcome!");
            defaultServer.setMaxPlayers(20);
            defaultServer.setRememberMe(false);
            serverList.add(defaultServer);
        }

        currentConfig = serverList.get(0);
    }
    @Override
    public void saveConfig(ServerConnectionConfig config) {
        ensureInitialized();

        boolean found = false;
        for (int i = 0; i < serverList.size(); i++) {
            ServerConnectionConfig s = serverList.get(i);
            if (s.getServerName().equals(config.getServerName()) && s.getServerIP().equals(config.getServerIP())) {
                serverList.set(i, config);
                found = true;
                break;
            }
        }

        if (!found) {
            serverList.add(config);
        }

        currentConfig = config;
        saveServersToFile();
        System.out.println("Server configuration saved: " + config);
    }

    @Override
    public ServerConnectionConfig loadConfig() {
        ensureInitialized();
        return currentConfig;
    }

    @Override
    public List<ServerConnectionConfig> listServers() {
        ensureInitialized();
        return new ArrayList<>(serverList);
    }

    @Override
    public void addServer(ServerConnectionConfig config) {
        ensureInitialized();
        serverList.add(config);
        saveServersToFile();
        System.out.println("Server added: " + config);
    }

    @Override
    public void deleteServer(ServerConnectionConfig config) {
        ensureInitialized();
        serverList.removeIf(s ->
                s.getServerName().equals(config.getServerName()) &&
                        s.getServerIP().equals(config.getServerIP())
        );
        saveServersToFile();
        System.out.println("Server deleted: " + config);
    }

    private void ensureInitialized() {
        if (currentConfig == null) {
            throw new IllegalStateException("ServerConnectionService is not initialized.");
        }
    }

    private void saveServersToFile() {
        Json json = new Json();
        String data = json.toJson(serverList);
        fileAccessService.writeFile("data/servers.json", data);
    }

    @SuppressWarnings("unchecked")
    private void loadServersFromFile() {
        if (fileAccessService.exists("data/servers.json")) {
            Json json = new Json();
            List<ServerConnectionConfig> loaded = json.fromJson(ArrayList.class, ServerConnectionConfig.class, fileAccessService.readFile("data/servers.json"));
            serverList.clear();
            if (loaded != null) {
                serverList.addAll(loaded);
            }
        }
    }
}

================
File: main/java/io.github.minemon/multiplayer/service/MultiplayerClient.java
================
package io.github.minemon.multiplayer.service;

import io.github.minemon.multiplayer.model.PlayerSyncData;

import java.util.Map;

public interface MultiplayerClient {
    interface LoginResponseListener {
        void onLoginResponse(boolean success, String message, String username, int startX, int startY);
    }
    boolean isPendingChunkRequest(int chunkX, int chunkY);
    Map<String, PlayerSyncData> getPlayerStates();

    interface CreateUserResponseListener {
        void onCreateUserResponse(boolean success, String message);
    }

    void clearPendingChunkRequests();

    void setLoginResponseListener(LoginResponseListener listener);
    void setCreateUserResponseListener(CreateUserResponseListener listener);
    void connect(String serverIP, int tcpPort, int udpPort);
    void login(String username, String password);
    void createUser(String username, String password);
    void disconnect();
    boolean isConnected();
    void sendPlayerMove(float x, float y, boolean running, boolean moving, String direction);
    void requestChunk(int chunkX, int chunkY);
    void update(float delta);
    void sendMessage(Object msg);

    // New methods for handling pending actions
    void setPendingLoginRequest(Runnable action);
    void setPendingCreateUserRequest(Runnable action);
}

================
File: main/java/io.github.minemon/multiplayer/service/ServerConnectionService.java
================
package io.github.minemon.multiplayer.service;

import io.github.minemon.multiplayer.model.ServerConnectionConfig;
import java.util.List;

public interface ServerConnectionService {
    void saveConfig(ServerConnectionConfig config);
    ServerConnectionConfig loadConfig();

    List<ServerConnectionConfig> listServers();
    void addServer(ServerConnectionConfig config);
    void deleteServer(ServerConnectionConfig config);
}

================
File: main/java/io.github.minemon/NetworkProtocol.java
================
package io.github.minemon;

import com.esotericsoftware.kryo.Kryo;
import io.github.minemon.chat.model.ChatMessage;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.utils.UUIDSerializer;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.multiplayer.model.PlayerSyncData;
import io.github.minemon.multiplayer.model.WorldObjectUpdate;
import lombok.Data;

import java.util.*;

public final class NetworkProtocol {

    private NetworkProtocol() {
    }

    public static void registerClasses(Kryo kryo) {
        kryo.register(UUID.class, new UUIDSerializer());
        kryo.register(java.util.UUID.class);
        kryo.register(ChatMessage.class);

        kryo.register(UUID.class, new UUIDSerializer());
        kryo.register(ArrayList.class);
        kryo.register(HashMap.class);
        kryo.register(HashSet.class);
        kryo.register(WorldObject.class);
        kryo.register(WorldObject[].class);
        kryo.register(ChunkRequestAck.class);
        kryo.register(ArrayList.class);
        kryo.register(int[].class);
        kryo.register(int[][].class);
        kryo.register(ChunkData.class);
        kryo.register(PlayerData.class);
        kryo.register(WorldObject.class);
        kryo.register(PlayerSyncData.class);
        kryo.register(WorldObjectUpdate.class);

        kryo.register(ServerShutdownNotice.class);

        kryo.register(List.class);
        kryo.register(Set.class);

        kryo.register(LoginRequest.class);
        kryo.register(LoginResponse.class);
        kryo.register(PlayerMoveRequest.class);
        kryo.register(PlayerStatesUpdate.class);
        kryo.register(ChunkRequest.class);
        kryo.register(ChunkData.class);
        kryo.register(WorldObjectsUpdate.class);

        kryo.register(CreateUserRequest.class);
        kryo.register(CreateUserResponse.class);

        kryo.setRegistrationRequired(false);
        kryo.setReferences(false);
    }

    @Data
    public static class LoginRequest {
        private String username;
        private String password;
        private long timestamp;
    }
    @Data
    public static class CreateUserRequest {
        private String username;
        private String password;
    }

    @Data
    public static class ChunkRequestAck {
        private int chunkX;
        private int chunkY;
    }
    @Data
    public static class CreateUserResponse {
        private boolean success;
        private String message;
    }
    @Data
    public static class ServerShutdownNotice {
        private String message;
        private ShutdownReason reason;

        public enum ShutdownReason {
            NORMAL_SHUTDOWN,
            TIMEOUT,
            ERROR
        }
    }
    @Data
    public static class LoginResponse {
        private boolean success;
        private String message;
        private String username;
        private int x;
        private int y;
        private long timestamp;
    }

    @Data
    public static class PlayerMoveRequest {
        private float x;
        private float y;
        private boolean running;
        private boolean moving;
        private String direction;
    }

    @Data
    public static class PlayerStatesUpdate {
        private Map<String, PlayerSyncData> players;
    }

    @Data
    public static class ChunkRequest {
        private int chunkX;
        private int chunkY;
        private long timestamp;
    }

    @Data
    public static class ChunkData {
        private int chunkX;
        private int chunkY;
        private int[][] tiles;
        private List<WorldObject> objects = new ArrayList<>();
        private boolean isPartial;
        private int partNumber;
        private int totalParts;
    }

    @Data
    public static class WorldObjectsUpdate {
        private List<WorldObjectUpdate> objects;
    }
}

================
File: main/java/io.github.minemon/player/config/PlayerConfig.java
================
package io.github.minemon.player.config;

import io.github.minemon.input.InputService;
import io.github.minemon.player.service.PlayerAnimationService;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.player.service.impl.PlayerServiceImpl;
import io.github.minemon.world.service.WorldService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Lazy;


@Configuration
@EnableConfigurationProperties(PlayerProperties.class)
public class PlayerConfig {

    private final InputService inputService;
    private final PlayerProperties playerProperties;

    @Autowired
    @Lazy
    private WorldService worldService;

    @Autowired
    public PlayerConfig(InputService inputService, PlayerProperties playerProperties, WorldService worldService) {
        this.inputService = inputService;
        this.playerProperties = playerProperties;
        this.worldService = worldService;

    }

    
    @Bean
    public PlayerService playerService(
            PlayerAnimationService animationService
    ) {
        return new PlayerServiceImpl(animationService, inputService, playerProperties, worldService);
    }
}

================
File: main/java/io.github.minemon/player/config/PlayerProperties.java
================
package io.github.minemon.player.config;

import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;


@Setter
@Getter
@Configuration
@ConfigurationProperties(prefix = "player")
public class PlayerProperties {

    
    private String username = "Player";

    
    private float walkStepDuration = 0.3f;

    
    private float runStepDuration = 0.15f;



}

================
File: main/java/io.github.minemon/player/event/PlayerJoinEvent.java
================
package io.github.minemon.player.event;

import io.github.minemon.event.Event;
import lombok.Getter;

@Getter
public class PlayerJoinEvent implements Event {
    private final String username;

    public PlayerJoinEvent(String username) {
        this.username = username;
    }

}

================
File: main/java/io.github.minemon/player/event/PlayerLeaveEvent.java
================
package io.github.minemon.player.event;

import io.github.minemon.event.Event;
import lombok.Getter;

@Getter
public class PlayerLeaveEvent implements Event {
    private final String username;

    public PlayerLeaveEvent(String username) {
        this.username = username;
    }

}

================
File: main/java/io.github.minemon/player/event/PlayerMoveEvent.java
================
package io.github.minemon.player.event;

import io.github.minemon.event.Event;
import io.github.minemon.player.model.PlayerData;
import lombok.Getter;

@Getter
public class PlayerMoveEvent implements Event {
    private final PlayerData playerData;

    public PlayerMoveEvent(PlayerData playerData) {
        this.playerData = playerData;
    }

}

================
File: main/java/io.github.minemon/player/model/PlayerData.java
================
package io.github.minemon.player.model;

import lombok.Data;

@Data
public class PlayerData {
    private String username;

    private float x;
    private float y;
    private boolean wantsToRun;
    private boolean moving;
    private PlayerDirection direction = PlayerDirection.DOWN;

    public PlayerData() {}

    public PlayerData(String username, float x, float y, PlayerDirection dir) {
        this.username = username;
        this.x = x;
        this.y = y;
        this.wantsToRun = false;
        this.moving = false;
        this.direction = dir;
    }
}

================
File: main/java/io.github.minemon/player/model/PlayerDirection.java
================
package io.github.minemon.player.model;

public enum PlayerDirection {
    UP, DOWN, LEFT, RIGHT
}

================
File: main/java/io.github.minemon/player/model/PlayerModel.java
================
package io.github.minemon.player.model;

import com.badlogic.gdx.math.Vector2;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class PlayerModel {
    public final int TILE_SIZE = 32;

    private Vector2 position;
    private Vector2 startPosition;
    private Vector2 targetPosition;

    private PlayerDirection direction;
    private boolean moving;
    private boolean running;

    private float movementTime = 0f;
    private float movementDuration = 0.2f;
    private float runSpeedMultiplier = 1.75f;

    private float stateTime = 0f;

    public PlayerModel(int startTileX, int startTileY) {
        float x = startTileX * TILE_SIZE;
        float y = startTileY * TILE_SIZE;
        this.position = new Vector2(x, y);
        this.targetPosition = new Vector2(x, y);
        this.startPosition = new Vector2(x, y);
        this.direction = PlayerDirection.DOWN;
        this.moving = false;
        this.running = false;
    }

    public void setTargetPosition(float x, float y) {
        this.targetPosition.set(x, y);
    }

    public void setStartPosition(float x, float y) {
        this.startPosition.set(x, y);
    }

    public void setPosition(float x, float y) {
        this.position.set(x, y);
    }
}

================
File: main/java/io.github.minemon/player/model/RemotePlayerAnimator.java
================
package io.github.minemon.player.model;

import lombok.Getter;

public class RemotePlayerAnimator {
    private static final float MIN_MOVEMENT_THRESHOLD = 0.001f;
    private static final float POSITION_LERP_SPEED = 15f;

    @Getter
    private float currentX, currentY;
    private float targetX, targetY;
    private float lastX, lastY;
    @Getter
    private float animationTime;
    @Getter
    private boolean moving;
    private boolean wasMoving;
    @Getter
    private boolean running;
    @Getter
    private PlayerDirection direction;
    private PlayerDirection lastDirection;
    private float stationaryTime; // tracks how long we have been at rest

    public RemotePlayerAnimator() {
        this.direction = PlayerDirection.DOWN;
        this.lastDirection = direction;
        this.moving = false;
        this.wasMoving = false;
        this.running = false;
        this.animationTime = 0f;
        this.stationaryTime = 0f;
    }

    /**
     * Updates the remote player's position, direction, and animation state.
     *
     * @param newTargetX     Where the server says we should be (X)
     * @param newTargetY     Where the server says we should be (Y)
     * @param isRunning      True if server says player is running
     * @param newDirection   The direction from the server
     * @param serverMoving   True if server is telling us the player is "moving"
     * @param delta          Frame time
     */
    public void updateState(float newTargetX, float newTargetY,
                            boolean isRunning, PlayerDirection newDirection,
                            boolean serverMoving, float delta) {

        // Store old positions to detect if we truly changed
        lastX = currentX;
        lastY = currentY;
        lastDirection = direction;
        wasMoving = moving;

        // Update basic states from server
        this.running = isRunning;
        this.direction = newDirection;
        this.targetX = newTargetX;
        this.targetY = newTargetY;

        // Check how far we are from target
        float dx = Math.abs(targetX - currentX);
        float dy = Math.abs(targetY - currentY);
        boolean hasPositionChanged = (dx > MIN_MOVEMENT_THRESHOLD || dy > MIN_MOVEMENT_THRESHOLD);

        // Smooth interpolation
        if (hasPositionChanged) {
            float lerpSpeed = POSITION_LERP_SPEED * delta;
            currentX += (targetX - currentX) * lerpSpeed;
            currentY += (targetY - currentY) * lerpSpeed;
            stationaryTime = 0f;
        } else {
            // If we’re not changing position at all, keep track of idle time
            stationaryTime += delta;
        }

        // Now decide "moving" or "not" based on server + actual movement
        // 1) If the server claims no movement, or we’ve been idle long enough, forcibly stop
        if (!serverMoving && stationaryTime > 0.1f) {
            moving = false;
            // Snap to target
            currentX = targetX;
            currentY = targetY;
        }
        // 2) If server says "moving" OR we are actually adjusting position, set true
        else if (hasPositionChanged || serverMoving) {
            moving = true;
        }

        // *** Additional final check: if server says "moving" but we truly didn't move, override. ***
        // This prevents "running in place" if the server sets moving=true but we actually haven't changed positions.
        float actualDX = Math.abs(currentX - lastX);
        float actualDY = Math.abs(currentY - lastY);
        boolean actuallyMoved = (actualDX > MIN_MOVEMENT_THRESHOLD || actualDY > MIN_MOVEMENT_THRESHOLD);

        if (serverMoving && !actuallyMoved) {
            moving = false;
            stationaryTime += delta;   // accumulate idle time if truly no movement
        }

        // Update animation time
        if (moving) {
            // Running speeds up animation by 2x (example)
            animationTime += delta * (running ? 2f : 1f);
        } else {
            // If we just stopped moving or changed direction, reset animation to idle frame
            if (wasMoving != moving || lastDirection != direction) {
                animationTime = 0f;
            }
        }
    }

    /**
     * Directly sets our position (e.g., on initial spawn).
     */
    public void setPosition(float x, float y) {
        this.currentX = x;
        this.targetX = x;
        this.lastX = x;
        this.currentY = y;
        this.targetY = y;
        this.lastY = y;
        this.stationaryTime = 0f;
    }

    /**
     * Resets the animation and movement state completely.
     */
    public void resetAnimation() {
        animationTime = 0f;
        moving = false;
        wasMoving = false;
        stationaryTime = 0f;
    }
}

================
File: main/java/io.github.minemon/player/model/RemotePlayerModel.java
================
package io.github.minemon.player.model;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class RemotePlayerModel {
    public float currentX, currentY;
    public float targetX, targetY;
    public float lastX, lastY;
    public boolean moving;
    public boolean wasMoving;
    public boolean running;
    public PlayerDirection direction = PlayerDirection.DOWN;
    public float animationTime;
    public float updateTime;
    public float movementThreshold = 0.001f;
    public void updatePosition(float newX, float newY, float delta) {
        lastX = currentX;
        lastY = currentY;

        float lerpFactor = 10f * delta;
        currentX += (newX - currentX) * lerpFactor;
        currentY += (newY - currentY) * lerpFactor;

        boolean isMoving = Math.abs(currentX - lastX) > movementThreshold ||
            Math.abs(currentY - lastY) > movementThreshold;

        wasMoving = moving;
        moving = isMoving;

        // Update animation
        if (moving) {
            animationTime += delta;
        } else if (wasMoving != moving) {
            animationTime = 0;  // Reset animation when movement state changes
        }
    }
}

================
File: main/java/io.github.minemon/player/service/impl/PlayerAnimationServiceImpl.java
================
package io.github.minemon.player.service.impl;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.utils.Array;
import io.github.minemon.player.model.PlayerDirection;
import io.github.minemon.player.service.PlayerAnimationService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Comparator;

@Service
@Slf4j
public class PlayerAnimationServiceImpl implements PlayerAnimationService {

    /**
     * Increase the frame duration for walking to slow down the animation slightly.
     *
     * With 3 frames, 0.10f means ~10 FPS (1 / 0.10). Feel free to adjust as needed.
     */
    private static final float WALK_FRAME_DURATION = 0.10f;

    /**
     * Increase the frame duration for running but still keep it slightly faster than walk.
     *
     * With 3 frames, 0.06f means ~16.7 FPS (1 / 0.06). Adjust if you need a different feel.
     */
    private static final float RUN_FRAME_DURATION = 0.06f;

    private TextureRegion standingUp, standingDown, standingLeft, standingRight;
    private Animation<TextureRegion> walkUp, walkDown, walkLeft, walkRight;
    private Animation<TextureRegion> runUp, runDown, runLeft, runRight;
    private boolean initialized = false;

    public PlayerAnimationServiceImpl() {
    }

    @Override
    public TextureRegion getCurrentFrame(PlayerDirection direction, boolean moving, boolean running, float stateTime) {
        if (!moving) {
            return getStandingFrame(direction);
        }

        Animation<TextureRegion> anim = getMovementAnimation(direction, running);
        return anim.getKeyFrame(stateTime, true);
    }

    @Override
    public TextureRegion getStandingFrame(PlayerDirection direction) {
        return switch (direction) {
            case UP -> standingUp;
            case DOWN -> standingDown;
            case LEFT -> standingLeft;
            case RIGHT -> standingRight;
        };
    }

    private Animation<TextureRegion> getMovementAnimation(PlayerDirection direction, boolean running) {
        return switch (direction) {
            case UP -> running ? runUp : walkUp;
            case DOWN -> running ? runDown : walkDown;
            case LEFT -> running ? runLeft : walkLeft;
            case RIGHT -> running ? runRight : walkRight;
        };
    }

    private void loadAnimations() {
        String atlasPath = "atlas/boy-gfx-atlas.atlas";
        log.info("Loading TextureAtlas from path: {}", atlasPath);
        TextureAtlas atlas = new TextureAtlas(Gdx.files.internal(atlasPath));

        log.info("Available regions in the atlas:");
        for (TextureAtlas.AtlasRegion region : atlas.getRegions()) {
            log.info("- {} (index: {})", region.name, region.index);
        }

        // Create the walking animations (3 frames expected, but will work with however many frames are found)
        walkUp = createLoopAnimation(atlas, "boy_walk_up", WALK_FRAME_DURATION);
        walkDown = createLoopAnimation(atlas, "boy_walk_down", WALK_FRAME_DURATION);
        walkLeft = createLoopAnimation(atlas, "boy_walk_left", WALK_FRAME_DURATION);
        walkRight = createLoopAnimation(atlas, "boy_walk_right", WALK_FRAME_DURATION);

        // Standing frames are simply the first key frame of each animation
        standingUp = walkUp.getKeyFrames()[0];
        standingDown = walkDown.getKeyFrames()[0];
        standingLeft = walkLeft.getKeyFrames()[0];
        standingRight = walkRight.getKeyFrames()[0];

        // Create the running animations (3 frames expected, but will work with however many frames are found)
        runUp = createLoopAnimation(atlas, "boy_run_up", RUN_FRAME_DURATION);
        runDown = createLoopAnimation(atlas, "boy_run_down", RUN_FRAME_DURATION);
        runLeft = createLoopAnimation(atlas, "boy_run_left", RUN_FRAME_DURATION);
        runRight = createLoopAnimation(atlas, "boy_run_right", RUN_FRAME_DURATION);
    }

    public void initAnimationsIfNeeded() {
        if (!initialized) {
            loadAnimations();
            initialized = true;
        }
    }

    private Animation<TextureRegion> createLoopAnimation(TextureAtlas atlas, String baseName, float duration) {
        Array<TextureAtlas.AtlasRegion> regions = atlas.findRegions(baseName);
        if (regions.size == 0) {
            log.error("No regions found for animation: {}", baseName);
            throw new RuntimeException("No regions found for animation: " + baseName);
        }

        // Sort frames by index to ensure correct ordering
        regions.sort(Comparator.comparingInt(a -> a.index));

        log.info("Creating animation '{}', frames: {}, frameDuration: {}",
                baseName, regions.size, duration);

        Animation<TextureRegion> anim = new Animation<>(duration, regions, Animation.PlayMode.LOOP);
        log.debug("Created loop animation: {}", baseName);
        return anim;
    }

    public void dispose() {
    }
}

================
File: main/java/io.github.minemon/player/service/impl/PlayerServiceImpl.java
================
package io.github.minemon.player.service.impl;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import io.github.minemon.event.EventBus;
import io.github.minemon.input.InputService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.config.PlayerProperties;
import io.github.minemon.player.event.PlayerMoveEvent;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.model.PlayerDirection;
import io.github.minemon.player.model.PlayerModel;
import io.github.minemon.player.service.PlayerAnimationService;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.world.model.ChunkData;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.world.service.ChunkLoadingManager;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.ArrayList;
import java.util.List;

@Slf4j
public class PlayerServiceImpl implements PlayerService {
    public final int TILE_SIZE = 32;

    private final PlayerModel playerModel;
    private final PlayerAnimationService animationService;
    private final WorldService worldService;
    private final float walkStepDuration;
    private final float runStepDuration;
    private final InputService inputService;
    private String username;
    private PlayerDirection bufferedDirection = null;

    @Autowired
    private EventBus eventBus;

    @Autowired
    private ChunkLoadingManager chunkLoadingManager;
    @Autowired
    private MultiplayerClient multiplayerClient;

    public PlayerServiceImpl(
        PlayerAnimationService animationService,
        InputService inputService,
        PlayerProperties playerProperties,
        WorldService worldService
    ) {
        this.playerModel = new PlayerModel(0, 0);
        this.animationService = animationService;
        this.inputService = inputService;
        this.username = playerProperties.getUsername();
        this.walkStepDuration = playerProperties.getWalkStepDuration();
        this.runStepDuration = playerProperties.getRunStepDuration();
        this.playerModel.setRunning(false);
        this.worldService = worldService;
    }

    @Override
    public void move(PlayerDirection direction) {
        // If currently mid-move, buffer the new direction for after finishing
        if (playerModel.isMoving()) {
            log.debug("Currently moving. Buffering direction: {}", direction);
            this.bufferedDirection = direction;
            return;
        }

        float currentX = playerModel.getPosition().x;
        float currentY = playerModel.getPosition().y;
        float tileSize = TILE_SIZE;

        int currentTileX = (int) (currentX / tileSize);
        int currentTileY = (int) (currentY / tileSize);

        // Calculate the attempted tile
        int targetTileX = currentTileX;
        int targetTileY = currentTileY;
        switch (direction) {
            case UP -> targetTileY += 1;
            case DOWN -> targetTileY -= 1;
            case LEFT -> targetTileX -= 1;
            case RIGHT -> targetTileX += 1;
        }

        // Always set direction so we appear to face that way even if blocked
        playerModel.setDirection(direction);

        if (isColliding(targetTileX, targetTileY)) {
            log.debug("Collision at ({}, {}): no movement, but direction updated to {}",
                targetTileX, targetTileY, direction);
            // No movement, remain idle, but direction is changed
            playerModel.setMoving(false);
            return;
        }

        // If passable, we do run/walk
        playerModel.setRunning(inputService.isRunning());
        float targetX = targetTileX * tileSize;
        float targetY = targetTileY * tileSize;

        playerModel.setStartPosition(currentX, currentY);
        playerModel.setTargetPosition(targetX, targetY);

        float duration = playerModel.isRunning() ? runStepDuration : walkStepDuration;
        playerModel.setMovementDuration(duration);

        // DO NOT reset stateTime, so the animation doesn't restart every step:
        // playerModel.setStateTime(0f);

        // We still reset movementTime for tile interpolation:
        playerModel.setMovementTime(0f);

        playerModel.setMoving(true);
        if (worldService.isMultiplayerMode()) {
            chunkLoadingManager.preloadChunksAroundPosition(
                playerModel.getTargetPosition().x,
                playerModel.getTargetPosition().y
            );
        }
        log.debug("Initiated movement: {}, Target=({}, {}), Duration={}",
            direction, targetX, targetY, duration);
    }


    private boolean isColliding(int tileX, int tileY) {
        int chunkX = tileX / 16;
        int chunkY = tileY / 16;
        int[][] chunkTiles = worldService.getChunkTiles(chunkX, chunkY);
        if (chunkTiles == null) return true;

        int localX = Math.floorMod(tileX, 16);
        int localY = Math.floorMod(tileY, 16);
        if (localX < 0 || localX >= 16 || localY < 0 || localY >= 16) return true;

        int tileID = chunkTiles[localX][localY];
        if (!worldService.getTileManager().isPassable(tileID)) {
            return true;
        }

        float tileSize = TILE_SIZE;
        Rectangle targetTileRect = new Rectangle(tileX * tileSize, tileY * tileSize, tileSize, tileSize);

        List<WorldObject> nearbyObjects = new ArrayList<>();

        for (int dx = -1; dx <= 1; dx++) {
            for (int dy = -1; dy <= 1; dy++) {
                int neighborChunkX = chunkX + dx;
                int neighborChunkY = chunkY + dy;
                String chunkKey = neighborChunkX + "," + neighborChunkY;
                ChunkData chunkData = worldService.getWorldData().getChunks().get(chunkKey);
                if (chunkData != null && chunkData.getObjects() != null) {
                    nearbyObjects.addAll(chunkData.getObjects());
                }
            }
        }

        for (WorldObject obj : nearbyObjects) {
            if (!obj.isCollidable()) continue;
            Rectangle collisionBox = obj.getCollisionBox();
            if (collisionBox == null) continue;
            if (collisionBox.overlaps(targetTileRect)) {
                log.debug("Collision detected with object {} at tile ({}, {})", obj.getId(), tileX, tileY);
                return true;
            }
        }

        return false;
    }

    @Override
    public void update(float delta) {
        playerModel.setStateTime(playerModel.getStateTime() + delta);

        if (playerModel.isMoving()) {
            float progress = playerModel.getMovementTime() / playerModel.getMovementDuration();
            progress = Math.min(progress + (delta / playerModel.getMovementDuration()), 1f);

            float smoothed = smoothstep(progress);

            float newX = lerp(playerModel.getStartPosition().x, playerModel.getTargetPosition().x, smoothed);
            float newY = lerp(playerModel.getStartPosition().y, playerModel.getTargetPosition().y, smoothed);
            playerModel.setPosition(newX, newY);

            playerModel.setMovementTime(playerModel.getMovementTime() + delta);

            if (progress >= 1f) {
                playerModel.setMoving(false);
                playerModel.setPosition(playerModel.getTargetPosition().x, playerModel.getTargetPosition().y);

                // Movement completed, send updated position to the server
                PlayerData pd = getPlayerData();
                worldService.setPlayerData(pd);
                multiplayerClient.sendPlayerMove(
                    pd.getX(),
                    pd.getY(),
                    pd.isWantsToRun(),
                    pd.isMoving(),
                    pd.getDirection().name().toLowerCase()
                );

                if (bufferedDirection != null) {
                    PlayerDirection nextDir = bufferedDirection;
                    bufferedDirection = null;
                    move(nextDir);
                } else {
                    PlayerDirection dir = inputService.getCurrentDirection();
                    if (dir != null) {
                        move(dir);
                    } else {
                        playerModel.setMoving(false);
                        playerModel.setRunning(false);
                    }
                }
            }
        } else {
            PlayerDirection dir = inputService.getCurrentDirection();
            if (dir != null) {
                move(dir);
            } else {
                playerModel.setMoving(false);
                playerModel.setRunning(false);
            }
        }

        if (!playerModel.isMoving()) {
            eventBus.fireEvent(new PlayerMoveEvent(getPlayerData()));
        }
    }

    private float lerp(float a, float b, float t) {
        return a + (b - a) * t;
    }

    private float smoothstep(float x) {
        x = Math.max(0f, Math.min(x, 1f));
        return x * x * (3f - 2f * x);
    }

    @Override
    public void render(SpriteBatch batch) {
        TextureRegion frame = animationService.getCurrentFrame(
            playerModel.getDirection(),
            playerModel.isMoving(),
            playerModel.isRunning(),
            playerModel.getStateTime()
        );
        batch.draw(frame, playerModel.getPosition().x, playerModel.getPosition().y);
    }

    @Override
    public PlayerData getPlayerData() {
        float tileX = playerModel.getPosition().x / TILE_SIZE;
        float tileY = playerModel.getPosition().y / TILE_SIZE;
        PlayerData pd = new PlayerData(username, tileX, tileY, playerModel.getDirection());

        pd.setMoving(playerModel.isMoving());
        pd.setWantsToRun(playerModel.isRunning());

        return pd;
    }

    @Override
    public void setPlayerData(PlayerData data) {
        if (data.getUsername() != null && !data.getUsername().isEmpty()) {
            this.username = data.getUsername();
        }

        int tileX = (int) data.getX();
        int tileY = (int) data.getY();
        setPosition(tileX, tileY);
        playerModel.setMoving(data.isMoving());
        playerModel.setRunning(data.isWantsToRun());

        playerModel.setDirection(data.getDirection());

        log.debug("Player data updated: username={}, x={}, y={}", data.getUsername(), data.getX(), data.getY());

        worldService.setPlayerData(data);
    }

    @Override
    public void setRunning(boolean running) {
        playerModel.setRunning(running);
        log.debug("Set running to {}", running);
    }

    @Override
    public void setPosition(int tileX, int tileY) {
        float x = tileX * TILE_SIZE;
        float y = tileY * TILE_SIZE;
        playerModel.setPosition(x, y);
        playerModel.setStartPosition(x, y);
        playerModel.setTargetPosition(x, y);
        playerModel.setMoving(false);
        playerModel.setMovementTime(0f);
        playerModel.setStateTime(0f);
        this.bufferedDirection = null;
        log.debug("Set position to ({}, {})", x, y);
    }
}

================
File: main/java/io.github.minemon/player/service/PlayerAnimationService.java
================
package io.github.minemon.player.service;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.minemon.player.model.PlayerDirection;

public interface PlayerAnimationService {
    TextureRegion getCurrentFrame(PlayerDirection direction, boolean moving, boolean running, float stateTime);
    TextureRegion getStandingFrame(PlayerDirection direction);
    void initAnimationsIfNeeded();
}

================
File: main/java/io.github.minemon/player/service/PlayerService.java
================
package io.github.minemon.player.service;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.model.PlayerDirection;

public interface PlayerService {
    void move(PlayerDirection direction);
    void update(float delta);
    void render(SpriteBatch batch);

    PlayerData getPlayerData();
    void setPlayerData(PlayerData data);

    void setRunning(boolean running);
    void setPosition(int tileX, int tileY);
}

================
File: main/java/io.github.minemon/plugin/Plugin.java
================
package io.github.minemon.plugin;

public interface Plugin {
    void onEnable();
    void onDisable();
}

================
File: main/java/io.github.minemon/plugin/PluginManager.java
================
package io.github.minemon.plugin;

import io.github.minemon.event.EventBus;
import lombok.Getter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.*;
import java.util.*;

@Component
public class PluginManager {
    private static final Logger logger = LoggerFactory.getLogger(PluginManager.class);
    private final List<Plugin> plugins = new ArrayList<>();
    @Getter
    private final EventBus eventBus;

    public PluginManager(EventBus eventBus) {
        this.eventBus = eventBus;
    }

    
    public void loadPlugins(Path pluginsDir) {
        if (Files.notExists(pluginsDir)) {
            try {
                Files.createDirectories(pluginsDir);
            } catch (IOException e) {
                logger.error("Failed to create plugins directory: {}", e.getMessage());
                return;
            }
        }

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(pluginsDir, "*.jar")) {
            for (Path jarPath : stream) {
                loadPluginFromJar(jarPath);
            }
        } catch (IOException e) {
            logger.error("Error reading plugins directory: {}", e.getMessage());
        }
    }

    
    private void loadPluginFromJar(Path jarPath) {
        logger.info("Loading plugin from JAR: {}", jarPath);
        try {
            URL jarUrl = jarPath.toUri().toURL();
            try (URLClassLoader loader = new URLClassLoader(new URL[]{jarUrl}, this.getClass().getClassLoader())) {
                ServiceLoader<Plugin> serviceLoader = ServiceLoader.load(Plugin.class, loader);
                for (Plugin plugin : serviceLoader) {
                    registerPlugin(plugin);
                }
            }
        } catch (IOException e) {
            logger.error("Failed to load plugin JAR {}: {}", jarPath, e.getMessage());
        }
    }

    
    public void registerPlugin(Plugin plugin) {
        plugins.add(plugin);
        plugin.onEnable();
        logger.info("Enabled plugin: {}", plugin.getClass().getName());
    }

    public void unloadAll() {
        for (Plugin plugin : plugins) {
            plugin.onDisable();
            logger.info("Disabled plugin: {}", plugin.getClass().getName());
        }
        plugins.clear();
    }
}

================
File: main/java/io.github.minemon/utils/OpenSimplex2.java
================
package io.github.minemon.utils;

public class OpenSimplex2 {

    private static final long PRIME_X = 0x5205402B9270C86FL;
    private static final long PRIME_Y = 0x598CD327003817B5L;
    private static final long PRIME_Z = 0x5BCC226E9FA0BACBL;
    private static final long PRIME_W = 0x56CC5227E58F554BL;
    private static final long HASH_MULTIPLIER = 0x53A3F72DEEC546F5L;
    private static final long SEED_FLIP_3D = -0x52D547B2E96ED629L;
    private static final long SEED_OFFSET_4D = 0xE83DC3E0DA7164DL;

    private static final double ROOT2OVER2 = 0.7071067811865476;
    private static final double SKEW_2D = 0.366025403784439;
    private static final double UNSKEW_2D = -0.21132486540518713;

    private static final double ROOT3OVER3 = 0.577350269189626;
    private static final double FALLBACK_ROTATE_3D = 2.0 / 3.0;
    private static final double ROTATE_3D_ORTHOGONALIZER = UNSKEW_2D;

    private static final float SKEW_4D = -0.138196601125011f;
    private static final float UNSKEW_4D = 0.309016994374947f;
    private static final float LATTICE_STEP_4D = 0.2f;

    private static final int N_GRADS_2D_EXPONENT = 7;
    private static final int N_GRADS_3D_EXPONENT = 8;
    private static final int N_GRADS_4D_EXPONENT = 9;
    private static final int N_GRADS_2D = 1 << N_GRADS_2D_EXPONENT;
    private static final int N_GRADS_3D = 1 << N_GRADS_3D_EXPONENT;
    private static final int N_GRADS_4D = 1 << N_GRADS_4D_EXPONENT;

    private static final double NORMALIZER_2D = 0.01001634121365712;
    private static final double NORMALIZER_3D = 0.07969837668935331;
    private static final double NORMALIZER_4D = 0.0220065933241897;

    private static final float RSQUARED_2D = 0.5f;
    private static final float RSQUARED_3D = 0.6f;
    private static final float RSQUARED_4D = 0.6f;


    

    
    public static float noise2(long seed, double x, double y) {


        double s = SKEW_2D * (x + y);
        double xs = x + s, ys = y + s;

        return noise2_UnskewedBase(seed, xs, ys);
    }

    
    public static float noise2_ImproveX(long seed, double x, double y) {


        double xx = x * ROOT2OVER2;
        double yy = y * (ROOT2OVER2 * (1 + 2 * SKEW_2D));

        return noise2_UnskewedBase(seed, yy + xx, yy - xx);
    }

    
    private static float noise2_UnskewedBase(long seed, double xs, double ys) {


        int xsb = fastFloor(xs), ysb = fastFloor(ys);
        float xi = (float)(xs - xsb), yi = (float)(ys - ysb);


        long xsbp = xsb * PRIME_X, ysbp = ysb * PRIME_Y;


        float t = (xi + yi) * (float)UNSKEW_2D;
        float dx0 = xi + t, dy0 = yi + t;


        float value = 0;
        float a0 = RSQUARED_2D - dx0 * dx0 - dy0 * dy0;
        if (a0 > 0) {
            value = (a0 * a0) * (a0 * a0) * grad(seed, xsbp, ysbp, dx0, dy0);
        }


        float a1 = (float)(2 * (1 + 2 * UNSKEW_2D) * (1 / UNSKEW_2D + 2)) * t + ((float)(-2 * (1 + 2 * UNSKEW_2D) * (1 + 2 * UNSKEW_2D)) + a0);
        if (a1 > 0) {
            float dx1 = dx0 - (float)(1 + 2 * UNSKEW_2D);
            float dy1 = dy0 - (float)(1 + 2 * UNSKEW_2D);
            value += (a1 * a1) * (a1 * a1) * grad(seed, xsbp + PRIME_X, ysbp + PRIME_Y, dx1, dy1);
        }


        if (dy0 > dx0) {
            float dx2 = dx0 - (float)UNSKEW_2D;
            float dy2 = dy0 - (float)(UNSKEW_2D + 1);
            float a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if (a2 > 0) {
                value += (a2 * a2) * (a2 * a2) * grad(seed, xsbp, ysbp + PRIME_Y, dx2, dy2);
            }
        }
        else
        {
            float dx2 = dx0 - (float)(UNSKEW_2D + 1);
            float dy2 = dy0 - (float)UNSKEW_2D;
            float a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if (a2 > 0) {
                value += (a2 * a2) * (a2 * a2) * grad(seed, xsbp + PRIME_X, ysbp, dx2, dy2);
            }
        }

        return value;
    }

    
    public static float noise3_ImproveXY(long seed, double x, double y, double z) {




        double xy = x + y;
        double s2 = xy * ROTATE_3D_ORTHOGONALIZER;
        double zz = z * ROOT3OVER3;
        double xr = x + s2 + zz;
        double yr = y + s2 + zz;
        double zr = xy * -ROOT3OVER3 + zz;


        return noise3_UnrotatedBase(seed, xr, yr, zr);
    }

    
    public static float noise3_ImproveXZ(long seed, double x, double y, double z) {




        double xz = x + z;
        double s2 = xz * ROTATE_3D_ORTHOGONALIZER;
        double yy = y * ROOT3OVER3;
        double xr = x + s2 + yy;
        double zr = z + s2 + yy;
        double yr = xz * -ROOT3OVER3 + yy;


        return noise3_UnrotatedBase(seed, xr, yr, zr);
    }

    
    public static float noise3_Fallback(long seed, double x, double y, double z) {



        double r = FALLBACK_ROTATE_3D * (x + y + z);
        double xr = r - x, yr = r - y, zr = r - z;


        return noise3_UnrotatedBase(seed, xr, yr, zr);
    }

    
    private static float noise3_UnrotatedBase(long seed, double xr, double yr, double zr) {


        int xrb = fastRound(xr), yrb = fastRound(yr), zrb = fastRound(zr);
        float xri = (float)(xr - xrb), yri = (float)(yr - yrb), zri = (float)(zr - zrb);


        int xNSign = (int)(-1.0f - xri) | 1, yNSign = (int)(-1.0f - yri) | 1, zNSign = (int)(-1.0f - zri) | 1;


        float ax0 = xNSign * -xri, ay0 = yNSign * -yri, az0 = zNSign * -zri;


        long xrbp = xrb * PRIME_X, yrbp = yrb * PRIME_Y, zrbp = zrb * PRIME_Z;


        float value = 0;
        float a = (RSQUARED_3D - xri * xri) - (yri * yri + zri * zri);
        for (int l = 0; ; l++) {


            if (a > 0) {
                value += (a * a) * (a * a) * grad(seed, xrbp, yrbp, zrbp, xri, yri, zri);
            }


            if (ax0 >= ay0 && ax0 >= az0) {
                float b = a + ax0 + ax0;
                if (b > 1) {
                    b -= 1;
                    value += (b * b) * (b * b) * grad(seed, xrbp - xNSign * PRIME_X, yrbp, zrbp, xri + xNSign, yri, zri);
                }
            }
            else if (ay0 > ax0 && ay0 >= az0) {
                float b = a + ay0 + ay0;
                if (b > 1) {
                    b -= 1;
                    value += (b * b) * (b * b) * grad(seed, xrbp, yrbp - yNSign * PRIME_Y, zrbp, xri, yri + yNSign, zri);
                }
            }
            else
            {
                float b = a + az0 + az0;
                if (b > 1) {
                    b -= 1;
                    value += (b * b) * (b * b) * grad(seed, xrbp, yrbp, zrbp - zNSign * PRIME_Z, xri, yri, zri + zNSign);
                }
            }


            if (l == 1) break;


            ax0 = 0.5f - ax0;
            ay0 = 0.5f - ay0;
            az0 = 0.5f - az0;


            xri = xNSign * ax0;
            yri = yNSign * ay0;
            zri = zNSign * az0;


            a += (0.75f - ax0) - (ay0 + az0);


            xrbp += (xNSign >> 1) & PRIME_X;
            yrbp += (yNSign >> 1) & PRIME_Y;
            zrbp += (zNSign >> 1) & PRIME_Z;


            xNSign = -xNSign;
            yNSign = -yNSign;
            zNSign = -zNSign;


            seed ^= SEED_FLIP_3D;
        }

        return value;
    }

    
    public static float noise4_ImproveXYZ_ImproveXY(long seed, double x, double y, double z, double w) {

        double xy = x + y;
        double s2 = xy * -0.21132486540518699998;
        double zz = z * 0.28867513459481294226;
        double ww = w * 0.2236067977499788;
        double xr = x + (zz + ww + s2), yr = y + (zz + ww + s2);
        double zr = xy * -0.57735026918962599998 + (zz + ww);
        double wr = z * -0.866025403784439 + ww;

        return noise4_UnskewedBase(seed, xr, yr, zr, wr);
    }

    
    public static float noise4_ImproveXYZ_ImproveXZ(long seed, double x, double y, double z, double w) {

        double xz = x + z;
        double s2 = xz * -0.21132486540518699998;
        double yy = y * 0.28867513459481294226;
        double ww = w * 0.2236067977499788;
        double xr = x + (yy + ww + s2), zr = z + (yy + ww + s2);
        double yr = xz * -0.57735026918962599998 + (yy + ww);
        double wr = y * -0.866025403784439 + ww;

        return noise4_UnskewedBase(seed, xr, yr, zr, wr);
    }

    
    public static float noise4_ImproveXYZ(long seed, double x, double y, double z, double w) {

        double xyz = x + y + z;
        double ww = w * 0.2236067977499788;
        double s2 = xyz * -0.16666666666666666 + ww;
        double xs = x + s2, ys = y + s2, zs = z + s2, ws = -0.5 * xyz + ww;

        return noise4_UnskewedBase(seed, xs, ys, zs, ws);
    }

    
    public static float noise4_ImproveXY_ImproveZW(long seed, double x, double y, double z, double w) {

        double s2 = (x + y) * -0.178275657951399372 + (z + w) * 0.215623393288842828;
        double t2 = (z + w) * -0.403949762580207112 + (x + y) * -0.375199083010075342;
        double xs = x + s2, ys = y + s2, zs = z + t2, ws = w + t2;

        return noise4_UnskewedBase(seed, xs, ys, zs, ws);
    }

    
    public static float noise4_Fallback(long seed, double x, double y, double z, double w) {


        double s = SKEW_4D * (x + y + z + w);
        double xs = x + s, ys = y + s, zs = z + s, ws = w + s;

        return noise4_UnskewedBase(seed, xs, ys, zs, ws);
    }

    
    private static float noise4_UnskewedBase(long seed, double xs, double ys, double zs, double ws) {


        int xsb = fastFloor(xs), ysb = fastFloor(ys), zsb = fastFloor(zs), wsb = fastFloor(ws);
        float xsi = (float)(xs - xsb), ysi = (float)(ys - ysb), zsi = (float)(zs - zsb), wsi = (float)(ws - wsb);



        float siSum = (xsi + ysi) + (zsi + wsi);
        int startingLattice = (int)(siSum * 1.25);


        seed += startingLattice * SEED_OFFSET_4D;


        float startingLatticeOffset = startingLattice * -LATTICE_STEP_4D;
        xsi += startingLatticeOffset; ysi += startingLatticeOffset; zsi += startingLatticeOffset; wsi += startingLatticeOffset;


        float ssi = (siSum + startingLatticeOffset * 4) * UNSKEW_4D;


        long xsvp = xsb * PRIME_X, ysvp = ysb * PRIME_Y, zsvp = zsb * PRIME_Z, wsvp = wsb * PRIME_W;


        float value = 0;
        for (int i = 0; ; i++) {


            double score0 = 1.0 + ssi * (-1.0 / UNSKEW_4D);
            if (xsi >= ysi && xsi >= zsi && xsi >= wsi && xsi >= score0) {
                xsvp += PRIME_X;
                xsi -= 1;
                ssi -= UNSKEW_4D;
            }
            else if (ysi > xsi && ysi >= zsi && ysi >= wsi && ysi >= score0) {
                ysvp += PRIME_Y;
                ysi -= 1;
                ssi -= UNSKEW_4D;
            }
            else if (zsi > xsi && zsi > ysi && zsi >= wsi && zsi >= score0) {
                zsvp += PRIME_Z;
                zsi -= 1;
                ssi -= UNSKEW_4D;
            }
            else if (wsi > xsi && wsi > ysi && wsi > zsi && wsi >= score0) {
                wsvp += PRIME_W;
                wsi -= 1;
                ssi -= UNSKEW_4D;
            }


            float dx = xsi + ssi, dy = ysi + ssi, dz = zsi + ssi, dw = wsi + ssi;
            float a = (dx * dx + dy * dy) + (dz * dz + dw * dw);
            if (a < RSQUARED_4D) {
                a -= RSQUARED_4D;
                a *= a;
                value += a * a * grad(seed, xsvp, ysvp, zsvp, wsvp, dx, dy, dz, dw);
            }


            if (i == 4) break;


            xsi += LATTICE_STEP_4D; ysi += LATTICE_STEP_4D; zsi += LATTICE_STEP_4D; wsi += LATTICE_STEP_4D;
            ssi += LATTICE_STEP_4D * 4 * UNSKEW_4D;
            seed -= SEED_OFFSET_4D;


            if (i == startingLattice) {
                xsvp -= PRIME_X;
                ysvp -= PRIME_Y;
                zsvp -= PRIME_Z;
                wsvp -= PRIME_W;
                seed += SEED_OFFSET_4D * 5;
            }
        }

        return value;
    }

    

    private static float grad(long seed, long xsvp, long ysvp, float dx, float dy) {
        long hash = seed ^ xsvp ^ ysvp;
        hash *= HASH_MULTIPLIER;
        hash ^= hash >> (64 - N_GRADS_2D_EXPONENT + 1);
        int gi = (int)hash & ((N_GRADS_2D - 1) << 1);
        return GRADIENTS_2D[gi | 0] * dx + GRADIENTS_2D[gi | 1] * dy;
    }

    private static float grad(long seed, long xrvp, long yrvp, long zrvp, float dx, float dy, float dz) {
        long hash = (seed ^ xrvp) ^ (yrvp ^ zrvp);
        hash *= HASH_MULTIPLIER;
        hash ^= hash >> (64 - N_GRADS_3D_EXPONENT + 2);
        int gi = (int)hash & ((N_GRADS_3D - 1) << 2);
        return GRADIENTS_3D[gi | 0] * dx + GRADIENTS_3D[gi | 1] * dy + GRADIENTS_3D[gi | 2] * dz;
    }

    private static float grad(long seed, long xsvp, long ysvp, long zsvp, long wsvp, float dx, float dy, float dz, float dw) {
        long hash = seed ^ (xsvp ^ ysvp) ^ (zsvp ^ wsvp);
        hash *= HASH_MULTIPLIER;
        hash ^= hash >> (64 - N_GRADS_4D_EXPONENT + 2);
        int gi = (int)hash & ((N_GRADS_4D - 1) << 2);
        return (GRADIENTS_4D[gi | 0] * dx + GRADIENTS_4D[gi | 1] * dy) + (GRADIENTS_4D[gi | 2] * dz + GRADIENTS_4D[gi | 3] * dw);
    }

    private static int fastFloor(double x) {
        int xi = (int)x;
        return x < xi ? xi - 1 : xi;
    }

    private static int fastRound(double x) {
        return x < 0 ? (int)(x - 0.5) : (int)(x + 0.5);
    }

    

    private static float[] GRADIENTS_2D;
    private static float[] GRADIENTS_3D;
    private static float[] GRADIENTS_4D;
    static {

        GRADIENTS_2D = new float[N_GRADS_2D * 2];
        float[] grad2 = {
            0.38268343236509f,   0.923879532511287f,
            0.923879532511287f,  0.38268343236509f,
            0.923879532511287f, -0.38268343236509f,
            0.38268343236509f,  -0.923879532511287f,
            -0.38268343236509f,  -0.923879532511287f,
            -0.923879532511287f, -0.38268343236509f,
            -0.923879532511287f,  0.38268343236509f,
            -0.38268343236509f,   0.923879532511287f,

            0.130526192220052f,  0.99144486137381f,
            0.608761429008721f,  0.793353340291235f,
            0.793353340291235f,  0.608761429008721f,
            0.99144486137381f,   0.130526192220051f,
            0.99144486137381f,  -0.130526192220051f,
            0.793353340291235f, -0.60876142900872f,
            0.608761429008721f, -0.793353340291235f,
            0.130526192220052f, -0.99144486137381f,
            -0.130526192220052f, -0.99144486137381f,
            -0.608761429008721f, -0.793353340291235f,
            -0.793353340291235f, -0.608761429008721f,
            -0.99144486137381f,  -0.130526192220052f,
            -0.99144486137381f,   0.130526192220051f,
            -0.793353340291235f,  0.608761429008721f,
            -0.608761429008721f,  0.793353340291235f,
            -0.130526192220052f,  0.99144486137381f,
        };
        for (int i = 0; i < grad2.length; i++) {
            grad2[i] = (float)(grad2[i] / NORMALIZER_2D);
        }
        for (int i = 0, j = 0; i < GRADIENTS_2D.length; i++, j++) {
            if (j == grad2.length) j = 0;
            GRADIENTS_2D[i] = grad2[j];
        }

        GRADIENTS_3D = new float[N_GRADS_3D * 4];
        float[] grad3 = {
            2.22474487139f,       2.22474487139f,      -1.0f,                 0.0f,
            2.22474487139f,       2.22474487139f,       1.0f,                 0.0f,
            3.0862664687972017f,  1.1721513422464978f,  0.0f,                 0.0f,
            1.1721513422464978f,  3.0862664687972017f,  0.0f,                 0.0f,
            -2.22474487139f,       2.22474487139f,      -1.0f,                 0.0f,
            -2.22474487139f,       2.22474487139f,       1.0f,                 0.0f,
            -1.1721513422464978f,  3.0862664687972017f,  0.0f,                 0.0f,
            -3.0862664687972017f,  1.1721513422464978f,  0.0f,                 0.0f,
            -1.0f,                -2.22474487139f,      -2.22474487139f,       0.0f,
            1.0f,                -2.22474487139f,      -2.22474487139f,       0.0f,
            0.0f,                -3.0862664687972017f, -1.1721513422464978f,  0.0f,
            0.0f,                -1.1721513422464978f, -3.0862664687972017f,  0.0f,
            -1.0f,                -2.22474487139f,       2.22474487139f,       0.0f,
            1.0f,                -2.22474487139f,       2.22474487139f,       0.0f,
            0.0f,                -1.1721513422464978f,  3.0862664687972017f,  0.0f,
            0.0f,                -3.0862664687972017f,  1.1721513422464978f,  0.0f,

            -2.22474487139f,      -2.22474487139f,      -1.0f,                 0.0f,
            -2.22474487139f,      -2.22474487139f,       1.0f,                 0.0f,
            -3.0862664687972017f, -1.1721513422464978f,  0.0f,                 0.0f,
            -1.1721513422464978f, -3.0862664687972017f,  0.0f,                 0.0f,
            -2.22474487139f,      -1.0f,                -2.22474487139f,       0.0f,
            -2.22474487139f,       1.0f,                -2.22474487139f,       0.0f,
            -1.1721513422464978f,  0.0f,                -3.0862664687972017f,  0.0f,
            -3.0862664687972017f,  0.0f,                -1.1721513422464978f,  0.0f,
            -2.22474487139f,      -1.0f,                 2.22474487139f,       0.0f,
            -2.22474487139f,       1.0f,                 2.22474487139f,       0.0f,
            -3.0862664687972017f,  0.0f,                 1.1721513422464978f,  0.0f,
            -1.1721513422464978f,  0.0f,                 3.0862664687972017f,  0.0f,
            -1.0f,                 2.22474487139f,      -2.22474487139f,       0.0f,
            1.0f,                 2.22474487139f,      -2.22474487139f,       0.0f,
            0.0f,                 1.1721513422464978f, -3.0862664687972017f,  0.0f,
            0.0f,                 3.0862664687972017f, -1.1721513422464978f,  0.0f,
            -1.0f,                 2.22474487139f,       2.22474487139f,       0.0f,
            1.0f,                 2.22474487139f,       2.22474487139f,       0.0f,
            0.0f,                 3.0862664687972017f,  1.1721513422464978f,  0.0f,
            0.0f,                 1.1721513422464978f,  3.0862664687972017f,  0.0f,
            2.22474487139f,      -2.22474487139f,      -1.0f,                 0.0f,
            2.22474487139f,      -2.22474487139f,       1.0f,                 0.0f,
            1.1721513422464978f, -3.0862664687972017f,  0.0f,                 0.0f,
            3.0862664687972017f, -1.1721513422464978f,  0.0f,                 0.0f,
            2.22474487139f,      -1.0f,                -2.22474487139f,       0.0f,
            2.22474487139f,       1.0f,                -2.22474487139f,       0.0f,
            3.0862664687972017f,  0.0f,                -1.1721513422464978f,  0.0f,
            1.1721513422464978f,  0.0f,                -3.0862664687972017f,  0.0f,
            2.22474487139f,      -1.0f,                 2.22474487139f,       0.0f,
            2.22474487139f,       1.0f,                 2.22474487139f,       0.0f,
            1.1721513422464978f,  0.0f,                 3.0862664687972017f,  0.0f,
            3.0862664687972017f,  0.0f,                 1.1721513422464978f,  0.0f,
        };
        for (int i = 0; i < grad3.length; i++) {
            grad3[i] = (float)(grad3[i] / NORMALIZER_3D);
        }
        for (int i = 0, j = 0; i < GRADIENTS_3D.length; i++, j++) {
            if (j == grad3.length) j = 0;
            GRADIENTS_3D[i] = grad3[j];
        }

        GRADIENTS_4D = new float[N_GRADS_4D * 4];
        float[] grad4 = {
            -0.6740059517812944f,   -0.3239847771997537f,   -0.3239847771997537f,    0.5794684678643381f,
            -0.7504883828755602f,   -0.4004672082940195f,    0.15296486218853164f,   0.5029860367700724f,
            -0.7504883828755602f,    0.15296486218853164f,  -0.4004672082940195f,    0.5029860367700724f,
            -0.8828161875373585f,    0.08164729285680945f,   0.08164729285680945f,   0.4553054119602712f,
            -0.4553054119602712f,   -0.08164729285680945f,  -0.08164729285680945f,   0.8828161875373585f,
            -0.5029860367700724f,   -0.15296486218853164f,   0.4004672082940195f,    0.7504883828755602f,
            -0.5029860367700724f,    0.4004672082940195f,   -0.15296486218853164f,   0.7504883828755602f,
            -0.5794684678643381f,    0.3239847771997537f,    0.3239847771997537f,    0.6740059517812944f,
            -0.6740059517812944f,   -0.3239847771997537f,    0.5794684678643381f,   -0.3239847771997537f,
            -0.7504883828755602f,   -0.4004672082940195f,    0.5029860367700724f,    0.15296486218853164f,
            -0.7504883828755602f,    0.15296486218853164f,   0.5029860367700724f,   -0.4004672082940195f,
            -0.8828161875373585f,    0.08164729285680945f,   0.4553054119602712f,    0.08164729285680945f,
            -0.4553054119602712f,   -0.08164729285680945f,   0.8828161875373585f,   -0.08164729285680945f,
            -0.5029860367700724f,   -0.15296486218853164f,   0.7504883828755602f,    0.4004672082940195f,
            -0.5029860367700724f,    0.4004672082940195f,    0.7504883828755602f,   -0.15296486218853164f,
            -0.5794684678643381f,    0.3239847771997537f,    0.6740059517812944f,    0.3239847771997537f,
            -0.6740059517812944f,    0.5794684678643381f,   -0.3239847771997537f,   -0.3239847771997537f,
            -0.7504883828755602f,    0.5029860367700724f,   -0.4004672082940195f,    0.15296486218853164f,
            -0.7504883828755602f,    0.5029860367700724f,    0.15296486218853164f,  -0.4004672082940195f,
            -0.8828161875373585f,    0.4553054119602712f,    0.08164729285680945f,   0.08164729285680945f,
            -0.4553054119602712f,    0.8828161875373585f,   -0.08164729285680945f,  -0.08164729285680945f,
            -0.5029860367700724f,    0.7504883828755602f,   -0.15296486218853164f,   0.4004672082940195f,
            -0.5029860367700724f,    0.7504883828755602f,    0.4004672082940195f,   -0.15296486218853164f,
            -0.5794684678643381f,    0.6740059517812944f,    0.3239847771997537f,    0.3239847771997537f,
            0.5794684678643381f,   -0.6740059517812944f,   -0.3239847771997537f,   -0.3239847771997537f,
            0.5029860367700724f,   -0.7504883828755602f,   -0.4004672082940195f,    0.15296486218853164f,
            0.5029860367700724f,   -0.7504883828755602f,    0.15296486218853164f,  -0.4004672082940195f,
            0.4553054119602712f,   -0.8828161875373585f,    0.08164729285680945f,   0.08164729285680945f,
            0.8828161875373585f,   -0.4553054119602712f,   -0.08164729285680945f,  -0.08164729285680945f,
            0.7504883828755602f,   -0.5029860367700724f,   -0.15296486218853164f,   0.4004672082940195f,
            0.7504883828755602f,   -0.5029860367700724f,    0.4004672082940195f,   -0.15296486218853164f,
            0.6740059517812944f,   -0.5794684678643381f,    0.3239847771997537f,    0.3239847771997537f,

            -0.753341017856078f,    -0.37968289875261624f,  -0.37968289875261624f,  -0.37968289875261624f,
            -0.7821684431180708f,   -0.4321472685365301f,   -0.4321472685365301f,    0.12128480194602098f,
            -0.7821684431180708f,   -0.4321472685365301f,    0.12128480194602098f,  -0.4321472685365301f,
            -0.7821684431180708f,    0.12128480194602098f,  -0.4321472685365301f,   -0.4321472685365301f,
            -0.8586508742123365f,   -0.508629699630796f,     0.044802370851755174f,  0.044802370851755174f,
            -0.8586508742123365f,    0.044802370851755174f, -0.508629699630796f,     0.044802370851755174f,
            -0.8586508742123365f,    0.044802370851755174f,  0.044802370851755174f, -0.508629699630796f,
            -0.9982828964265062f,   -0.03381941603233842f,  -0.03381941603233842f,  -0.03381941603233842f,
            -0.37968289875261624f,  -0.753341017856078f,    -0.37968289875261624f,  -0.37968289875261624f,
            -0.4321472685365301f,   -0.7821684431180708f,   -0.4321472685365301f,    0.12128480194602098f,
            -0.4321472685365301f,   -0.7821684431180708f,    0.12128480194602098f,  -0.4321472685365301f,
            0.12128480194602098f,  -0.7821684431180708f,   -0.4321472685365301f,   -0.4321472685365301f,
            -0.508629699630796f,    -0.8586508742123365f,    0.044802370851755174f,  0.044802370851755174f,
            0.044802370851755174f, -0.8586508742123365f,   -0.508629699630796f,     0.044802370851755174f,
            0.044802370851755174f, -0.8586508742123365f,    0.044802370851755174f, -0.508629699630796f,
            -0.03381941603233842f,  -0.9982828964265062f,   -0.03381941603233842f,  -0.03381941603233842f,
            -0.37968289875261624f,  -0.37968289875261624f,  -0.753341017856078f,    -0.37968289875261624f,
            -0.4321472685365301f,   -0.4321472685365301f,   -0.7821684431180708f,    0.12128480194602098f,
            -0.4321472685365301f,    0.12128480194602098f,  -0.7821684431180708f,   -0.4321472685365301f,
            0.12128480194602098f,  -0.4321472685365301f,   -0.7821684431180708f,   -0.4321472685365301f,
            -0.508629699630796f,     0.044802370851755174f, -0.8586508742123365f,    0.044802370851755174f,
            0.044802370851755174f, -0.508629699630796f,    -0.8586508742123365f,    0.044802370851755174f,
            0.044802370851755174f,  0.044802370851755174f, -0.8586508742123365f,   -0.508629699630796f,
            -0.03381941603233842f,  -0.03381941603233842f,  -0.9982828964265062f,   -0.03381941603233842f,
            -0.37968289875261624f,  -0.37968289875261624f,  -0.37968289875261624f,  -0.753341017856078f,
            -0.4321472685365301f,   -0.4321472685365301f,    0.12128480194602098f,  -0.7821684431180708f,
            -0.4321472685365301f,    0.12128480194602098f,  -0.4321472685365301f,   -0.7821684431180708f,
            0.12128480194602098f,  -0.4321472685365301f,   -0.4321472685365301f,   -0.7821684431180708f,
            -0.508629699630796f,     0.044802370851755174f,  0.044802370851755174f, -0.8586508742123365f,
            0.044802370851755174f, -0.508629699630796f,     0.044802370851755174f, -0.8586508742123365f,
            0.044802370851755174f,  0.044802370851755174f, -0.508629699630796f,    -0.8586508742123365f,
            -0.03381941603233842f,  -0.03381941603233842f,  -0.03381941603233842f,  -0.9982828964265062f,
            -0.3239847771997537f,   -0.6740059517812944f,   -0.3239847771997537f,    0.5794684678643381f,
            -0.4004672082940195f,   -0.7504883828755602f,    0.15296486218853164f,   0.5029860367700724f,
            0.15296486218853164f,  -0.7504883828755602f,   -0.4004672082940195f,    0.5029860367700724f,
            0.08164729285680945f,  -0.8828161875373585f,    0.08164729285680945f,   0.4553054119602712f,
            -0.08164729285680945f,  -0.4553054119602712f,   -0.08164729285680945f,   0.8828161875373585f,
            -0.15296486218853164f,  -0.5029860367700724f,    0.4004672082940195f,    0.7504883828755602f,
            0.4004672082940195f,   -0.5029860367700724f,   -0.15296486218853164f,   0.7504883828755602f,
            0.3239847771997537f,   -0.5794684678643381f,    0.3239847771997537f,    0.6740059517812944f,
            -0.3239847771997537f,   -0.3239847771997537f,   -0.6740059517812944f,    0.5794684678643381f,
            -0.4004672082940195f,    0.15296486218853164f,  -0.7504883828755602f,    0.5029860367700724f,
            0.15296486218853164f,  -0.4004672082940195f,   -0.7504883828755602f,    0.5029860367700724f,
            0.08164729285680945f,   0.08164729285680945f,  -0.8828161875373585f,    0.4553054119602712f,
            -0.08164729285680945f,  -0.08164729285680945f,  -0.4553054119602712f,    0.8828161875373585f,
            -0.15296486218853164f,   0.4004672082940195f,   -0.5029860367700724f,    0.7504883828755602f,
            0.4004672082940195f,   -0.15296486218853164f,  -0.5029860367700724f,    0.7504883828755602f,
            0.3239847771997537f,    0.3239847771997537f,   -0.5794684678643381f,    0.6740059517812944f,
            -0.3239847771997537f,   -0.6740059517812944f,    0.5794684678643381f,   -0.3239847771997537f,
            -0.4004672082940195f,   -0.7504883828755602f,    0.5029860367700724f,    0.15296486218853164f,
            0.15296486218853164f,  -0.7504883828755602f,    0.5029860367700724f,   -0.4004672082940195f,
            0.08164729285680945f,  -0.8828161875373585f,    0.4553054119602712f,    0.08164729285680945f,
            -0.08164729285680945f,  -0.4553054119602712f,    0.8828161875373585f,   -0.08164729285680945f,
            -0.15296486218853164f,  -0.5029860367700724f,    0.7504883828755602f,    0.4004672082940195f,
            0.4004672082940195f,   -0.5029860367700724f,    0.7504883828755602f,   -0.15296486218853164f,
            0.3239847771997537f,   -0.5794684678643381f,    0.6740059517812944f,    0.3239847771997537f,
            -0.3239847771997537f,   -0.3239847771997537f,    0.5794684678643381f,   -0.6740059517812944f,
            -0.4004672082940195f,    0.15296486218853164f,   0.5029860367700724f,   -0.7504883828755602f,
            0.15296486218853164f,  -0.4004672082940195f,    0.5029860367700724f,   -0.7504883828755602f,
            0.08164729285680945f,   0.08164729285680945f,   0.4553054119602712f,   -0.8828161875373585f,
            -0.08164729285680945f,  -0.08164729285680945f,   0.8828161875373585f,   -0.4553054119602712f,
            -0.15296486218853164f,   0.4004672082940195f,    0.7504883828755602f,   -0.5029860367700724f,
            0.4004672082940195f,   -0.15296486218853164f,   0.7504883828755602f,   -0.5029860367700724f,
            0.3239847771997537f,    0.3239847771997537f,    0.6740059517812944f,   -0.5794684678643381f,
            -0.3239847771997537f,    0.5794684678643381f,   -0.6740059517812944f,   -0.3239847771997537f,
            -0.4004672082940195f,    0.5029860367700724f,   -0.7504883828755602f,    0.15296486218853164f,
            0.15296486218853164f,   0.5029860367700724f,   -0.7504883828755602f,   -0.4004672082940195f,
            0.08164729285680945f,   0.4553054119602712f,   -0.8828161875373585f,    0.08164729285680945f,
            -0.08164729285680945f,   0.8828161875373585f,   -0.4553054119602712f,   -0.08164729285680945f,
            -0.15296486218853164f,   0.7504883828755602f,   -0.5029860367700724f,    0.4004672082940195f,
            0.4004672082940195f,    0.7504883828755602f,   -0.5029860367700724f,   -0.15296486218853164f,
            0.3239847771997537f,    0.6740059517812944f,   -0.5794684678643381f,    0.3239847771997537f,
            -0.3239847771997537f,    0.5794684678643381f,   -0.3239847771997537f,   -0.6740059517812944f,
            -0.4004672082940195f,    0.5029860367700724f,    0.15296486218853164f,  -0.7504883828755602f,
            0.15296486218853164f,   0.5029860367700724f,   -0.4004672082940195f,   -0.7504883828755602f,
            0.08164729285680945f,   0.4553054119602712f,    0.08164729285680945f,  -0.8828161875373585f,
            -0.08164729285680945f,   0.8828161875373585f,   -0.08164729285680945f,  -0.4553054119602712f,
            -0.15296486218853164f,   0.7504883828755602f,    0.4004672082940195f,   -0.5029860367700724f,
            0.4004672082940195f,    0.7504883828755602f,   -0.15296486218853164f,  -0.5029860367700724f,
            0.3239847771997537f,    0.6740059517812944f,    0.3239847771997537f,   -0.5794684678643381f,
            0.5794684678643381f,   -0.3239847771997537f,   -0.6740059517812944f,   -0.3239847771997537f,
            0.5029860367700724f,   -0.4004672082940195f,   -0.7504883828755602f,    0.15296486218853164f,
            0.5029860367700724f,    0.15296486218853164f,  -0.7504883828755602f,   -0.4004672082940195f,
            0.4553054119602712f,    0.08164729285680945f,  -0.8828161875373585f,    0.08164729285680945f,
            0.8828161875373585f,   -0.08164729285680945f,  -0.4553054119602712f,   -0.08164729285680945f,
            0.7504883828755602f,   -0.15296486218853164f,  -0.5029860367700724f,    0.4004672082940195f,
            0.7504883828755602f,    0.4004672082940195f,   -0.5029860367700724f,   -0.15296486218853164f,
            0.6740059517812944f,    0.3239847771997537f,   -0.5794684678643381f,    0.3239847771997537f,
            0.5794684678643381f,   -0.3239847771997537f,   -0.3239847771997537f,   -0.6740059517812944f,
            0.5029860367700724f,   -0.4004672082940195f,    0.15296486218853164f,  -0.7504883828755602f,
            0.5029860367700724f,    0.15296486218853164f,  -0.4004672082940195f,   -0.7504883828755602f,
            0.4553054119602712f,    0.08164729285680945f,   0.08164729285680945f,  -0.8828161875373585f,
            0.8828161875373585f,   -0.08164729285680945f,  -0.08164729285680945f,  -0.4553054119602712f,
            0.7504883828755602f,   -0.15296486218853164f,   0.4004672082940195f,   -0.5029860367700724f,
            0.7504883828755602f,    0.4004672082940195f,   -0.15296486218853164f,  -0.5029860367700724f,
            0.6740059517812944f,    0.3239847771997537f,    0.3239847771997537f,   -0.5794684678643381f,
            0.03381941603233842f,   0.03381941603233842f,   0.03381941603233842f,   0.9982828964265062f,
            -0.044802370851755174f, -0.044802370851755174f,  0.508629699630796f,     0.8586508742123365f,
            -0.044802370851755174f,  0.508629699630796f,    -0.044802370851755174f,  0.8586508742123365f,
            -0.12128480194602098f,   0.4321472685365301f,    0.4321472685365301f,    0.7821684431180708f,
            0.508629699630796f,    -0.044802370851755174f, -0.044802370851755174f,  0.8586508742123365f,
            0.4321472685365301f,   -0.12128480194602098f,   0.4321472685365301f,    0.7821684431180708f,
            0.4321472685365301f,    0.4321472685365301f,   -0.12128480194602098f,   0.7821684431180708f,
            0.37968289875261624f,   0.37968289875261624f,   0.37968289875261624f,   0.753341017856078f,
            0.03381941603233842f,   0.03381941603233842f,   0.9982828964265062f,    0.03381941603233842f,
            -0.044802370851755174f,  0.044802370851755174f,  0.8586508742123365f,    0.508629699630796f,
            -0.044802370851755174f,  0.508629699630796f,     0.8586508742123365f,   -0.044802370851755174f,
            -0.12128480194602098f,   0.4321472685365301f,    0.7821684431180708f,    0.4321472685365301f,
            0.508629699630796f,    -0.044802370851755174f,  0.8586508742123365f,   -0.044802370851755174f,
            0.4321472685365301f,   -0.12128480194602098f,   0.7821684431180708f,    0.4321472685365301f,
            0.4321472685365301f,    0.4321472685365301f,    0.7821684431180708f,   -0.12128480194602098f,
            0.37968289875261624f,   0.37968289875261624f,   0.753341017856078f,     0.37968289875261624f,
            0.03381941603233842f,   0.9982828964265062f,    0.03381941603233842f,   0.03381941603233842f,
            -0.044802370851755174f,  0.8586508742123365f,   -0.044802370851755174f,  0.508629699630796f,
            -0.044802370851755174f,  0.8586508742123365f,    0.508629699630796f,    -0.044802370851755174f,
            -0.12128480194602098f,   0.7821684431180708f,    0.4321472685365301f,    0.4321472685365301f,
            0.508629699630796f,     0.8586508742123365f,   -0.044802370851755174f, -0.044802370851755174f,
            0.4321472685365301f,    0.7821684431180708f,   -0.12128480194602098f,   0.4321472685365301f,
            0.4321472685365301f,    0.7821684431180708f,    0.4321472685365301f,   -0.12128480194602098f,
            0.37968289875261624f,   0.753341017856078f,     0.37968289875261624f,   0.37968289875261624f,
            0.9982828964265062f,    0.03381941603233842f,   0.03381941603233842f,   0.03381941603233842f,
            0.8586508742123365f,   -0.044802370851755174f, -0.044802370851755174f,  0.508629699630796f,
            0.8586508742123365f,   -0.044802370851755174f,  0.508629699630796f,    -0.044802370851755174f,
            0.7821684431180708f,   -0.12128480194602098f,   0.4321472685365301f,    0.4321472685365301f,
            0.8586508742123365f,    0.508629699630796f,    -0.044802370851755174f, -0.044802370851755174f,
            0.7821684431180708f,    0.4321472685365301f,   -0.12128480194602098f,   0.4321472685365301f,
            0.7821684431180708f,    0.4321472685365301f,    0.4321472685365301f,   -0.12128480194602098f,
            0.753341017856078f,     0.37968289875261624f,   0.37968289875261624f,   0.37968289875261624f,
        };
        for (int i = 0; i < grad4.length; i++) {
            grad4[i] = (float)(grad4[i] / NORMALIZER_4D);
        }
        for (int i = 0, j = 0; i < GRADIENTS_4D.length; i++, j++) {
            if (j == grad4.length) j = 0;
            GRADIENTS_4D[i] = grad4[j];
        }
    }
}

================
File: main/java/io.github.minemon/utils/UUIDSerializer.java
================
package io.github.minemon.utils;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.Serializer;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

import java.util.UUID;

public class UUIDSerializer extends Serializer<UUID> {
    @Override
    public void write(Kryo kryo, Output output, UUID uuid) {
        output.writeLong(uuid.getMostSignificantBits());
        output.writeLong(uuid.getLeastSignificantBits());
    }

    @Override
    public UUID read(Kryo kryo, Input input, Class<UUID> type) {
        long mostSigBits = input.readLong();
        long leastSigBits = input.readLong();
        return new UUID(mostSigBits, leastSigBits);
    }
}

================
File: main/java/io.github.minemon/weather/config/WeatherConfig.java
================
package io.github.minemon.weather.config;

import org.springframework.context.annotation.Configuration;

@Configuration
public class WeatherConfig {
    public float getWeatherCheckInterval() {
        return 10f;
    }

    public int getMaxParticles() {
        return 300;
    }

    public float getMaxParticleSpawnRate() {
        return 300f;
    }

}

================
File: main/java/io.github.minemon/weather/model/WeatherType.java
================
package io.github.minemon.weather.model;

public enum WeatherType {
    CLEAR,
    RAIN,
    HEAVY_RAIN,
    SNOW,
    BLIZZARD,
    SANDSTORM,
    FOG,
    THUNDERSTORM
}

================
File: main/java/io.github.minemon/weather/service/WeatherAudioService.java
================
package io.github.minemon.weather.service;

import io.github.minemon.audio.model.WeatherSoundEffect;
import io.github.minemon.audio.service.AudioService;
import io.github.minemon.weather.model.WeatherType;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;


@Service
@Slf4j
public class WeatherAudioService {

    private static final float THUNDER_MIN_INTERVAL = 5f;
    private static final float THUNDER_MAX_INTERVAL = 15f;

    private float thunderTimer;
    private float nextThunderTime;
    private boolean isThundering;
    @Getter
    private float lightningAlpha;

    @Setter
    private AudioService audioService;

    public WeatherAudioService() {
        resetThunderTimer();
    }

    private void resetThunderTimer() {
        nextThunderTime = randomRange();
        thunderTimer = 0;
    }

    
    public void update(float delta, WeatherType currentWeather, float intensity) {
        updateThunderAndLightning(delta, currentWeather, intensity);
        updateWeatherSounds(currentWeather, intensity);
    }

    private void updateThunderAndLightning(float delta, WeatherType currentWeather, float intensity) {
        if (currentWeather == WeatherType.THUNDERSTORM) {
            thunderTimer += delta;


            if (isThundering) {
                lightningAlpha = Math.max(0, lightningAlpha - delta * 2f);
                if (lightningAlpha <= 0) {
                    isThundering = false;
                }
            }


            if (thunderTimer >= nextThunderTime) {
                triggerThunderAndLightning(intensity);
                resetThunderTimer();
            }
        } else {
            lightningAlpha = 0;
            isThundering = false;
            resetThunderTimer();
        }
    }

    private void triggerThunderAndLightning(float intensity) {
        isThundering = true;
        lightningAlpha = 0.7f * intensity;


        float volume = 0.5f + (intensity * 0.5f);
        float pitch = 0.9f + (randomFloat() * 0.2f);
        if (audioService != null && audioService.isSoundEnabled()) {
            audioService.playWeatherSound(WeatherSoundEffect.THUNDER, volume, pitch);
        } else {
            log.debug("AudioService not available or sound disabled; skipping thunder sound.");
        }
    }

    private void updateWeatherSounds(WeatherType currentWeather, float intensity) {
        if (audioService == null || !audioService.isSoundEnabled()) {
            return;
        }


        switch (currentWeather) {
            case RAIN -> {

                audioService.updateWeatherLoop(WeatherSoundEffect.LIGHT_RAIN, intensity * 0.6f);
                audioService.stopWeatherLoop(WeatherSoundEffect.WIND);
                audioService.stopWeatherLoop(WeatherSoundEffect.SAND_WIND);
            }
            case HEAVY_RAIN, THUNDERSTORM -> {
                audioService.stopWeatherLoop(WeatherSoundEffect.LIGHT_RAIN);
                audioService.stopWeatherLoop(WeatherSoundEffect.WIND);
                audioService.stopWeatherLoop(WeatherSoundEffect.SAND_WIND);
            }
            case SNOW, BLIZZARD -> {

                audioService.updateWeatherLoop(WeatherSoundEffect.WIND, intensity * 0.4f);
                audioService.stopWeatherLoop(WeatherSoundEffect.LIGHT_RAIN);
                audioService.stopWeatherLoop(WeatherSoundEffect.SAND_WIND);
            }
            case SANDSTORM -> {

                audioService.updateWeatherLoop(WeatherSoundEffect.SAND_WIND, intensity * 0.7f);
                audioService.stopWeatherLoop(WeatherSoundEffect.LIGHT_RAIN);
                audioService.stopWeatherLoop(WeatherSoundEffect.WIND);
            }
            default -> {

                audioService.stopWeatherLoop(WeatherSoundEffect.LIGHT_RAIN);
                audioService.stopWeatherLoop(WeatherSoundEffect.WIND);
                audioService.stopWeatherLoop(WeatherSoundEffect.SAND_WIND);
            }
        }
    }

    private float randomFloat() {
        return (float) Math.random();
    }

    private float randomRange() {
        return WeatherAudioService.THUNDER_MIN_INTERVAL + randomFloat() * (WeatherAudioService.THUNDER_MAX_INTERVAL - WeatherAudioService.THUNDER_MIN_INTERVAL);
    }
}

================
File: main/java/io.github.minemon/world/biome/config/BiomeConfig.java
================
package io.github.minemon.world.biome.config;

import lombok.Getter;
import lombok.Setter;

import java.util.HashMap;

@Setter
@Getter
public class BiomeConfig {
    private HashMap<String, HashMap<String, Integer>> biomes;
}

================
File: main/java/io.github.minemon/world/biome/config/BiomeConfigurationLoader.java
================
package io.github.minemon.world.biome.config;

import com.badlogic.gdx.utils.Json;
import io.github.minemon.core.service.FileAccessService;
import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.biome.model.BiomeType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
public class BiomeConfigurationLoader {
    private static final Logger logger = LoggerFactory.getLogger(BiomeConfigurationLoader.class);

    public static class BiomeDefinition {
        public String name;
        public String type;
        public ArrayList<Integer> allowedTileTypes = new ArrayList<>();
        public HashMap<String, Double> tileDistribution = new HashMap<>();
        public ArrayList<String> spawnableObjects = new ArrayList<>();
        public HashMap<String, Double> spawnChances = new HashMap<>();
    }

    public static class BiomeRoot {
        public ArrayList<BiomeDefinition> biomes = new ArrayList<>();
    }

    private final FileAccessService fileAccessService;

    public BiomeConfigurationLoader(FileAccessService fileAccessService) {
        this.fileAccessService = fileAccessService;
    }

    public Map<BiomeType, Biome> loadBiomes(String configFilePath) {
        if (!fileAccessService.exists(configFilePath)) {
            logger.error("Biome config file not found: {}", configFilePath);
            return Collections.emptyMap();
        }

        String jsonContent;
        try {
            jsonContent = fileAccessService.readFile(configFilePath);
        } catch (RuntimeException e) {
            logger.error("Failed to read biome config: {}", e.getMessage());
            return Collections.emptyMap();
        }

        Json json = new Json();
        json.setIgnoreUnknownFields(true);

        BiomeRoot root = json.fromJson(BiomeRoot.class, jsonContent);
        if (root == null || root.biomes.isEmpty()) {
            logger.warn("No biomes found in file: {}", configFilePath);
            return Collections.emptyMap();
        }

        Map<BiomeType, Biome> biomeMap = new HashMap<>();
        for (BiomeDefinition def : root.biomes) {
            BiomeType type;
            try {
                type = BiomeType.valueOf(def.type.toUpperCase());
            } catch (IllegalArgumentException ex) {
                logger.error("Unknown biome type '{}' in config. Skipping...", def.type);
                continue;
            }

            Map<Integer, Double> distribution = new HashMap<>();
            for (Map.Entry<String, Double> entry : def.tileDistribution.entrySet()) {
                try {
                    distribution.put(Integer.valueOf(entry.getKey()), entry.getValue());
                } catch (NumberFormatException ex) {
                    logger.error("Invalid tile type '{}' in distribution for biome '{}'. Skipping this entry.", entry.getKey(), def.name);
                }
            }

            Biome biome = new Biome(
                    def.name,
                    type,
                    def.allowedTileTypes,
                    distribution,
                    def.spawnableObjects,
                    def.spawnChances
            );
            biomeMap.put(type, biome);
        }

        logger.info("Loaded {} biomes from {}", biomeMap.size(), configFilePath);
        return biomeMap;
    }
}

================
File: main/java/io.github.minemon/world/biome/model/Biome.java
================
package io.github.minemon.world.biome.model;

import io.github.minemon.world.model.ObjectType;
import lombok.Getter;

import java.util.List;
import java.util.Map;

@Getter
public class Biome {
    private final String name;

    private BiomeType type;

    private List<Integer> allowedTileTypes;

    private Map<Integer, Double> tileDistribution;

    private List<String> spawnableObjects;

    private Map<String, Double> spawnChances;

    public Biome(String name,
                 BiomeType type,
                 List<Integer> allowedTileTypes,
                 Map<Integer, Double> tileDistribution,
                 List<String> spawnableObjects,
                 Map<String, Double> spawnChances) {
        this.name = name;
        this.type = type;
        this.allowedTileTypes = allowedTileTypes;
        this.tileDistribution = tileDistribution;
        this.spawnableObjects = spawnableObjects;
        this.spawnChances = spawnChances;
    }

    public double getSpawnChanceForObject(ObjectType objType) {
        return spawnChances.getOrDefault(objType.name(), 0.0);
    }
}

================
File: main/java/io.github.minemon/world/biome/model/BiomeTransitionResult.java
================
package io.github.minemon.world.biome.model;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class BiomeTransitionResult {
    private final Biome primaryBiome;
    private final Biome secondaryBiome;
    
    private final float transitionFactor;
}

================
File: main/java/io.github.minemon/world/biome/model/BiomeType.java
================
package io.github.minemon.world.biome.model;

public enum BiomeType {
    PLAINS,
    DESERT,
    SNOW,
    FOREST,
    RAIN_FOREST,
    HAUNTED,
    BIG_MOUNTAINS,
    RUINS
}

================
File: main/java/io.github.minemon/world/biome/service/BiomeService.java
================
package io.github.minemon.world.biome.service;

import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.biome.model.BiomeTransitionResult;
import io.github.minemon.world.biome.model.BiomeType;

public interface BiomeService {
    
    BiomeTransitionResult getBiomeAt(float worldX, float worldY);

    
    Biome getBiome(BiomeType type);

    void init();
    void initWithSeed(long seed);

    
    void debugBiomeDistribution(int samples);
}

================
File: main/java/io.github.minemon/world/biome/service/impl/BiomeServiceImpl.java
================
package io.github.minemon.world.biome.service.impl;

import io.github.minemon.utils.OpenSimplex2;
import io.github.minemon.world.biome.config.BiomeConfigurationLoader;
import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.biome.model.BiomeTransitionResult;
import io.github.minemon.world.biome.model.BiomeType;
import io.github.minemon.world.biome.service.BiomeService;
import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;


@Service
@Slf4j
public class BiomeServiceImpl implements BiomeService {


    private static final float TEMPERATURE_SCALE = 0.00005f;
    private static final float MOISTURE_SCALE = 0.00005f;
    private static final float WARP_SCALE = 0.00001f;
    private static final float WARP_STRENGTH = 30f;
    private static final double TRANSITION_BASE = 0.15;
    private final BiomeConfigurationLoader configurationLoader;
    private long baseSeed;
    private long temperatureSeed;
    private long moistureSeed;
    private long warpSeed;
    private Map<BiomeType, Biome> biomes = new HashMap<>();

    public BiomeServiceImpl(BiomeConfigurationLoader configurationLoader) {
        this.configurationLoader = configurationLoader;
    }

    public void initWithSeed(long seed) {
        this.baseSeed = seed;
        this.temperatureSeed = seed + 1000;
        this.moistureSeed = seed + 2000;
        this.warpSeed = seed + 4000;
    }


    @PostConstruct
    @Override
    public void init() {
        this.biomes = configurationLoader.loadBiomes("config/biomes.json");
        if (biomes.isEmpty()) {
            log.warn("No biomes loaded - using defaults.");
        } else {
            log.info("Loaded {} biomes.", biomes.size());
        }
    }

    @Override
    public BiomeTransitionResult getBiomeAt(float worldX, float worldY) {
        float[] warped = domainWarp(worldX, worldY);
        double temperature = getNoiseValue(warped[0], warped[1], temperatureSeed, TEMPERATURE_SCALE);
        double moisture = getNoiseValue(warped[0], warped[1], moistureSeed, MOISTURE_SCALE);


        BiomeType primaryType = determineBiomeType(temperature, moisture);


        double edgeNoise = getNoiseValue(worldX, worldY, warpSeed, TEMPERATURE_SCALE * 2);
        double transitionThreshold = TRANSITION_BASE + edgeNoise * 0.05;

        if (shouldBlendBiomes(temperature, moisture, transitionThreshold)) {

            float[] offsetWarp = domainWarp(worldX + 64, worldY + 64);
            double temp2 = getNoiseValue(offsetWarp[0], offsetWarp[1], temperatureSeed, TEMPERATURE_SCALE);
            double moist2 = getNoiseValue(offsetWarp[0], offsetWarp[1], moistureSeed, MOISTURE_SCALE);
            BiomeType secondaryType = determineBiomeType(temp2, moist2);

            if (primaryType != secondaryType && areCompatibleBiomes(primaryType, secondaryType)) {
                float transitionFactor = computeTransitionFactor(temperature, moisture, transitionThreshold);
                return new BiomeTransitionResult(getBiome(primaryType), getBiome(secondaryType), transitionFactor);
            }
        }


        return new BiomeTransitionResult(getBiome(primaryType), null, 1.0f);
    }


    private float computeTransitionFactor(double temperature, double moisture, double threshold) {

        double tempDelta = Math.abs(temperature - 0.5);
        double moistDelta = Math.abs(moisture - 0.5);
        double maxDelta = Math.max(tempDelta, moistDelta);

        double factor = maxDelta / threshold;
        return (float) Math.min(Math.max(factor, 0.0), 1.0);
    }


    private boolean shouldBlendBiomes(double temperature, double moisture, double transitionThreshold) {
        return (Math.abs(temperature - 0.5) < transitionThreshold ||
                Math.abs(moisture - 0.5) < transitionThreshold);
    }


    private BiomeType determineBiomeType(double temperature, double moisture) {

        if (temperature < 0.35) {
            return (moisture > 0.65) ? BiomeType.DESERT : BiomeType.PLAINS;
        } else if (temperature > 0.65) {
            return (moisture < 0.35) ? BiomeType.DESERT : BiomeType.PLAINS;
        } else {
            return BiomeType.PLAINS;
        }
    }


    private float[] domainWarp(float x, float y) {
        float[] warped = new float[]{x, y};
        float amplitude = WARP_STRENGTH;
        float frequency = WARP_SCALE;

        for (int i = 0; i < 3; i++) {
            float warpX = (float) OpenSimplex2.noise2(warpSeed + i, warped[0] * frequency, warped[1] * frequency) * amplitude;
            float warpY = (float) OpenSimplex2.noise2(warpSeed + i + 1000, warped[0] * frequency, warped[1] * frequency) * amplitude;

            warped[0] += warpX;
            warped[1] += warpY;

            amplitude *= 0.5f;
            frequency *= 1.8f;
        }
        return warped;
    }


    private double getNoiseValue(float x, float y, long seed, float scale) {
        double value = 0;
        double amplitude = 1.0;
        double frequency = 1.0;
        double maxAmplitude = 0;


        for (int i = 0; i < 3; i++) {
            double n = OpenSimplex2.noise2(seed + i, x * scale * frequency, y * scale * frequency);
            value += amplitude * n;
            maxAmplitude += amplitude;
            amplitude *= 0.5;
            frequency *= 2.0;
        }

        value = (value / maxAmplitude + 1) / 2;
        return Math.max(0.0, Math.min(1.0, Math.pow(value, 1.1)));
    }


    private boolean areCompatibleBiomes(BiomeType a, BiomeType b) {
        if (a == b) return true;

        if (a == BiomeType.PLAINS && b == BiomeType.FOREST) return true;

        return true;
    }

    @Override
    public Biome getBiome(BiomeType type) {
        Biome biome = biomes.get(type);
        if (biome == null) {
            log.error("Missing biome type: {}. Falling back to PLAINS.", type);
            return biomes.getOrDefault(BiomeType.PLAINS, new Biome("Plains", BiomeType.PLAINS, null, null, null, null));
        }
        return biome;
    }

    @Override
    public void debugBiomeDistribution(int samples) {

        Map<BiomeType, Integer> distribution = new HashMap<>();
        for (int i = 0; i < samples; i++) {
            float x = (float) Math.random() * 1000;
            float y = (float) Math.random() * 1000;
            BiomeTransitionResult result = getBiomeAt(x, y);
            BiomeType type = result.getPrimaryBiome().getType();
            distribution.merge(type, 1, Integer::sum);
        }

        log.info("=== Biome Distribution ({} samples) ===", samples);
        for (Map.Entry<BiomeType, Integer> entry : distribution.entrySet()) {
            double perc = (entry.getValue() * 100.0) / samples;
            log.info("{}: {} ({}%)", entry.getKey(), entry.getValue(), perc);
        }
        log.info("======================================");
    }
}

================
File: main/java/io.github.minemon/world/config/TileConfig.java
================
package io.github.minemon.world.config;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Setter
@Getter
public class TileConfig {
    private List<TileDefinition> tiles;

    @Setter
    @Getter
    public static class TileDefinition {
        private int id;
        private String name;
        private String texture;
        private boolean passable;

    }
}

================
File: main/java/io.github.minemon/world/config/WorldConfig.java
================
package io.github.minemon.world.config;

import lombok.Getter;

@Getter
public class WorldConfig {
    private final long seed;
    private final int chunkSize = 16;
    private final int tileSize = 32;

    public WorldConfig(long seed) {
        this.seed = seed;
    }

}

================
File: main/java/io.github.minemon/world/config/WorldConfiguration.java
================
package io.github.minemon.world.config;

import io.github.minemon.world.service.impl.JsonWorldDataService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class WorldConfiguration {

    @Value("${world.seed:12345}")
    private long seed;

    @Bean(name = "clientJsonWorldDataService")
    public JsonWorldDataService clientJsonWorldDataService() {
        return new JsonWorldDataService("save/worlds", false);
    }
    @Bean
    public WorldConfig worldConfig() {
        return new WorldConfig(seed);
    }
}

================
File: main/java/io.github.minemon/world/event/ChunkLoadEvent.java
================
package io.github.minemon.world.event;

import io.github.minemon.event.Event;
import lombok.Getter;

@Getter
public class ChunkLoadEvent implements Event {
    private final int chunkX;
    private final int chunkY;

    public ChunkLoadEvent(int chunkX, int chunkY) {
        this.chunkX = chunkX;
        this.chunkY = chunkY;
    }

}

================
File: main/java/io.github.minemon/world/event/WorldObjectRemoveEvent.java
================
package io.github.minemon.world.event;

import lombok.Getter;
import org.springframework.context.ApplicationEvent;

@Getter
public class WorldObjectRemoveEvent extends ApplicationEvent {
    private final String objectId;

    public WorldObjectRemoveEvent(Object source, String objectId) {
        super(source);
        this.objectId = objectId;
    }
}

================
File: main/java/io.github.minemon/world/event/WorldObjectSpawnEvent.java
================
package io.github.minemon.world.event;

import io.github.minemon.world.model.WorldObject;
import lombok.Getter;
import org.springframework.context.ApplicationEvent;

@Getter
public class WorldObjectSpawnEvent extends ApplicationEvent {
    private final WorldObject worldObject;

    public WorldObjectSpawnEvent(Object source, WorldObject worldObject) {
        super(source);
        this.worldObject = worldObject;
    }
}

================
File: main/java/io.github.minemon/world/model/ChunkData.java
================
package io.github.minemon.world.model;

import lombok.Data;

import java.io.*;
import java.util.List;

@Data
public class ChunkData {
    private int chunkX;
    private int chunkY;

    private int[][] tiles;

    private List<WorldObject> objects;

    private transient byte[] tilesBlob;

    public int[][] getTiles() {
        if (tiles == null && tilesBlob != null) {
            tiles = deserializeTiles(tilesBlob);
        }
        return tiles;
    }

    public void setTiles(int[][] tiles) {
        this.tiles = tiles;
        this.tilesBlob = serializeTiles(tiles);
    }

    private byte[] serializeTiles(int[][] tiles) {
        if (tiles == null) return null;
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
             ObjectOutputStream oos = new ObjectOutputStream(baos)) {
            oos.writeObject(tiles);
            return baos.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException("Failed to serialize tiles", e);
        }
    }

    private int[][] deserializeTiles(byte[] data) {
        if (data == null) return null;
        try (ByteArrayInputStream bais = new ByteArrayInputStream(data);
             ObjectInputStream ois = new ObjectInputStream(bais)) {
            return (int[][]) ois.readObject();
        } catch (IOException | ClassNotFoundException e) {
            throw new RuntimeException("Failed to deserialize tiles", e);
        }
    }
}

================
File: main/java/io.github.minemon/world/model/ObjectRenderState.java
================
package io.github.minemon.world.model;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Component
public class ObjectRenderState {
    private static final float FADE_DURATION = 0.5f;
    private final Map<String, Float> objectFadeStates = new ConcurrentHashMap<>();
    private final Map<String, WorldObject> objectCache = new ConcurrentHashMap<>();

    @Autowired
    private WorldService worldService;

    /**
     * Render a "full" texture for the given WorldObject,
     * automatically incrementing its alpha from 0..1.
     */
    public void renderObject(SpriteBatch batch, WorldObject obj, TextureRegion texture, float delta) {
        if (texture == null) return;

        // Cache the object for later lookup
        objectCache.put(obj.getId(), obj);

        // Get or initialize fade state
        float fadeState = objectFadeStates.computeIfAbsent(obj.getId(), k -> 0f);

        // Update fade state
        if (fadeState < 1.0f) {
            fadeState = Math.min(1.0f, fadeState + (delta / FADE_DURATION));
            objectFadeStates.put(obj.getId(), fadeState);
        }

        // Apply fade state
        Color c = batch.getColor();
        batch.setColor(c.r, c.g, c.b, fadeState);

        float x = obj.getTileX() * 32;
        float y = obj.getTileY() * 32;
        int width = obj.getType().getWidthInTiles() * 32;
        int height = obj.getType().getHeightInTiles() * 32;



        batch.draw(texture, x, y, width, height);

        // Restore color
        batch.setColor(c.r, c.g, c.b, 1f);
    }

    /**
     * Overload for partial textures (e.g. top or base of a tree).
     * Lets you define the exact region & draw location/size.
     */
    public void renderObject(
        SpriteBatch batch, WorldObject obj,
        TextureRegion texture, float delta,
        float drawX, float drawY,
        float drawWidth, float drawHeight
    ) {
        if (texture == null) return;

        // Same alpha logic
        objectCache.put(obj.getId(), obj);
        float fadeState = objectFadeStates.computeIfAbsent(obj.getId(), k -> 0f);
        if (fadeState < 1.0f) {
            fadeState = Math.min(1.0f, fadeState + (delta / FADE_DURATION));
            objectFadeStates.put(obj.getId(), fadeState);
        }

        Color c = batch.getColor();
        batch.setColor(c.r, c.g, c.b, fadeState);

        batch.draw(texture, drawX, drawY, drawWidth, drawHeight);

        batch.setColor(c.r, c.g, c.b, 1f);
    }

    /**
     * Periodically call this to remove objects that are far outside the view.
     */
    public void clearInvisibleObjects(Rectangle viewBounds) {
        // Expand view bounds slightly to prevent premature clearing
        Rectangle expandedBounds = new Rectangle(
            viewBounds.x - 64,
            viewBounds.y - 64,
            viewBounds.width + 128,
            viewBounds.height + 128
        );

        objectFadeStates.keySet().removeIf(id -> {
            WorldObject obj = getObjectById(id);
            if (obj == null) {
                objectCache.remove(id);
                return true;
            }

            float objX = obj.getTileX() * 32;
            float objY = obj.getTileY() * 32;

            boolean visible = expandedBounds.contains(objX, objY);
            if (!visible) {
                objectCache.remove(id);
                return true;
            }
            return false;
        });
    }

    private WorldObject getObjectById(String id) {
        // First check cache
        WorldObject cached = objectCache.get(id);
        if (cached != null) {
            return cached;
        }

        // If not in cache, search visible objects
        Rectangle searchBounds = calculateSearchBounds();
        List<WorldObject> visibleObjects = worldService.getVisibleObjects(searchBounds);

        for (WorldObject obj : visibleObjects) {
            if (obj.getId().equals(id)) {
                objectCache.put(id, obj);
                return obj;
            }
        }

        return null;
    }

    private Rectangle calculateSearchBounds() {
        float width = worldService.getCamera().viewportWidth * worldService.getCamera().zoom;
        float height = worldService.getCamera().viewportHeight * worldService.getCamera().zoom;

        return new Rectangle(
            worldService.getCamera().position.x - (width / 2) - 128,
            worldService.getCamera().position.y - (height / 2) - 128,
            width + 256,
            height + 256
        );
    }

    private boolean isTreeType(ObjectType type) {
        return type == ObjectType.TREE_0 ||
            type == ObjectType.TREE_1 ||
            type == ObjectType.SNOW_TREE ||
            type == ObjectType.HAUNTED_TREE ||
            type == ObjectType.RUINS_TREE ||
            type == ObjectType.APRICORN_TREE ||
            type == ObjectType.RAIN_TREE ||
            type == ObjectType.CHERRY_TREE;
    }

    public void reset() {
        objectFadeStates.clear();
        objectCache.clear();
    }

    public boolean hasObject(String id) {
        return objectCache.containsKey(id) || objectFadeStates.containsKey(id);
    }

    public float getFadeState(String id) {
        return objectFadeStates.getOrDefault(id, 0f);
    }
}

================
File: main/java/io.github.minemon/world/model/ObjectType.java
================
package io.github.minemon.world.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum ObjectType {

    TREE_0(true, true, 2, 3, RenderLayer.LAYERED, "treeONE"),
    TREE_1(true, true, 2, 3, RenderLayer.LAYERED, "treeTWO"),
    SNOW_TREE(true, true, 2, 3, RenderLayer.LAYERED, "snow_tree"),
    HAUNTED_TREE(true, true, 2, 3, RenderLayer.LAYERED, "haunted_tree"),
    RUINS_TREE(true, true, 2, 3, RenderLayer.LAYERED, "ruins_tree"),
    APRICORN_TREE(true, true, 3, 3, RenderLayer.LAYERED, "apricorn_tree_grown"),


    CACTUS(true, true, 1, 2, RenderLayer.BELOW_PLAYER, "desert_cactus"),
    DEAD_TREE(true, true, 1, 2, RenderLayer.BELOW_PLAYER, "dead_tree"),
    SMALL_HAUNTED_TREE(true, true, 1, 2, RenderLayer.BELOW_PLAYER, "small_haunted_tree"),
    BUSH(true, true, 3, 2, RenderLayer.BELOW_PLAYER, "bush"),
    VINES(true, false, 1, 2, RenderLayer.BELOW_PLAYER, "vines"),
    RUIN_POLE(true, true, 1, 3, RenderLayer.BELOW_PLAYER, "ruins_pole"),
    POKEBALL(true, true, 1, 1, RenderLayer.BELOW_PLAYER, "pokeball"),
    RAIN_TREE(true, true, 2, 3, RenderLayer.LAYERED, "rain_tree"),
    CHERRY_TREE(true, true, 2, 3, RenderLayer.LAYERED, "CherryTree"),
    SUNFLOWER(true, false, 1, 2, RenderLayer.BELOW_PLAYER, "sunflower");

    private final boolean isPermanent;
    private final boolean isCollidable;
    private final int widthInTiles;
    private final int heightInTiles;
    private final RenderLayer renderLayer;
    private final String textureRegionName;

    public enum RenderLayer {
        BELOW_PLAYER,
        ABOVE_PLAYER,
        LAYERED,
        ABOVE_TALL_GRASS
    }
}

================
File: main/java/io.github.minemon/world/model/WorldData.java
================
package io.github.minemon.world.model;

import java.util.HashMap;
import java.util.Map;

import io.github.minemon.player.model.PlayerData;
import lombok.Getter;
import lombok.Setter;

@Getter
public class WorldData {
    @Setter
    private String worldName;
    @Setter
    private long seed;
    private final Map<String, PlayerData> players = new HashMap<>();
    private final Map<String, ChunkData> chunks = new HashMap<>();

    @Setter
    private long createdDate;
    @Setter
    private long lastPlayed;
    @Setter
    private long playedTime; 
}

================
File: main/java/io.github.minemon/world/model/WorldMetadata.java
================
package io.github.minemon.world.model;


import lombok.Data;

@Data
public class WorldMetadata {

    private String worldName;

    private long seed;
    private long createdDate;
    private long lastPlayed;
    private long playedTime;
}

================
File: main/java/io.github.minemon/world/model/WorldObject.java
================
package io.github.minemon.world.model;

import com.badlogic.gdx.math.Rectangle;

import lombok.Data;

import java.util.UUID;


@Data
public class WorldObject {

    private String id;

    private int tileX;
    private int tileY;

    private ObjectType type;

    private float spawnTime;
    private boolean collidable;


    private float timeSinceVisible;

    public WorldObject() {

    }

    public WorldObject(int tileX, int tileY, ObjectType type, boolean collidable) {
        this.tileX = tileX;
        this.tileY = tileY;
        this.type = type;
        this.collidable = collidable;
        this.id = UUID.randomUUID().toString();
        this.spawnTime = type.isPermanent() ? 0f : (System.currentTimeMillis() / 1000f);
        this.timeSinceVisible = 0f;
    }



    public float getFadeAlpha() {
        return Math.min(timeSinceVisible, 1f);
    }


    public Rectangle getCollisionBox() {
        if (!collidable) return null;

        float pixelX = tileX * 32;
        float pixelY = tileY * 32;

        if (type == ObjectType.APRICORN_TREE) {
            float width = 3 * 32;
            float height = 2 * 32;
            float offsetX = -32;

            return new Rectangle(
                pixelX + offsetX,
                pixelY,
                width,
                height
            );
        } else if (isTreeType(type)) {
            return new Rectangle(
                pixelX,
                pixelY,
                2 * 32,
                2 * 32
            );
        }

        return new Rectangle(
            pixelX,
            pixelY,
            type.getWidthInTiles() * 32,
            type.getHeightInTiles() * 32
        );
    }

    private boolean isTreeType(ObjectType t) {
        return t == ObjectType.TREE_0 ||
                t == ObjectType.TREE_1 ||
                t == ObjectType.SNOW_TREE ||
                t == ObjectType.HAUNTED_TREE ||
                t == ObjectType.RUINS_TREE ||
                t == ObjectType.APRICORN_TREE ||
                t == ObjectType.RAIN_TREE ||
                t == ObjectType.CHERRY_TREE;
    }
}

================
File: main/java/io.github.minemon/world/model/WorldRenderer.java
================
package io.github.minemon.world.model;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import io.github.minemon.world.service.TileManager;
import io.github.minemon.world.service.WorldService;
import io.github.minemon.world.service.impl.ObjectTextureManager;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.*;

@Component
@Slf4j
public class WorldRenderer {
    private static final int TILE_SIZE = 32;
    private static final int CHUNK_SIZE = 16;
    private static final int VIEW_PADDING = 5;
    private static final Color VOID_COLOR = new Color(0.1f, 0.1f, 0.1f, 1f);

    private final TileManager tileManager;
    private final WorldService worldService;
    private final ObjectTextureManager objectTextureManager;
    private final List<TreeTopRender> treeTopQueue = new ArrayList<>();

    private SpriteBatch batch;
    private boolean initialized = false;

    @Autowired
    private ObjectRenderState objectRenderState;

    public WorldRenderer(WorldService worldService,
                         TileManager tileManager,
                         ObjectTextureManager objectTextureManager) {
        this.worldService = worldService;
        this.tileManager = tileManager;
        this.objectTextureManager = objectTextureManager;
    }

    public void initialize() {
        if (!initialized) {
            this.batch = new SpriteBatch();
            initialized = true;
        }
    }

    public void cleanup() {
        objectRenderState.reset();
    }

    /**
     * Main entry point for rendering the world. Now includes a 'delta' param.
     */
    public void render(OrthographicCamera camera, float delta) {
        if (!initialized || batch == null) {
            initialize();
        }

        // Clear any faded-out objects if needed
        Rectangle viewBounds = calculateViewBounds();
        objectRenderState.clearInvisibleObjects(viewBounds);

        batch.setProjectionMatrix(camera.combined);
        batch.begin();

        treeTopQueue.clear();

        // Render the ground tiles (chunks)
        renderGroundLayer();

        // Render objects below the player
        renderBelowPlayerLayer(delta);

        batch.end();
    }

    /**
     * After everything else, call this to draw the "tops" of trees above the player.
     */
    public void renderTreeTops(float delta) {
        if (treeTopQueue.isEmpty()) return;

        batch.begin();
        for (TreeTopRender top : treeTopQueue) {
            objectRenderState.renderObject(
                batch,
                top.getSourceObject(),
                top.getTexture(),
                delta,
                top.getX(), top.getY(),
                top.getWidth(), top.getHeight()
            );
        }
        batch.end();
    }

    private void renderBelowPlayerLayer(float delta) {
        Rectangle viewBounds = calculateViewBounds();
        List<WorldObject> objects = worldService.getVisibleObjects(viewBounds);

        // 1) Non-tree objects
        objects.stream()
            .filter(obj -> !isTreeType(obj.getType()))
            .sorted(Comparator.comparingInt(WorldObject::getTileY))
            .forEach(obj -> renderRegularObject(obj, delta));

        // 2) Trees (split base vs. top)
        objects.stream()
            .filter(obj -> isTreeType(obj.getType()))
            .sorted(Comparator.comparingInt(WorldObject::getTileY))
            .forEach(obj -> {
                renderTreeBase(obj, delta);
                queueTreeTop(obj);
            });
    }

    private void renderRegularObject(WorldObject obj, float delta) {
        TextureRegion texture = objectTextureManager.getTexture(
            obj.getType().getTextureRegionName());
        if (texture == null) return;

        // Delegate drawing + fade logic to objectRenderState
        objectRenderState.renderObject(batch, obj, texture, delta);
    }
    private void renderTreeBase(WorldObject tree, float delta) {
        TextureRegion full = objectTextureManager.getTexture(tree.getType().getTextureRegionName());

        int totalW = full.getRegionWidth();
        int totalH = full.getRegionHeight();

        // Example: 70% base, 30% top
        int basePx = (int)(totalH * 0.7f);
        TextureRegion baseRegion = new TextureRegion(full, 0, totalH - basePx, totalW, basePx);

        int tileW = tree.getType().getWidthInTiles();  // 2
        int tileH = tree.getType().getHeightInTiles(); // 3

        int finalW = tileW * 32; // 64
        int finalH = tileH * 32; // 96

        // For the trunk to sit EXACTLY on the bottom 2 tiles:
        // We do NOT shift left by 32. We just place it at tileX*32
        float drawX = tree.getTileX() * 32f;
        float drawY = tree.getTileY() * 32f;

        // The base is 70% of finalH
        float baseHeight = finalH * 0.7f; // e.g. 96 * 0.7 = 67.2 → ~67

        // Draw it flush at (drawX, drawY)
        objectRenderState.renderObject(batch, tree,
            baseRegion, delta,
            drawX, drawY,  // no offset
            finalW, baseHeight
        );
    }
    private void queueTreeTop(WorldObject tree) {
        TextureRegion fullTexture = objectTextureManager.getTexture(
            tree.getType().getTextureRegionName()
        );
        if (fullTexture == null) return;

        int totalWidth  = fullTexture.getRegionWidth();
        int totalHeight = fullTexture.getRegionHeight();

        // For a 70% base, top is 30%
        int basePx = (int) (totalHeight * 0.7f);
        int topPx  = totalHeight - basePx; // 30%

        TextureRegion topRegion = new TextureRegion(
            fullTexture,
            0,
            0,          // top is physically at Y=0 in the image
            totalWidth,
            topPx
        );

        // Convert tile size
        int tileW = tree.getType().getWidthInTiles();    // e.g., 2
        int tileH = tree.getType().getHeightInTiles();   // e.g., 3
        int finalWidthPx  = tileW * TILE_SIZE;           // 64 for a 2-tile wide
        int finalHeightPx = tileH * TILE_SIZE;           // 96 for a 3-tile tall

        // The base is 70%, top is 30%
        int baseHeightPx = (int) (finalHeightPx * 0.7f);         int topHeightPx  = finalHeightPx - baseHeightPx;

        float drawX = tree.getTileX() * TILE_SIZE;
        float drawY = tree.getTileY() * TILE_SIZE + baseHeightPx;

        drawY -= 1f;

        TreeTopRender topData = new TreeTopRender(
            topRegion,
            drawX, drawY,
            finalWidthPx,
            topHeightPx,
            tree
        );
        treeTopQueue.add(topData);
    }


    private boolean isTreeType(ObjectType type) {
        return type == ObjectType.TREE_0 ||
            type == ObjectType.TREE_1 ||
            type == ObjectType.SNOW_TREE ||
            type == ObjectType.HAUNTED_TREE ||
            type == ObjectType.RUINS_TREE ||
            type == ObjectType.APRICORN_TREE ||
            type == ObjectType.RAIN_TREE ||
            type == ObjectType.CHERRY_TREE;
    }

    private Rectangle calculateViewBounds() {
        OrthographicCamera camera = worldService.getCamera();
        float width = camera.viewportWidth * camera.zoom;
        float height = camera.viewportHeight * camera.zoom;

        return new Rectangle(
            camera.position.x - (width / 2) - (TILE_SIZE * VIEW_PADDING),
            camera.position.y - (height / 2) - (TILE_SIZE * VIEW_PADDING),
            width + (TILE_SIZE * VIEW_PADDING * 2),
            height + (TILE_SIZE * VIEW_PADDING * 2)
        );
    }

    private void renderGroundLayer() {
        Rectangle viewBounds = calculateViewBounds();
        Map<String, ChunkData> visibleChunks = worldService.getVisibleChunks(viewBounds);

        // Draw "void" for unloaded chunks
        batch.setColor(VOID_COLOR);
        for (int x = (int) viewBounds.x; x < viewBounds.x + viewBounds.width; x += CHUNK_SIZE * TILE_SIZE) {
            for (int y = (int) viewBounds.y; y < viewBounds.y + viewBounds.height; y += CHUNK_SIZE * TILE_SIZE) {
                int chunkX = x / (CHUNK_SIZE * TILE_SIZE);
                int chunkY = y / (CHUNK_SIZE * TILE_SIZE);
                String key = chunkX + "," + chunkY;
                if (!visibleChunks.containsKey(key)) {
                    // draw a placeholder
                    batch.draw(tileManager.getRegionForTile(0), x, y,
                        CHUNK_SIZE * TILE_SIZE, CHUNK_SIZE * TILE_SIZE);
                }
            }
        }
        batch.setColor(Color.WHITE);

        // Now draw actual loaded chunks
        for (ChunkData chunk : visibleChunks.values()) {
            renderChunk(chunk);
        }
    }

    private void renderChunk(ChunkData chunk) {
        if (chunk == null || chunk.getTiles() == null) return;

        int chunkPixelX = chunk.getChunkX() * CHUNK_SIZE * TILE_SIZE;
        int chunkPixelY = chunk.getChunkY() * CHUNK_SIZE * TILE_SIZE;

        int[][] tiles = chunk.getTiles();
        for (int x = 0; x < CHUNK_SIZE; x++) {
            for (int y = 0; y < CHUNK_SIZE; y++) {
                TextureRegion region = tileManager.getRegionForTile(tiles[x][y]);
                if (region != null) {
                    float worldX = chunkPixelX + (x * TILE_SIZE);
                    float worldY = chunkPixelY + (y * TILE_SIZE);
                    batch.draw(region, worldX, worldY, TILE_SIZE, TILE_SIZE);
                } else {
                    log.error("No texture region for tile ID {} at {},{}", tiles[x][y], x, y);
                }
            }
        }
    }

    public void dispose() {
        if (batch != null) {
            batch.dispose();
            batch = null;
        }
        cleanup();
    }

    @AllArgsConstructor
    @Getter
    private static class TreeTopRender {
        private final TextureRegion texture;
        private final float x;
        private final float y;
        private final float width;
        private final float height;

        /**
         * The same WorldObject, so we can fade it using the same ID.
         */
        private final WorldObject sourceObject;
    }
}

================
File: main/java/io.github.minemon/world/service/ChunkLoaderService.java
================
package io.github.minemon.world.service;

import com.badlogic.gdx.math.Vector2;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.*;

@Service
public class ChunkLoaderService {
    private static final int VISIBLE_RADIUS = 2;
    private static final int PRELOAD_RADIUS = 4;

    private final Map<Vector2, Float> chunkFadeStates = new ConcurrentHashMap<>();
    private final Set<Vector2> preloadedChunks = Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final WorldService worldService;
    private final ExecutorService executorService;
    private final Map<Vector2, CompletableFuture<Void>> loadingChunks = new ConcurrentHashMap<>();
    public ChunkLoaderService(WorldService worldService) {
        this.worldService = worldService;
        this.executorService = Executors.newFixedThreadPool(4);
    }

    public void updatePlayerPosition(float playerX, float playerY) {
        int chunkX = (int) Math.floor(playerX / (16 * 32));
        int chunkY = (int) Math.floor(playerY / (16 * 32));


        Set<Vector2> requiredChunks = new HashSet<>();
        for (int dx = -PRELOAD_RADIUS; dx <= PRELOAD_RADIUS; dx++) {
            for (int dy = -PRELOAD_RADIUS; dy <= PRELOAD_RADIUS; dy++) {
                requiredChunks.add(new Vector2(chunkX + dx, chunkY + dy));
            }
        }


        for (Vector2 chunkPos : requiredChunks) {
            if (!preloadedChunks.contains(chunkPos)) {
                preloadChunk(chunkPos);
            }
        }


        for (int dx = -VISIBLE_RADIUS; dx <= VISIBLE_RADIUS; dx++) {
            for (int dy = -VISIBLE_RADIUS; dy <= VISIBLE_RADIUS; dy++) {
                Vector2 visibleChunk = new Vector2(chunkX + dx, chunkY + dy);
                if (!chunkFadeStates.containsKey(visibleChunk)) {
                    chunkFadeStates.put(visibleChunk, 0f);
                }
            }
        }
    }

    private void preloadChunk(Vector2 chunkPos) {
        if (!loadingChunks.containsKey(chunkPos) && !worldService.isChunkLoaded(chunkPos)) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                worldService.loadChunk(chunkPos);
                preloadedChunks.add(chunkPos);
            }, executorService).whenComplete((result, ex) -> {
                loadingChunks.remove(chunkPos);
            });
            loadingChunks.put(chunkPos, future);
        }
    }
    private void preloadChunks(int centerX, int centerY) {
        Set<Vector2> requiredChunks = new HashSet<>();


        for (int dx = -PRELOAD_RADIUS; dx <= PRELOAD_RADIUS; dx++) {
            for (int dy = -PRELOAD_RADIUS; dy <= PRELOAD_RADIUS; dy++) {
                requiredChunks.add(new Vector2(centerX + dx, centerY + dy));
            }
        }


        for (Vector2 chunkPos : requiredChunks) {
            if (!loadingChunks.containsKey(chunkPos) && !worldService.isChunkLoaded(chunkPos)) {
                CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                    worldService.loadChunk(chunkPos);
                }, executorService).whenComplete((result, ex) -> {
                    loadingChunks.remove(chunkPos);
                });
                loadingChunks.put(chunkPos, future);
            }
        }
    }

    public void dispose() {
        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
        }
    }
}

================
File: main/java/io.github.minemon/world/service/ChunkLoadingManager.java
================
package io.github.minemon.world.service;

import com.badlogic.gdx.math.Vector2;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.*;

@Slf4j
@Service
public class ChunkLoadingManager {
    private static final int MAX_CONCURRENT_REQUESTS = 12;
    private static final long REQUEST_TIMEOUT = 3000;
    private static final int IMMEDIATE_RADIUS = 4;  // Highest priority - visible chunks
    private static final int ACTIVE_RADIUS = 6;     // Medium priority - about to be visible
    private static final int PRELOAD_RADIUS = 8;    // Low priority - background loading
    private static final int CHUNK_SIZE = 16;
    private static final int MAX_RETRIES = 3;
    private final PriorityBlockingQueue<ChunkRequest> requestQueue = new PriorityBlockingQueue<>();
    private final Map<Vector2, ChunkRequestInfo> activeRequests = new ConcurrentHashMap<>();
    private final Set<Vector2> failedChunks = ConcurrentHashMap.newKeySet();
    private final Map<Vector2, Integer> retryCount = new ConcurrentHashMap<>();
    private final Map<Vector2, Long> recentlyLoaded = new ConcurrentHashMap<>();
    private final ScheduledExecutorService cleanupService = Executors.newSingleThreadScheduledExecutor();
    private final Object queueLock = new Object();
    private Vector2 lastPlayerChunk = new Vector2(Integer.MAX_VALUE, Integer.MAX_VALUE);
    @Autowired
    @Lazy
    private WorldService worldService;
    @Autowired
    @Lazy
    private MultiplayerClient multiplayerClient;
    public ChunkLoadingManager() {
        cleanupService.scheduleWithFixedDelay(this::cleanup, 30, 30, TimeUnit.SECONDS);
    }

    public void update() {
        if (!multiplayerClient.isConnected()) {
            return;
        }

        long now = System.currentTimeMillis();

        // Handle timeouts first
        handleTimeouts(now);

        // Process queue if we have space
        processQueue();
    }

    public void queueChunkRequest(int x, int y, boolean highPriority) {
        Vector2 pos = new Vector2(x, y);

        // Skip if chunk is already being handled
        if (worldService.isChunkLoaded(pos) || activeRequests.containsKey(pos)) {
            return;
        }

        // Reset retry count for new requests
        retryCount.remove(pos);
        failedChunks.remove(pos);

        requestQueue.offer(new ChunkRequest(
            x, y,
            highPriority ? 0 : 1,
            System.currentTimeMillis(),
            0
        ));

        log.debug("Queued chunk request for ({},{}), priority={}", x, y, highPriority ? "high" : "normal");
    }

    public void markChunkComplete(int x, int y) {
        Vector2 pos = new Vector2(x, y);
        activeRequests.remove(pos);
        failedChunks.remove(pos);
        retryCount.remove(pos);
        processQueue(); // Process next chunk in queue
    }

    private synchronized void processQueue() {
        while (activeRequests.size() < MAX_CONCURRENT_REQUESTS && !requestQueue.isEmpty()) {
            ChunkRequest request = requestQueue.poll();
            if (request == null) break;

            Vector2 pos = new Vector2(request.x, request.y);

            // Skip if chunk was loaded while in queue
            if (worldService.isChunkLoaded(pos)) continue;

            activeRequests.put(pos, new ChunkRequestInfo(
                System.currentTimeMillis(),
                request.priority
            ));

            multiplayerClient.requestChunk(request.x, request.y);
            log.debug("Sent chunk request for ({},{})", request.x, request.y);
        }
    }

    public void preloadChunksAroundPosition(float tileX, float tileY) {
        int centerX = (int) Math.floor(tileX / CHUNK_SIZE);
        int centerY = (int) Math.floor(tileY / CHUNK_SIZE);

        Vector2 currentChunk = new Vector2(centerX, centerY);
        if (currentChunk.equals(lastPlayerChunk)) {
            return;
        }
        lastPlayerChunk.set(currentChunk);

        // Calculate distances for better circular loading
        int[][] priorities = calculatePriorities();

        synchronized (queueLock) {
            requestQueue.clear(); // Clear old requests since position changed

            // Queue chunks in spiral pattern for more efficient loading
            for (int radius = 0; radius <= PRELOAD_RADIUS; radius++) {
                for (int dx = -radius; dx <= radius; dx++) {
                    for (int dy = -radius; dy <= radius; dy++) {
                        if (Math.abs(dx) == radius || Math.abs(dy) == radius) {
                            int priority = priorities[dx + PRELOAD_RADIUS][dy + PRELOAD_RADIUS];
                            queueChunkRequest(centerX + dx, centerY + dy, priority == 0);
                        }
                    }
                }
            }
        }
    }

    private int[][] calculatePriorities() {
        int size = PRELOAD_RADIUS * 2 + 1;
        int[][] priorities = new int[size][size];

        for (int dx = -PRELOAD_RADIUS; dx <= PRELOAD_RADIUS; dx++) {
            for (int dy = -PRELOAD_RADIUS; dy <= PRELOAD_RADIUS; dy++) {
                double distance = Math.sqrt(dx * dx + dy * dy);
                int priority;

                if (distance <= IMMEDIATE_RADIUS) {
                    priority = 0;  // Highest priority
                } else if (distance <= ACTIVE_RADIUS) {
                    priority = 1;  // Medium priority
                } else {
                    priority = 2;  // Lowest priority
                }

                priorities[dx + PRELOAD_RADIUS][dy + PRELOAD_RADIUS] = priority;
            }
        }

        return priorities;
    }


    private void handleTimeouts(long now) {
        List<Vector2> timedOut = new ArrayList<>();

        activeRequests.forEach((pos, info) -> {
            if (now - info.getStartTime() > REQUEST_TIMEOUT) {
                int currentRetries = retryCount.getOrDefault(pos, 0);

                if (currentRetries < MAX_RETRIES) {
                    // Retry with increased priority
                    int newPriority = Math.max(0, info.getPriority() - 1);
                    retryCount.put(pos, currentRetries + 1);

                    requestQueue.offer(new ChunkRequest(
                        (int) pos.x, (int) pos.y,
                        newPriority,
                        now,
                        currentRetries + 1
                    ));

                    log.debug("Retrying chunk {},{} (attempt {})", pos.x, pos.y, currentRetries + 1);
                } else {
                    failedChunks.add(pos);
                    log.warn("Chunk {},{} failed after {} retries", pos.x, pos.y, MAX_RETRIES);
                }

                timedOut.add(pos);
            }
        });

        // Remove timed out requests
        timedOut.forEach(activeRequests::remove);
    }

    private void cleanup() {
        recentlyLoaded.entrySet().removeIf(entry ->
            System.currentTimeMillis() - entry.getValue() > 30000
        );

        retryCount.entrySet().removeIf(entry ->
            !activeRequests.containsKey(entry.getKey())
        );
    }

    private boolean isChunkLoaded(Vector2 pos) {
        if (worldService.isChunkLoaded(pos)) {
            return true;
        }
        Long loadTime = recentlyLoaded.get(pos);
        return loadTime != null && System.currentTimeMillis() - loadTime < 30000;
    }

    public boolean isChunkInProgress(int x, int y) {
        Vector2 pos = new Vector2(x, y);
        return activeRequests.containsKey(pos);
    }

    public void dispose() {
        cleanupService.shutdown();
        try {
            cleanupService.awaitTermination(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            cleanupService.shutdownNow();
            Thread.currentThread().interrupt();
        }
        requestQueue.clear();
        activeRequests.clear();
        recentlyLoaded.clear();
        failedChunks.clear();
    }

    @Data
    private static class ChunkRequest implements Comparable<ChunkRequest> {
        private final int x;
        private final int y;
        private final int priority;
        private final long timestamp;
        private final int retries;

        @Override
        public int compareTo(ChunkRequest o) {
            // First compare priorities
            int priorityCompare = Integer.compare(this.priority, o.priority);
            if (priorityCompare != 0) return priorityCompare;

            // For same priority, retry attempts take precedence
            int retryCompare = Integer.compare(o.retries, this.retries);
            if (retryCompare != 0) return retryCompare;

            // Finally sort by age
            return Long.compare(this.timestamp, o.timestamp);
        }
    }

    @Data
    private static class ChunkRequestInfo {
        private final long startTime;
        private final int priority;
    }
}

================
File: main/java/io.github.minemon/world/service/ChunkPreloaderService.java
================
package io.github.minemon.world.service;

import com.badlogic.gdx.math.Vector2;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

@Service
@Slf4j
public class ChunkPreloaderService {
    // Significantly increased radius for better coverage
    private static final int VISIBLE_RADIUS = 3;
    private static final int PRELOAD_RADIUS = 5;
    private static final int URGENT_RADIUS = 2;
    private static final long CHUNK_REQUEST_TIMEOUT = 2000; // 2 seconds timeout
    private static final long URGENT_REQUEST_TIMEOUT = 1000; // 1 second for urgent chunks

    private final WorldService worldService;
    private final ExecutorService executor = Executors.newFixedThreadPool(4);
    private final Map<Vector2, Long> chunkRequestTimes = new ConcurrentHashMap<>();
    private final Set<Vector2> preloadedChunks = Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final Set<Vector2> failedRequests = Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final Queue<Vector2> urgentChunkQueue = new LinkedList<>();
    @Autowired
    @Lazy
    private ChunkLoadingManager chunkLoadingManager;
    @Autowired
    @Lazy
    private MultiplayerClient client;

    public ChunkPreloaderService(WorldService worldService) {
        this.worldService = worldService;
        startUrgentChunkProcessor();
    }

    private void startUrgentChunkProcessor() {
        executor.submit(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    processUrgentChunks();
                    Thread.sleep(100); // Check urgent queue every 100ms
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
    }

    private void processUrgentChunks() {
        Vector2 urgentChunk;
        while ((urgentChunk = urgentChunkQueue.poll()) != null) {
            if (!worldService.isChunkLoaded(urgentChunk)) {
                requestChunk(urgentChunk, true);
            }
        }
    }

    private void requestChunk(Vector2 chunkPos, boolean urgent) {
        if (worldService.isMultiplayerMode() && client != null && client.isConnected()) {
            chunkLoadingManager.queueChunkRequest((int) chunkPos.x, (int) chunkPos.y, urgent);
        } else {
            // Single-player direct load/generate
            worldService.loadChunk(chunkPos);
        }
    }


    private void retryFailedRequests() {
        long now = System.currentTimeMillis();
        Iterator<Vector2> iterator = failedRequests.iterator();
        while (iterator.hasNext()) {
            Vector2 failedChunk = iterator.next();
            if (worldService.isChunkLoaded(failedChunk)) {
                iterator.remove();
                continue;
            }

            Long lastAttempt = chunkRequestTimes.get(failedChunk);
            if (lastAttempt == null || now - lastAttempt >= CHUNK_REQUEST_TIMEOUT) {
                requestChunk(failedChunk, true);
            }
        }
    }

    public void dispose() {
        executor.shutdownNow();
        try {
            executor.awaitTermination(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        preloadedChunks.clear();
        chunkRequestTimes.clear();
        failedRequests.clear();
        urgentChunkQueue.clear();
    }
}

================
File: main/java/io.github.minemon/world/service/impl/BaseWorldServiceImpl.java
================
package io.github.minemon.world.service.impl;

import com.badlogic.gdx.graphics.OrthographicCamera;
import io.github.minemon.world.service.WorldService;

public abstract class BaseWorldServiceImpl implements WorldService {
    protected OrthographicCamera camera;

    @Override
    public OrthographicCamera getCamera() {
        return camera;
    }

    @Override
    public void setCamera(OrthographicCamera camera) {
        this.camera = camera;
    }
}

================
File: main/java/io.github.minemon/world/service/impl/ChunkCacheManager.java
================
package io.github.minemon.world.service.impl;

import io.github.minemon.world.service.WorldService;
import jakarta.annotation.PreDestroy;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Service
@Slf4j
public class ChunkCacheManager {
    private final Map<String, Map<ChunkKey, Long>> clientChunks = new ConcurrentHashMap<>();
    private final ScheduledExecutorService cleanupExecutor;
    private final int maxChunksPerClient;
    private final long cacheTtl;

    public ChunkCacheManager(
            @Value("${server.chunk.cache.maxPerClient:256}") int maxChunksPerClient,
            @Value("${server.chunk.cache.ttl:300000}") long cacheTtl) {
        this.maxChunksPerClient = maxChunksPerClient;
        this.cacheTtl = cacheTtl;
        this.cleanupExecutor = Executors.newSingleThreadScheduledExecutor();
        startCleanupTask();
    }

    public boolean isChunkCached(String clientId, int chunkX, int chunkY) {
        Map<ChunkKey, Long> clientCache = clientChunks.get(clientId);
        if (clientCache == null) return false;

        ChunkKey key = new ChunkKey(chunkX, chunkY);
        Long cacheTime = clientCache.get(key);
        if (cacheTime == null) return false;

        if (System.currentTimeMillis() - cacheTime > cacheTtl) {
            clientCache.remove(key);
            return false;
        }
        return true;
    }
    private final boolean isServer = false;

    @Autowired
    private WorldService worldService;

    public void cacheChunk(String clientId, int chunkX, int chunkY) {
        // Only cache on server or in singleplayer
        if (!isServer && worldService.isMultiplayerMode()) {
            return;
        }
        clientChunks.computeIfAbsent(clientId, k -> new ConcurrentHashMap<>())
                .put(new ChunkKey(chunkX, chunkY), System.currentTimeMillis());

        // If cache too large, remove oldest entries
        Map<ChunkKey, Long> clientCache = clientChunks.get(clientId);
        if (clientCache.size() > maxChunksPerClient) {
            List<ChunkKey> oldestChunks = clientCache.entrySet().stream()
                    .sorted(Map.Entry.comparingByValue())
                    .limit(clientCache.size() - maxChunksPerClient)
                    .map(Map.Entry::getKey)
                    .toList();

            for (ChunkKey key : oldestChunks) {
                clientCache.remove(key);
            }
        }
    }

    public void removeClient(String clientId) {
        clientChunks.remove(clientId);
        log.debug("Removed chunk cache for client: {}", clientId);
    }

    private void startCleanupTask() {
        cleanupExecutor.scheduleAtFixedRate(this::cleanupCache,
                60, 60, TimeUnit.SECONDS);
    }

    private void cleanupCache() {
        long now = System.currentTimeMillis();
        clientChunks.forEach((clientId, chunks) -> {
            chunks.entrySet().removeIf(entry ->
                    now - entry.getValue() > cacheTtl);
        });
        clientChunks.entrySet().removeIf(entry -> entry.getValue().isEmpty());
        log.debug("Completed chunk cache cleanup");
    }

    @PreDestroy
    public void shutdown() {
        cleanupExecutor.shutdown();
        try {
            if (!cleanupExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                cleanupExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            cleanupExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    @Data
    @AllArgsConstructor
    private static class ChunkKey {
        private final int x;
        private final int y;
    }
}

================
File: main/java/io.github.minemon/world/service/impl/ClientTileManagerImpl.java
================
package io.github.minemon.world.service.impl;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.utils.Json;
import io.github.minemon.core.service.FileAccessService;
import io.github.minemon.world.config.TileConfig;
import io.github.minemon.world.service.TileManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

import java.util.HashMap;

@Component
@Qualifier("clientTileManagerImpl")
public class ClientTileManagerImpl implements TileManager {
    private static final Logger logger = LoggerFactory.getLogger(ClientTileManagerImpl.class);

    @Value("${tiles.configPath:config/tiles.json}")
    private String tileConfigFile;

    private final HashMap<Integer, TileConfig.TileDefinition> tiles = new HashMap<>();
    private TextureAtlas atlas;
    private boolean initialized = false;
    private final FileAccessService fileAccessService;

    public ClientTileManagerImpl(FileAccessService fileAccessService) {
        this.fileAccessService = fileAccessService;
    }

    @Override
    public void initIfNeeded() {
        if (!initialized) {
            loadConfig(tileConfigFile);
            atlas = new TextureAtlas(Gdx.files.internal("atlas/tiles-gfx-atlas.atlas"));
            initialized = true;
            logger.info("TileManager (client) initialized.");
        }
    }

    private void loadConfig(String tileConfigFile) {
        if (!fileAccessService.exists(tileConfigFile)) {
            logger.warn("Tile config file not found: {}", tileConfigFile);
            return;
        }

        String jsonContent = fileAccessService.readFile(tileConfigFile);
        Json json = new Json();
        TileConfig config = json.fromJson(TileConfig.class, jsonContent);
        for (TileConfig.TileDefinition def : config.getTiles()) {
            tiles.put(def.getId(), def);
        }
        logger.info("Loaded {} tiles from {}", tiles.size(), tileConfigFile);
    }

    @Override
    public TextureRegion getRegionForTile(int tileId) {
        TileConfig.TileDefinition def = tiles.get(tileId);
        if (def == null) {
            TextureRegion unknown = atlas.findRegion("unknown");
            if (unknown == null) {
                logger.warn("Unknown tile requested and no 'unknown' region found.");
            }
            return unknown;
        }
        TextureRegion region = atlas.findRegion(def.getTexture());
        if (region == null) {
            logger.warn("No region found in atlas for tile texture: {}", def.getTexture());
            return atlas.findRegion("unknown");
        }
        return region;
    }

    @Override
    public boolean isPassable(int tileId) {
        TileConfig.TileDefinition def = tiles.get(tileId);
        if (def == null) return false;
        return def.isPassable();
    }

    @Override
    public String getTileName(int tileId) {
        TileConfig.TileDefinition def = tiles.get(tileId);
        if (def == null) return "unknown";
        return def.getName();
    }
}

================
File: main/java/io.github.minemon/world/service/impl/ClientWorldServiceImpl.java
================
package io.github.minemon.world.service.impl;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.PixmapIO;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.FrameBuffer;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.minemon.multiplayer.model.WorldObjectUpdate;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.model.PlayerDirection;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.world.biome.config.BiomeConfigurationLoader;
import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.biome.model.BiomeType;
import io.github.minemon.world.biome.service.BiomeService;
import io.github.minemon.world.config.WorldConfig;
import io.github.minemon.world.model.*;
import io.github.minemon.world.service.*;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Slf4j
@Service
public class ClientWorldServiceImpl extends BaseWorldServiceImpl implements WorldService {
    private static final int CHUNK_SIZE = 16;
    private static final int TILE_SIZE = 32;
    private static final long CHUNK_REQUEST_TIMEOUT = 2000;
    private static final long URGENT_REQUEST_TIMEOUT = 1000;
    private final WorldGenerator worldGenerator;
    @Autowired
    @Lazy
    private final WorldObjectManager worldObjectManager;
    private final TileManager tileManager;
    private final ObjectTextureManager objectTextureManager;
    private final BiomeConfigurationLoader biomeLoader;
    private final BiomeService biomeService;
    private final JsonWorldDataService jsonWorldDataService;  // NEW
    private final WorldData worldData = new WorldData();
    private final Map<String, Long> chunkRequestTimes = new ConcurrentHashMap<>();
    private final Set<Vector2> failedRequests = Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final Map<String, Object> chunkLocks = new ConcurrentHashMap<>();
    @Value("${world.defaultName:defaultWorld}")
    private String defaultWorldName;
    @Value("${world.saveDir:save/worlds/}")
    private String saveDir;
    private boolean initialized = false;
    @Autowired
    @Lazy
    private MultiplayerClient multiplayerClient;
    private boolean isMultiplayerMode = false;
    private boolean disconnectHandled = false;
    @Autowired
    @Lazy
    private ChunkLoadingManager chunkLoadingManager;
    @Autowired
    @Lazy
    private PlayerService playerService;

    public ClientWorldServiceImpl(
        WorldConfig worldConfig,
        WorldGenerator worldGenerator,
        WorldObjectManager worldObjectManager,
        TileManager tileManager,
        BiomeConfigurationLoader biomeLoader,
        BiomeService biomeService,
        ObjectTextureManager objectTextureManager,
        @Qualifier("clientJsonWorldDataService") JsonWorldDataService jsonWorldDataService
    ) {
        this.worldGenerator = worldGenerator;
        this.worldObjectManager = worldObjectManager;
        this.tileManager = tileManager;
        this.biomeLoader = biomeLoader;
        this.biomeService = biomeService;
        this.objectTextureManager = objectTextureManager;
        this.jsonWorldDataService = jsonWorldDataService;
    }

    @Override
    public void generateWorldThumbnail(String worldName) {
        initIfNeeded();
        objectTextureManager.initializeIfNeeded();
        int previewSize = 8;
        int tileSize = 32;
        int iconWidth = 128;
        int iconHeight = 128;

        float scaleX = (float) iconWidth / (previewSize * tileSize);
        float scaleY = (float) iconHeight / (previewSize * tileSize);
        float scale = Math.min(scaleX, scaleY);

        FrameBuffer fbo = new FrameBuffer(Pixmap.Format.RGBA8888, iconWidth, iconHeight, false);
        SpriteBatch batch = new SpriteBatch();

        fbo.begin();
        Gdx.gl.glClearColor(0, 0, 0, 0);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        OrthographicCamera camera = new OrthographicCamera(iconWidth, iconHeight);
        camera.setToOrtho(true, iconWidth, iconHeight);

        batch.setProjectionMatrix(camera.combined);
        batch.begin();

        com.badlogic.gdx.math.Matrix4 transform = batch.getTransformMatrix();
        transform.idt();

        float worldWidth = previewSize * tileSize;
        float worldHeight = previewSize * tileSize;
        transform.translate(iconWidth / 2f, iconHeight / 2f, 0);
        transform.scale(scale, scale, 1f);
        transform.translate(-worldWidth / 2f, -worldHeight / 2f, 0);

        batch.setTransformMatrix(transform);

        int centerX = 0;
        int centerY = 0;


        for (int dy = 0; dy < previewSize; dy++) {
            for (int dx = 0; dx < previewSize; dx++) {
                int tileX = centerX + dx - previewSize / 2;
                int tileY = centerY + dy - previewSize / 2;
                int chunkX = tileX / 16;
                int chunkY = tileY / 16;
                int[][] tiles = getChunkTiles(chunkX, chunkY);
                if (tiles != null) {
                    int localX = Math.floorMod(tileX, 16);
                    int localY = Math.floorMod(tileY, 16);
                    if (localX >= 0 && localX < 16 && localY >= 0 && localY < 16) {
                        int tileType = tiles[localX][localY];
                        TextureRegion region = tileManager.getRegionForTile(tileType);
                        if (region != null) {
                            float worldPixelX = dx * tileSize;
                            float worldPixelY = dy * tileSize;
                            batch.draw(region, worldPixelX, worldPixelY, tileSize, tileSize);
                        }
                    }
                }
            }
        }


        Set<String> processedChunks = new HashSet<>();
        for (int dy = 0; dy < previewSize; dy++) {
            for (int dx = 0; dx < previewSize; dx++) {
                int tileX = centerX + dx - previewSize / 2;
                int tileY = centerY + dy - previewSize / 2;
                int chunkX = tileX / 16;
                int chunkY = tileY / 16;
                String key = chunkX + "," + chunkY;
                if (!processedChunks.contains(key)) {
                    List<WorldObject> objs = worldObjectManager.getObjectsForChunk(chunkX, chunkY);
                    for (WorldObject obj : objs) {
                        int objTileX = obj.getTileX();
                        int objTileY = obj.getTileY();
                        if (objTileX >= centerX - previewSize / 2 && objTileX < centerX + previewSize / 2 &&
                            objTileY >= centerY - previewSize / 2 && objTileY < centerY + previewSize / 2) {
                            float worldPixelX = (objTileX - (centerX - (float) previewSize / 2)) * tileSize;
                            float worldPixelY = (objTileY - (centerY - (float) previewSize / 2)) * tileSize;


                            TextureRegion objTexture = objectTextureManager.getTexture(obj.getType().getTextureRegionName());
                            if (objTexture != null) {
                                batch.draw(objTexture, worldPixelX, worldPixelY,
                                    obj.getType().getWidthInTiles() * tileSize,
                                    obj.getType().getHeightInTiles() * tileSize);
                            }
                        }
                    }
                    processedChunks.add(key);
                }
            }
        }

        batch.end();

        Pixmap pm = Pixmap.createFromFrameBuffer(0, 0, iconWidth, iconHeight);
        fbo.end();


        FileHandle dir = Gdx.files.local(saveDir + worldName);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        FileHandle iconFile = Gdx.files.local(saveDir + worldName + "/icon.png");
        PixmapIO.writePNG(iconFile, pm);

        pm.dispose();
        batch.dispose();
        fbo.dispose();

        log.info("Generated world thumbnail for '{}'", worldName);
    }

    @Override
    public void updateWorldObjectState(WorldObjectUpdate update) {
        String key = (update.getTileX() / 16) + "," + (update.getTileY() / 16);
        ChunkData chunk = getWorldData().getChunks().get(key);
        if (chunk == null) return; // chunk not loaded

        List<WorldObject> objs = chunk.getObjects();
        if (update.isRemoved()) {
            objs.removeIf(o -> o.getId().equals(update.getObjectId()));
        } else {
            boolean found = false;
            for (WorldObject wo : objs) {
                if (wo.getId().equals(update.getObjectId())) {
                    wo.setTileX(update.getTileX());
                    wo.setTileY(update.getTileY());
                    found = true;
                    break;
                }
            }
            if (!found) {
                ObjectType objType = ObjectType.valueOf(update.getType());
                WorldObject newObj = new WorldObject(
                    update.getTileX(),
                    update.getTileY(),
                    objType,
                    objType.isCollidable()
                );
                objs.add(newObj);
            }
        }

        // Save chunk
        try {
            jsonWorldDataService.saveChunk(getWorldData().getWorldName(), chunk);
        } catch (IOException e) {
            log.error("Failed to save chunk after updateWorldObjectState: {}", e.getMessage());
        }
    }

    @Override
    public TileManager getTileManager() {
        return this.tileManager;
    }

    @Override
    public void loadWorld(String worldName) {
        // Reset disconnect handling flag
        disconnectHandled = false;

        // Clear any existing world state first
        clearWorldData();

        // Explicitly set to singleplayer mode before loading
        setMultiplayerMode(false);

        try {
            jsonWorldDataService.loadWorld(worldName, worldData);
            worldData.setLastPlayed(System.currentTimeMillis());
            initIfNeeded();
            log.info("Loaded singleplayer world data for world: {}", worldName);
        } catch (IOException e) {
            log.error("Failed to load world '{}': {}", worldName, e.getMessage());
            throw new RuntimeException("Failed to load world: " + worldName, e);
        }
    }

    public void handleDisconnect() {
        if (!isMultiplayerMode()) {
            return;
        }
        if (!disconnectHandled && isMultiplayerMode()) {
            disconnectHandled = true;
            log.info("Handling disconnection cleanup...");

            // Save if needed
            saveWorldData();

            // **Key**: clear out the old data
            clearWorldData();

            // Turn off multiplayer mode
            setMultiplayerMode(false);
        }
    }

    @Override
    public void clearWorldData() {
        worldData.getChunks().clear();
        worldData.getPlayers().clear();
        worldData.setWorldName(null);
        worldData.setSeed(0);
        worldData.setCreatedDate(0);
        worldData.setLastPlayed(0);
        worldData.setPlayedTime(0);
        initialized = false;

        // Clear any chunk requests
        if (multiplayerClient != null) {
            multiplayerClient.clearPendingChunkRequests();
        }
    }

    @Override
    public void initIfNeeded() {
        if (initialized) {
            return;
        }

        Map<BiomeType, Biome> biomes = biomeLoader.loadBiomes("config/biomes.json");
        if (worldData.getSeed() == 0) {
            long randomSeed = new Random().nextLong();
            worldData.setSeed(randomSeed);
            log.info("No existing seed found; using random seed: {}", randomSeed);
        }

        long seed = worldData.getSeed();
        worldGenerator.setSeedAndBiomes(seed, biomes);
        biomeService.initWithSeed(seed);
        worldObjectManager.initialize();
        tileManager.initIfNeeded();

        initialized = true;
        log.info("WorldService initialized with seed {}", seed);
    }

    public void preloadChunksAroundPosition(float tileX, float tileY) {
        int IMMEDIATE_RADIUS = 2;  // Highest priority chunks
        int PRELOAD_RADIUS = 4;    // Pre-load these chunks

        int centerChunkX = (int) Math.floor(tileX / CHUNK_SIZE);
        int centerChunkY = (int) Math.floor(tileY / CHUNK_SIZE);

        // Clear any existing chunk requests to prioritize new location
        if (multiplayerClient != null) {
            multiplayerClient.clearPendingChunkRequests();
        }

        // First load immediate chunks (high priority)
        for (int dx = -IMMEDIATE_RADIUS; dx <= IMMEDIATE_RADIUS; dx++) {
            for (int dy = -IMMEDIATE_RADIUS; dy <= IMMEDIATE_RADIUS; dy++) {
                int chunkX = centerChunkX + dx;
                int chunkY = centerChunkY + dy;

                if (!isChunkLoaded(new Vector2(chunkX, chunkY))) {
                    if (isMultiplayerMode && multiplayerClient != null) {
                        chunkLoadingManager.queueChunkRequest(chunkX, chunkY, true); // high priority
                    } else {
                        loadOrGenerateChunk(chunkX, chunkY);
                    }
                }
            }
        }

        // Then queue preload chunks (lower priority)
        for (int dx = -PRELOAD_RADIUS; dx <= PRELOAD_RADIUS; dx++) {
            for (int dy = -PRELOAD_RADIUS; dy <= PRELOAD_RADIUS; dy++) {
                // Skip immediate chunks we already loaded
                if (Math.abs(dx) <= IMMEDIATE_RADIUS && Math.abs(dy) <= IMMEDIATE_RADIUS) {
                    continue;
                }

                int chunkX = centerChunkX + dx;
                int chunkY = centerChunkY + dy;

                if (!isChunkLoaded(new Vector2(chunkX, chunkY))) {
                    if (isMultiplayerMode && multiplayerClient != null) {
                        chunkLoadingManager.queueChunkRequest(chunkX, chunkY, false); // normal priority
                    } else {
                        loadOrGenerateChunk(chunkX, chunkY);
                    }
                }
            }
        }
    }

    @Override
    public void saveWorldData() {
        // Don't save if we're in multiplayer mode
        if (isMultiplayerMode) {
            log.debug("Skipping world save in multiplayer mode");
            return;
        }

        if (worldData.getWorldName() == null || worldData.getWorldName().isEmpty()) {
            log.debug("No world loaded, nothing to save.");
            return;
        }

        try {
            // Only save in singleplayer mode
            jsonWorldDataService.saveWorld(worldData);
            log.info("Saved world data for '{}'", worldData.getWorldName());
        } catch (IOException e) {
            log.error("Failed saving world '{}': {}", worldData.getWorldName(), e.getMessage());
        }
    }

    @Override
    public boolean createWorld(String worldName, long seed) {
        // Check if world exists first
        if (jsonWorldDataService.worldExists(worldName)) {
            log.warn("World '{}' already exists, cannot create", worldName);
            return false;
        }

        // Clear any existing world data first
        worldData.getChunks().clear();
        worldData.getPlayers().clear();

        // Set up new world
        long now = System.currentTimeMillis();
        worldData.setWorldName(worldName);
        worldData.setSeed(seed);
        worldData.setCreatedDate(now);
        worldData.setLastPlayed(now);
        worldData.setPlayedTime(0);

        try {
            jsonWorldDataService.saveWorld(worldData);
            log.info("Created new world '{}' with seed {}", worldName, seed);
            return true;
        } catch (IOException e) {
            log.error("Failed to create world '{}': {}", worldName, e.getMessage());
            return false;
        }
    }

    @Override
    public WorldData getWorldData() {
        return worldData;
    }

    private boolean isChunkUrgent(int chunkX, int chunkY, Rectangle viewBounds) {
        float chunkWorldX = chunkX * CHUNK_SIZE * TILE_SIZE;
        float chunkWorldY = chunkY * CHUNK_SIZE * TILE_SIZE;
        Rectangle chunkBounds = new Rectangle(
            chunkWorldX,
            chunkWorldY,
            CHUNK_SIZE * TILE_SIZE,
            CHUNK_SIZE * TILE_SIZE
        );
        return viewBounds.overlaps(chunkBounds);
    }

    @Override
    public void loadWorldData() {
        try {
            jsonWorldDataService.loadWorld(defaultWorldName, worldData);
            initIfNeeded();
            log.info("Loaded default world data for '{}' from JSON", defaultWorldName);
        } catch (IOException e) {
            log.warn("No default world '{}' found in JSON: {}", defaultWorldName, e.getMessage());
        }
    }

    @Override
    public Map<String, ChunkData> getVisibleChunks(Rectangle viewBounds) {
        Map<String, ChunkData> visibleChunks = new HashMap<>();

        // Calculate chunk coordinates with a smaller buffer
        int startChunkX = (int) Math.floor((viewBounds.x - TILE_SIZE) / (CHUNK_SIZE * TILE_SIZE));
        int startChunkY = (int) Math.floor((viewBounds.y - TILE_SIZE) / (CHUNK_SIZE * TILE_SIZE));
        int endChunkX = (int) Math.ceil((viewBounds.x + viewBounds.width + TILE_SIZE) / (CHUNK_SIZE * TILE_SIZE));
        int endChunkY = (int) Math.ceil((viewBounds.y + viewBounds.height + TILE_SIZE) / (CHUNK_SIZE * TILE_SIZE));

        // Add immediate chunks first
        for (int x = startChunkX; x <= endChunkX; x++) {
            for (int y = startChunkY; y <= endChunkY; y++) {
                String key = x + "," + y;
                ChunkData chunk = worldData.getChunks().get(key);

                if (chunk != null) {
                    visibleChunks.put(key, chunk);
                } else if (isMultiplayerMode && !chunkLoadingManager.isChunkInProgress(x, y)) {
                    // Only request if really needed and not already in progress
                    chunkLoadingManager.queueChunkRequest(x, y, true); // true = high priority
                }
            }
        }

        return visibleChunks;
    }

    private void unloadDistantChunks(Rectangle viewBounds) {
        if (isMultiplayerMode) {
            return; // don't unload in multiplayer
        }
        final int UNLOAD_DISTANCE = 5; // Chunks

        int playerChunkX = (int) Math.floor(viewBounds.x / (CHUNK_SIZE * TILE_SIZE));
        int playerChunkY = (int) Math.floor(viewBounds.y / (CHUNK_SIZE * TILE_SIZE));

        // Create a safe copy of keys to check
        Set<String> keys = new HashSet<>(worldData.getChunks().keySet());

        for (String key : keys) {
            ChunkData chunk = worldData.getChunks().get(key);
            if (chunk == null) continue;

            int dx = Math.abs(chunk.getChunkX() - playerChunkX);
            int dy = Math.abs(chunk.getChunkY() - playerChunkY);

            if (dx > UNLOAD_DISTANCE || dy > UNLOAD_DISTANCE) {
                worldData.getChunks().remove(key);
            }
        }
    }

    public void update(float delta) {
        try {
            if (camera != null) {
                Rectangle viewBounds = calculateViewBounds();
                unloadDistantChunks(viewBounds);
            }
        } catch (Exception e) {
            log.error("Error during world update: {}", e.getMessage(), e);
        }
    }

    private Rectangle calculateViewBounds() {
        if (camera == null) {
            return new Rectangle(0, 0, CHUNK_SIZE * TILE_SIZE, CHUNK_SIZE * TILE_SIZE);
        }

        // Calculate view dimensions in world coordinates
        float width = camera.viewportWidth * camera.zoom;
        float height = camera.viewportHeight * camera.zoom;

        // Add a small buffer (2 chunk width) for smoother loading at edges
        float bufferSize = 2 * CHUNK_SIZE * TILE_SIZE;

        return new Rectangle(
            camera.position.x - (width / 2) - bufferSize,
            camera.position.y - (height / 2) - bufferSize,
            width + (bufferSize * 2),
            height + (bufferSize * 2)
        );
    }

    @Override
    public void forceLoadChunksAt(float tileX, float tileY) {
        int RADIUS = 2;
        int chunkX = (int) Math.floor(tileX / CHUNK_SIZE);
        int chunkY = (int) Math.floor(tileY / CHUNK_SIZE);

        // Only request chunks we don't have yet
        for (int dx = -RADIUS; dx <= RADIUS; dx++) {
            for (int dy = -RADIUS; dy <= RADIUS; dy++) {
                int cx = chunkX + dx;
                int cy = chunkY + dy;
                Vector2 chunkPos = new Vector2(cx, cy);

                if (!isChunkLoaded(chunkPos)) {
                    if (isMultiplayerMode()) {
                        // Don't check if request is pending - let ChunkLoadingManager handle that
                        chunkLoadingManager.queueChunkRequest(cx, cy, true);
                    } else {
                        loadOrGenerateChunk(cx, cy);
                    }
                }
            }
        }
    }

    @Override
    public int[][] getChunkTiles(int chunkX, int chunkY) {
        String key = chunkX + "," + chunkY;
        ChunkData chunkData = worldData.getChunks().get(key);

        if (chunkData == null && isMultiplayerMode()) {
            // Check viewport distance for priority
            Vector2 playerChunkPos = new Vector2(
                playerService.getPlayerData().getX() / CHUNK_SIZE,
                playerService.getPlayerData().getY() / CHUNK_SIZE
            );

            Vector2 requestedChunkPos = new Vector2(chunkX, chunkY);
            float distance = playerChunkPos.dst(requestedChunkPos);

            // Immediate vicinity (high priority) vs background loading
            boolean urgent = distance <= 3;

            if (!chunkLoadingManager.isChunkInProgress(chunkX, chunkY)) {
                // Queue the request with appropriate priority
                chunkLoadingManager.queueChunkRequest(chunkX, chunkY, urgent);
                log.debug("Queued {} priority chunk request for ({},{})",
                    urgent ? "high" : "normal", chunkX, chunkY);
            }
            return null; // Return null while waiting for chunk data
        }

        if (chunkData != null) {
            // Successfully loaded/received chunk
            return chunkData.getTiles();
        }

        return null;
    }
    @Override
    public void loadOrReplaceChunkData(int chunkX, int chunkY, int[][] tiles, List<WorldObject> objects) {
        // Don't ignore incoming chunk data in multiplayer mode
        String key = chunkX + "," + chunkY;

        synchronized (chunkLocks.computeIfAbsent(key, k -> new Object())) {
            ChunkData chunk = worldData.getChunks().computeIfAbsent(key, k -> {
                ChunkData newChunk = new ChunkData();
                newChunk.setChunkX(chunkX);
                newChunk.setChunkY(chunkY);
                return newChunk;
            });

            // Update tiles if provided
            if (tiles != null) {
                chunk.setTiles(tiles);
            }

            // Merge objects if provided
            if (objects != null) {
                if (chunk.getObjects() == null) {
                    chunk.setObjects(new ArrayList<>(objects));
                } else {
                    // Keep existing objects that aren't being replaced
                    List<WorldObject> mergedObjects = new ArrayList<>(
                        chunk.getObjects().stream()
                            .filter(existing -> objects.stream()
                                .noneMatch(newObj ->
                                    newObj.getId().equals(existing.getId())))
                            .collect(Collectors.toList())
                    );
                    mergedObjects.addAll(objects);
                    chunk.setObjects(mergedObjects);
                }
            }
            chunkLoadingManager.markChunkComplete(chunkX, chunkY);
        }
    }

    @Override
    public ChunkData loadOrGenerateChunk(int chunkX, int chunkY) {
        if (isMultiplayerMode) {
            return null;
        }
        // 1) Attempt load from JSON
        try {
            ChunkData loaded = jsonWorldDataService.loadChunk(worldData.getWorldName(), chunkX, chunkY);
            if (loaded != null) {
                worldObjectManager.loadObjectsForChunk(chunkX, chunkY, loaded.getObjects());
                worldData.getChunks().put(chunkX + "," + chunkY, loaded);
                return null;
            }
        } catch (IOException e) {
            log.warn("Failed reading chunk from JSON: {}", e.getMessage());
        }

        // 2) Generate
        int[][] tiles = worldGenerator.generateChunk(chunkX, chunkY);
        ChunkData cData = new ChunkData();
        cData.setChunkX(chunkX);
        cData.setChunkY(chunkY);

        cData.setTiles(tiles);
        Biome biome = worldGenerator.getBiomeForChunk(chunkX, chunkY);
        List<WorldObject> objs = worldObjectManager.generateObjectsForChunk(
            chunkX, chunkY, tiles, biome, getWorldData().getSeed());
        cData.setObjects(objs);
        worldData.getChunks().put(chunkX + "," + chunkY, cData);

        // 3) Save
        try {
            jsonWorldDataService.saveChunk(worldData.getWorldName(), cData);
        } catch (IOException e) {
            log.error("Failed to save chunk for newly generated chunk: {}", e.getMessage());
        }
        return cData;
    }

    @Override
    public synchronized boolean isChunkLoaded(Vector2 chunkPos) {
        String key = String.format("%d,%d", (int) chunkPos.x, (int) chunkPos.y);
        Map<String, ChunkData> chunks = worldData.getChunks();
        boolean loaded = chunks.containsKey(key);
        return loaded;
    }

    private void requestChunkWithTimeout(int chunkX, int chunkY, boolean urgent) {
        String key = chunkX + "," + chunkY;
        long now = System.currentTimeMillis();
        Long lastRequest = chunkRequestTimes.get(key);
        long timeout = urgent ? URGENT_REQUEST_TIMEOUT : CHUNK_REQUEST_TIMEOUT;

        // Check if we need to retry (timeout occurred)
        if (lastRequest != null && now - lastRequest < timeout) {
            return; // Still waiting for previous request
        }

        if (multiplayerClient != null && multiplayerClient.isConnected()) {
            if (!multiplayerClient.isPendingChunkRequest(chunkX, chunkY)) {
                if (isMultiplayerMode && !chunkLoadingManager.isChunkInProgress(chunkX, chunkY)) {
                    chunkLoadingManager.queueChunkRequest(chunkX, chunkY, /* highPriority= */ true);
                }

                chunkRequestTimes.put(key, now);

                if (urgent) {
                    // Track failed urgent requests for quick retry
                    failedRequests.add(new Vector2(chunkX, chunkY));
                }
            }
        }
    }


    @Override
    public void loadChunk(Vector2 chunkPos) {
        if (isMultiplayerMode) {
            chunkLoadingManager.queueChunkRequest((int) chunkPos.x, (int) chunkPos.y, false);
        } else {
            loadOrGenerateChunk((int) chunkPos.x, (int) chunkPos.y);
        }

    }


    @Override
    public List<WorldObject> getVisibleObjects(Rectangle viewBounds) {
        if (worldData.getWorldName() == null || worldData.getWorldName().isEmpty()) {
            return Collections.emptyList();
        }
        List<WorldObject> visibleObjects = new ArrayList<>();
        Map<String, ChunkData> visibleChunks = getVisibleChunks(viewBounds);
        for (ChunkData chunk : visibleChunks.values()) {
            if (chunk.getObjects() != null) {
                for (WorldObject obj : chunk.getObjects()) {
                    float pixelX = obj.getTileX() * TILE_SIZE;
                    float pixelY = obj.getTileY() * TILE_SIZE;
                    if (viewBounds.contains(pixelX, pixelY)) {
                        visibleObjects.add(obj);
                    }
                }
            }
        }
        return visibleObjects;
    }

    @Override
    public void setPlayerData(PlayerData playerData) {
        if (playerData == null) {
            log.warn("Attempt to set null player data");
            return;
        }

        // Always update in-memory state
        worldData.getPlayers().put(playerData.getUsername(), playerData);

        // Only save to disk in singleplayer mode
        if (!isMultiplayerMode) {
            try {
                jsonWorldDataService.savePlayerData(worldData.getWorldName(), playerData);
                log.debug("Saved player data for {} in singleplayer mode", playerData.getUsername());
            } catch (IOException e) {
                log.error("Failed to save player data: {}", e.getMessage());
            }
        }
    }

    @Override
    public boolean isMultiplayerMode() {
        return this.isMultiplayerMode;
    }

    @Override
    public void setMultiplayerMode(boolean multiplayer) {
        if (this.isMultiplayerMode() != multiplayer) {
            this.isMultiplayerMode = multiplayer;

            if (multiplayer) {
                // Initialize a default world for multiplayer
                worldData.setWorldName("serverWorld");
                worldData.setSeed(System.currentTimeMillis()); // Server will override this
                log.info("Initialized multiplayer world");
            } else {
                // Clear all multiplayer state
                clearWorldData();
                if (multiplayerClient != null) {
                    multiplayerClient.clearPendingChunkRequests();
                }
            }
        }
    }


    @Override
    public PlayerData getPlayerData(String username) {
        PlayerData pd = getWorldData().getPlayers().get(username);
        if (pd == null) {
            String wName = getWorldData().getWorldName();
            try {
                pd = jsonWorldDataService.loadPlayerData(wName, username);
                if (pd == null) {
                    pd = new PlayerData(username, 0, 0, PlayerDirection.DOWN);
                    jsonWorldDataService.savePlayerData(wName, pd);
                }
                getWorldData().getPlayers().put(username, pd);
            } catch (IOException e) {
                log.error("Failed to load or create player data for {}: {}", username, e.getMessage());
            }
        }
        return pd;
    }


    @Override
    public List<String> getAvailableWorlds() {
        return jsonWorldDataService.listAllWorlds();
    }

    @Override
    public void deleteWorld(String worldName) {
        if (!jsonWorldDataService.worldExists(worldName)) {
            log.warn("World '{}' does not exist, cannot delete", worldName);
            return;
        }
        jsonWorldDataService.deleteWorld(worldName);
        if (worldData.getWorldName() != null && worldData.getWorldName().equals(worldName)) {
            worldData.setWorldName(null);
            worldData.setSeed(0);
            worldData.getPlayers().clear();
            worldData.getChunks().clear();
            worldData.setCreatedDate(0);
            worldData.setLastPlayed(0);
            worldData.setPlayedTime(0);
            log.info("Cleared current loaded world data because it was deleted.");
        }
        log.info("Deleted world '{}'", worldName);
    }

    @Override
    public void regenerateChunk(int chunkX, int chunkY) {
        String key = chunkX + "," + chunkY;
        worldData.getChunks().remove(key);
        jsonWorldDataService.deleteChunk(worldData.getWorldName(), chunkX, chunkY);
        loadOrGenerateChunk(chunkX, chunkY);
    }
}

================
File: main/java/io.github.minemon/world/service/impl/JsonWorldDataService.java
================
package io.github.minemon.world.service.impl;

import com.badlogic.gdx.utils.Json;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.world.model.ChunkData;
import io.github.minemon.world.model.WorldData;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Now it references "saveDir" (by default "assets/save/worlds"),
 * ensuring we store everything in the same place used for icon.png
 */
@Slf4j
public class JsonWorldDataService {
    private final String baseWorldsDir;

    private final boolean isServer;
    private final Json json;
    @Autowired
    @Lazy
    private WorldService worldService;

    public JsonWorldDataService(String baseWorldsDir, boolean isServer) {
        // Ensure baseWorldsDir is never null and has proper format
        this.baseWorldsDir = baseWorldsDir != null ? baseWorldsDir.trim() : "save/worlds";
        if (this.baseWorldsDir.isEmpty()) {
            throw new IllegalArgumentException("Base worlds directory cannot be empty");
        }
        this.isServer = isServer;
        this.json = new Json();
        this.json.setIgnoreUnknownFields(true);

        // Create base directory if it doesn't exist
        try {
            Files.createDirectories(Paths.get(this.baseWorldsDir));
        } catch (IOException e) {
            log.error("Failed to create base worlds directory: {}", e.getMessage());
        }
    }



    private Path playerDataFolderPath(String worldName) {
        return worldFolderPath(worldName).resolve("playerdata");
    }

    public void savePlayerData(String worldName, PlayerData playerData) throws IOException {
        if (worldName == null || playerData == null || playerData.getUsername() == null) {
            log.warn("Attempted to save invalid player data");
            return;
        }

        Path folder = playerDataFolderPath(worldName);
        Files.createDirectories(folder);

        Path file = folder.resolve(playerData.getUsername() + ".json");
        try (Writer w = Files.newBufferedWriter(file)) {
            json.toJson(playerData, w);
        }
    }

    public PlayerData loadPlayerData(String worldName, String username) throws IOException {
        if (worldName == null || username == null) {
            log.warn("Attempted to load player data with null world name or username");
            return null;
        }

        Path folder = playerDataFolderPath(worldName);
        if (!Files.exists(folder)) {
            Files.createDirectories(folder);
            return null;
        }

        Path file = folder.resolve(username + ".json");
        if (!Files.exists(file)) {
            return null;
        }

        try (Reader r = Files.newBufferedReader(file)) {
            return json.fromJson(PlayerData.class, r);
        } catch (Exception e) {
            log.error("Error loading player data for {}: {}", username, e.getMessage());
            return null;
        }
    }
    private Path worldFolderPath(String worldName) {
        if (worldName == null || worldName.trim().isEmpty()) {
            throw new IllegalArgumentException("World name cannot be null or empty");
        }
        return Paths.get(baseWorldsDir, worldName.trim());
    }
    // The main world JSON file -> e.g. "assets/save/worlds/<worldName>/<worldName>.json"
    private Path worldFilePath(String worldName) {
        return worldFolderPath(worldName).resolve(worldName + ".json");
    }

    @SuppressWarnings("unused")
    public boolean worldExists(String worldName) {
        Path folder = worldFolderPath(worldName);
        Path worldFile = worldFilePath(worldName);
        return Files.exists(folder) && Files.exists(worldFile);
    }

    public void loadWorld(String worldName, WorldData worldData) throws IOException {
        if (worldName == null || worldName.trim().isEmpty()) {
            throw new IllegalArgumentException("World name cannot be null or empty");
        }
        if (worldData == null) {
            throw new IllegalArgumentException("WorldData instance cannot be null");
        }

        Path worldFile = worldFilePath(worldName);
        if (!Files.exists(worldFile)) {
            throw new NoSuchFileException("World file not found: " + worldFile);
        }

        try (Reader reader = Files.newBufferedReader(worldFile)) {
            WorldData loaded = json.fromJson(WorldData.class, reader);
            if (loaded == null) {
                throw new IOException("Failed to parse world data for " + worldName);
            }

            // Set the world data
            worldData.setWorldName(loaded.getWorldName());
            worldData.setSeed(loaded.getSeed());
            worldData.setCreatedDate(loaded.getCreatedDate());
            worldData.setLastPlayed(loaded.getLastPlayed());
            worldData.setPlayedTime(loaded.getPlayedTime());

            // Clear and copy collections
            worldData.getPlayers().clear();
            worldData.getPlayers().putAll(loaded.getPlayers());
            worldData.getChunks().clear();
            worldData.getChunks().putAll(loaded.getChunks());

            log.info("Successfully loaded world data for '{}'", worldName);
        } catch (Exception e) {
            log.error("Error loading world '{}': {}", worldName, e.getMessage());
            throw new IOException("Failed to load world: " + worldName, e);
        }
    }

    public void saveWorld(WorldData worldData) throws IOException {
        if (worldData == null) {
            throw new IllegalArgumentException("WorldData cannot be null");
        }
        if (worldData.getWorldName() == null || worldData.getWorldName().isEmpty()) {
            throw new IllegalStateException("Cannot save a world with no name");
        }

        Path folder = worldFolderPath(worldData.getWorldName());
        if (!Files.exists(folder)) {
            Files.createDirectories(folder);
        }

        Path worldFile = worldFilePath(worldData.getWorldName());
        try (Writer writer = Files.newBufferedWriter(worldFile)) {
            json.toJson(worldData, writer);
            log.info("Successfully saved world data for '{}'", worldData.getWorldName());
        } catch (Exception e) {
            log.error("Error saving world '{}': {}", worldData.getWorldName(), e.getMessage());
            throw new IOException("Failed to save world", e);
        }
    }

    // -------------------------------------------------
    // Chunk storage: "assets/save/worlds/<worldName>/chunks/x,y.json"
    // -------------------------------------------------

    public ChunkData loadChunk(String worldName, int chunkX, int chunkY) throws IOException {
        Path p = chunkFilePath(worldName, chunkX, chunkY);
        if (!Files.exists(p)) {
            return null;
        }
        try (Reader r = Files.newBufferedReader(p)) {
            return json.fromJson(ChunkData.class, r);
        }
    }

    public void saveChunk(String worldName, ChunkData chunkData) throws IOException {
        synchronized (this) {
            Path p = chunkFilePath(worldName, chunkData.getChunkX(), chunkData.getChunkY());
            if (!Files.exists(p.getParent())) {
                Files.createDirectories(p.getParent());
            }
            // brand-new 'json' per call:
            Json localJson = new Json();
            localJson.setIgnoreUnknownFields(true);

            try (Writer writer = Files.newBufferedWriter(p)) {
                localJson.toJson(chunkData, writer);
            }
        }
    }


    private Path chunkFilePath(String worldName, int chunkX, int chunkY) {
        // e.g. "assets/save/worlds/<worldName>/chunks/<chunkX>,<chunkY>.json"
        return worldFolderPath(worldName)
            .resolve("chunks")
            .resolve(chunkX + "," + chunkY + ".json");
    }


    public List<String> listAllWorlds() {
        List<String> result = new ArrayList<>();
        Path root = Paths.get(baseWorldsDir);  // e.g. "assets/save/worlds"
        if (!Files.exists(root)) {
            return result;
        }
        try {
            Files.list(root)
                .filter(Files::isDirectory)
                .forEach(path -> {
                    // We check if <worldName>/<worldName>.json exists
                    String folderName = path.getFileName().toString();
                    Path worldJson = path.resolve(folderName + ".json");
                    if (Files.exists(worldJson)) {
                        result.add(folderName);
                    }
                });
        } catch (IOException e) {
            log.warn("Could not list worlds: {}", e.getMessage());
        }
        return result;
    }

    /**
     * Delete entire world folder
     */
    public void deleteWorld(String worldName) {
        Path folder = worldFolderPath(worldName);
        if (!Files.exists(folder)) {
            return;
        }
        try {
            Files.walk(folder)
                .sorted((p1, p2) -> p2.getNameCount() - p1.getNameCount()) // files first
                .forEach(f -> {
                    try {
                        Files.delete(f);
                    } catch (IOException e) {
                        log.warn("Failed deleting {}", f);
                    }
                });
        } catch (IOException e) {
            log.warn("Failed to fully delete world '{}': {}", worldName, e.getMessage());
        }
    }

    /**
     * Delete a chunk JSON
     */
    public void deleteChunk(String worldName, int chunkX, int chunkY) {
        try {
            Path p = chunkFilePath(worldName, chunkX, chunkY);
            Files.deleteIfExists(p);
        } catch (IOException e) {
            log.warn("Failed to delete chunk {}/({},{})", worldName, chunkX, chunkY);
        }
    }
}

================
File: main/java/io.github.minemon/world/service/impl/ObjectTextureManager.java
================
package io.github.minemon.world.service.impl;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;

@Service
@Slf4j
public class ObjectTextureManager {
    private TextureAtlas atlas;
    private final Map<String, TextureRegion> regionCache = new HashMap<>();
    private boolean initialized = false;

    public void initializeIfNeeded() {
        if (initialized) return;

        if (Gdx.files == null) {
            log.warn("Gdx environment not ready. Cannot load atlas yet.");
            return;
        }

        String ATLAS_PATH = "atlas/tiles-gfx-atlas.atlas";
        if (!Gdx.files.internal(ATLAS_PATH).exists()) {
            log.error("Atlas file not found at: {}", ATLAS_PATH);
            return;
        }

        atlas = new TextureAtlas(Gdx.files.internal(ATLAS_PATH));

        // Set the filter for every texture inside the atlas
        for (TextureAtlas.AtlasRegion region : atlas.getRegions()) {
            region.getTexture().setFilter(
                com.badlogic.gdx.graphics.Texture.TextureFilter.Nearest,
                com.badlogic.gdx.graphics.Texture.TextureFilter.Nearest
            );region.getTexture().setWrap(Texture.TextureWrap.ClampToEdge, Texture.TextureWrap.ClampToEdge);

        }

        // Verify all tree textures are loading
        verifyTreeTextures();

        initialized = true;
        log.info("ObjectTextureManager initialized successfully");
    }


    private void verifyTreeTextures() {
        String[] treeTypes = {
            "treeONE", "treeTWO", "snow_tree", "haunted_tree",
            "ruins_tree", "apricorn_tree_grown", "rain_tree", "CherryTree"
        };

        for (String treeName : treeTypes) {
            TextureRegion region = atlas.findRegion(treeName);
            if (region == null) {
                log.error("Failed to load tree texture: {}", treeName);
            } else {
                regionCache.put(treeName, region);
                log.debug("Successfully loaded tree texture: {}", treeName);
            }
        }
    }

    public TextureRegion getTexture(String name) {
        if (!initialized) {
            initializeIfNeeded();
        }

        if (name == null) {
            log.warn("Null texture name requested");
            return null;
        }

        // Check cache first
        TextureRegion cached = regionCache.get(name);
        if (cached != null) {
            return cached;
        }

        // Try to load from atlas
        TextureRegion region = atlas.findRegion(name);
        if (region == null) {
            log.warn("No region found for '{}', trying 'unknown' texture", name);
            region = atlas.findRegion("unknown");
            if (region == null) {
                log.error("No 'unknown' region found in atlas either!");
                return null;
            }
        }

        // Cache for future use
        regionCache.put(name, region);
        return region;
    }

    public void disposeTextures() {
        if (atlas != null) {
            atlas.dispose();
            atlas = null;
            log.info("Disposed ObjectTextureManager atlas");
        }
        regionCache.clear();
        initialized = false;
    }
}

================
File: main/java/io.github.minemon/world/service/impl/WorldGeneratorImpl.java
================
package io.github.minemon.world.service.impl;

import io.github.minemon.utils.OpenSimplex2;
import io.github.minemon.world.biome.model.BiomeType;
import io.github.minemon.world.config.WorldConfig;
import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.service.WorldGenerator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.Random;

@Service
public class WorldGeneratorImpl implements WorldGenerator {
    private long seed;
    private Map<BiomeType, Biome> biomes;
    private final WorldConfig config;

    @Autowired
    public WorldGeneratorImpl(WorldConfig config) {
        this.config = config;
    }

    @Override
    public void setSeedAndBiomes(long seed, Map<BiomeType, Biome> biomes) {
        this.seed = seed;
        this.biomes = biomes;
    }

    @Override
    public Biome getBiomeForChunk(int chunkX, int chunkY) {
        if (biomes == null || biomes.isEmpty()) {
            return null;
        }

        float NOISE_SCALE = 0.005f;
        float n = OpenSimplex2.noise2(seed, chunkX * NOISE_SCALE, chunkY * NOISE_SCALE);
        BiomeType selectedBiome = n > 0 ? BiomeType.PLAINS : BiomeType.DESERT;
        return biomes.get(selectedBiome);
    }

    @Override
    public int[][] generateChunk(int chunkX, int chunkY) {
        // Optionally get the biome for the chunk
        Biome biome = getBiomeForChunk(chunkX, chunkY);
        int chunkSize = config.getChunkSize();

        int[][] tiles = new int[chunkSize][chunkSize];
        if (biome == null) {
            // Fallback if no biome found
            for (int x = 0; x < chunkSize; x++) {
                for (int y = 0; y < chunkSize; y++) {
                    tiles[x][y] = 1;
                }
            }
            return tiles;
        }

        Random chunkRandom = new Random(seed ^ (chunkX * 341_757L) ^ (chunkY * 132_721L));
        double total = biome.getTileDistribution().values().stream().mapToDouble(Double::doubleValue).sum();

        for (int x = 0; x < chunkSize; x++) {
            for (int y = 0; y < chunkSize; y++) {
                double roll = chunkRandom.nextDouble() * total;
                double cumulative = 0;
                for (Map.Entry<Integer, Double> entry : biome.getTileDistribution().entrySet()) {
                    cumulative += entry.getValue();
                    if (roll < cumulative) {
                        tiles[x][y] = entry.getKey();
                        break;
                    }
                }
            }
        }
        return tiles;
    }

}

================
File: main/java/io.github.minemon/world/service/impl/WorldObjectManagerImpl.java
================
package io.github.minemon.world.service.impl;

import com.badlogic.gdx.math.Rectangle;
import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.model.ObjectType;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.world.service.WorldObjectManager;
import io.github.minemon.world.service.WorldService;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

@Service
@Slf4j
public class WorldObjectManagerImpl implements WorldObjectManager {

    private static final int CHUNK_SIZE = 16;
    private static final int TILE_SIZE = 32;
    private final boolean isServer;
    private static final float MIN_OBJECT_SPACING = 2.0f;  // Minimum tiles between objects
    private static final float TREE_SPACING = 3.0f;       // Minimum tiles between trees

    private final Map<String, List<WorldObject>> objectsByChunk = new ConcurrentHashMap<>();

    @Autowired
    @Lazy  // Add this to break the cycle
    private WorldService worldService;
    @Getter
    @Setter
    private boolean singlePlayer = true;

    public WorldObjectManagerImpl() {
        this.isServer = "server".equals(System.getProperty("spring.profiles.active"));
        log.info("WorldObjectManager initialized with isServer={}", isServer);
    }

    @Override
    public void initialize() {

        log.info("WorldObjectManagerImpl initialized. singlePlayer={}", singlePlayer);
    }

    @Override
    public void loadObjectsForChunk(int chunkX, int chunkY, List<WorldObject> objects) {
        if (!isServer && worldService.isMultiplayerMode()) {
            log.debug("Client skipping local object loading in multiplayer mode");
            return;
        }
        if (objects == null) {
            objects = Collections.emptyList();
        }
        String key = chunkX + "," + chunkY;
        objectsByChunk.put(key, objects);
        log.debug("Loaded {} objects for chunk {}", objects.size(), key);
    }
    private boolean canPlaceObject(List<WorldObject> existingObjects, int x, int y, ObjectType type) {
        float minSpacing = type.name().contains("TREE") ? 4.0f : 2.0f;
        Rectangle newObjBounds = new Rectangle(
            x * TILE_SIZE - (type.getWidthInTiles() * TILE_SIZE / 2f),
            y * TILE_SIZE,
            type.getWidthInTiles() * TILE_SIZE,
            type.getHeightInTiles() * TILE_SIZE
        );

        // Add spacing buffer
        newObjBounds.x -= TILE_SIZE * minSpacing;
        newObjBounds.y -= TILE_SIZE * minSpacing;
        newObjBounds.width += TILE_SIZE * minSpacing * 2;
        newObjBounds.height += TILE_SIZE * minSpacing * 2;

        for (WorldObject existing : existingObjects) {
            Rectangle existingBounds = new Rectangle(
                existing.getTileX() * TILE_SIZE - (existing.getType().getWidthInTiles() * TILE_SIZE / 2f),
                existing.getTileY() * TILE_SIZE,
                existing.getType().getWidthInTiles() * TILE_SIZE,
                existing.getType().getHeightInTiles() * TILE_SIZE
            );

            if (newObjBounds.overlaps(existingBounds)) {
                return false;
            }
        }

        return true;
    }
    @Override
    public List<WorldObject> generateObjectsForChunk(int chunkX, int chunkY, int[][] tiles, Biome biome, long seed) {
        List<WorldObject> objects = new CopyOnWriteArrayList<>();
        if (biome == null || tiles == null) {
            return objects;
        }

        long chunkSeed = seed + chunkX * 341873128712L + chunkY * 132897987541L;
        Random random = new Random(chunkSeed);

        // First pass: Generate trees with proper spacing
        if (biome.getSpawnableObjects() != null) {
            // Sort objects so trees are placed first (they need more space)
            List<String> sortedObjects = new ArrayList<>(biome.getSpawnableObjects());
            sortedObjects.sort((a, b) -> {
                boolean aIsTree = a.contains("TREE");
                boolean bIsTree = b.contains("TREE");
                return bIsTree ? -1 : (aIsTree ? 1 : 0); // Trees first
            });

            for (String objTypeName : sortedObjects) {
                ObjectType type;
                try {
                    type = ObjectType.valueOf(objTypeName);
                    double spawnChance = biome.getSpawnChanceForObject(type);
                    int attempts = (int)(spawnChance * (CHUNK_SIZE * CHUNK_SIZE));

                    for (int i = 0; i < attempts; i++) {
                        int localX = random.nextInt(CHUNK_SIZE);
                        int localY = random.nextInt(CHUNK_SIZE);

                        // Check if tile type is valid
                        if (!biome.getAllowedTileTypes().contains(tiles[localX][localY])) {
                            continue;
                        }

                        int worldX = chunkX * CHUNK_SIZE + localX;
                        int worldY = chunkY * CHUNK_SIZE + localY;

                        if (canPlaceObject(objects, worldX, worldY, type)) {
                            WorldObject obj = new WorldObject(worldX, worldY, type, type.isCollidable());
                            objects.add(obj);
                        }
                    }
                } catch (IllegalArgumentException e) {
                    log.warn("Invalid object type {} in biome {}", objTypeName, biome.getName());
                }
            }
        }

        return objects;
    }


    private void generateTreesWithSpacing(List<WorldObject> objects, ObjectType type,
                                          Biome biome, int[][] tiles, Random random,
                                          int chunkX, int chunkY) {
        double spawnChance = biome.getSpawnChanceForObject(type);
        int attempts = (int)(spawnChance * (CHUNK_SIZE * CHUNK_SIZE));

        for (int i = 0; i < attempts; i++) {
            int localX = random.nextInt(CHUNK_SIZE);
            int localY = random.nextInt(CHUNK_SIZE);
            int worldX = chunkX * CHUNK_SIZE + localX;
            int worldY = chunkY * CHUNK_SIZE + localY;

            // Check tile type
            if (!biome.getAllowedTileTypes().contains(tiles[localX][localY])) {
                continue;
            }

            // Enhanced spacing check for trees
            if (hasSpaceForTree(objects, worldX, worldY)) {
                WorldObject tree = new WorldObject(worldX, worldY, type, true);
                objects.add(tree);
            }
        }
    }
    private void generateRegularObjects(List<WorldObject> objects, ObjectType type,
                                        Biome biome, int[][] tiles, Random random,
                                        int chunkX, int chunkY) {
        double spawnChance = biome.getSpawnChanceForObject(type);
        int attempts = (int)(spawnChance * (CHUNK_SIZE * CHUNK_SIZE));

        for (int i = 0; i < attempts; i++) {
            int localX = random.nextInt(CHUNK_SIZE);
            int localY = random.nextInt(CHUNK_SIZE);

            if (!biome.getAllowedTileTypes().contains(tiles[localX][localY])) {
                continue;
            }

            int worldX = chunkX * CHUNK_SIZE + localX;
            int worldY = chunkY * CHUNK_SIZE + localY;

            if (hasSpaceForObject(objects, worldX, worldY, type)) {
                WorldObject obj = new WorldObject(worldX, worldY, type, type.isCollidable());
                objects.add(obj);
            }
        }
    }
    private boolean hasSpaceForObject(List<WorldObject> objects, int x, int y, ObjectType type) {
        int minSpacing = type.name().contains("TREE") ? (int) TREE_SPACING : 2;

        for (WorldObject obj : objects) {
            int dx = Math.abs(obj.getTileX() - x);
            int dy = Math.abs(obj.getTileY() - y);

            if (dx < minSpacing && dy < minSpacing) {
                return false;
            }
        }
        return true;
    }

    private boolean isTreeType(ObjectType type) {
        return type == ObjectType.TREE_0 ||
            type == ObjectType.TREE_1 ||
            type == ObjectType.SNOW_TREE ||
            type == ObjectType.HAUNTED_TREE ||
            type == ObjectType.RUINS_TREE ||
            type == ObjectType.APRICORN_TREE ||
            type == ObjectType.RAIN_TREE ||
            type == ObjectType.CHERRY_TREE;
    }
    private boolean hasSpaceForTree(List<WorldObject> objects, int x, int y) {
        // Check a larger area for trees to prevent overlapping
        for (WorldObject obj : objects) {
            if (isTreeType(obj.getType())) {
                int dx = Math.abs(obj.getTileX() - x);
                int dy = Math.abs(obj.getTileY() - y);

                // Enforce minimum spacing between trees
                if (dx < TREE_SPACING && dy < TREE_SPACING) {
                    return false;
                }
            }
        }
        return true;
    }


    @Override
    public List<WorldObject> getObjectsForChunk(int chunkX, int chunkY) {
        String key = chunkX + "," + chunkY;
        return objectsByChunk.getOrDefault(key, Collections.emptyList());
    }

    @Override
    public void addObject(WorldObject object) {
        int chunkX = object.getTileX() / CHUNK_SIZE;
        int chunkY = object.getTileY() / CHUNK_SIZE;
        String key = chunkX + "," + chunkY;
        objectsByChunk.computeIfAbsent(key, k -> new CopyOnWriteArrayList<>()).add(object);
        log.debug("Added object {} to chunk {}", object.getId(), key);
    }

    @Override
    public void removeObject(String objectId) {
        for (Map.Entry<String, List<WorldObject>> entry : objectsByChunk.entrySet()) {
            List<WorldObject> objs = entry.getValue();
            boolean removed = objs.removeIf(o -> o.getId().equals(objectId));
            if (removed) {
                log.debug("Removed object {} from chunk {}", objectId, entry.getKey());
                break;
            }
        }
    }
}

================
File: main/java/io.github.minemon/world/service/TileManager.java
================
package io.github.minemon.world.service;

import com.badlogic.gdx.graphics.g2d.TextureRegion;

public interface TileManager {
    void initIfNeeded();
    TextureRegion getRegionForTile(int tileId);
    boolean isPassable(int tileId);
    String getTileName(int tileId);
}

================
File: main/java/io.github.minemon/world/service/WorldGenerator.java
================
package io.github.minemon.world.service;

import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.biome.model.BiomeType;

public interface WorldGenerator {
    void setSeedAndBiomes(long seed, java.util.Map<BiomeType, Biome> biomes);
    int[][] generateChunk(int chunkX, int chunkY);
    Biome getBiomeForChunk(int chunkX, int chunkY);
}

================
File: main/java/io.github.minemon/world/service/WorldObjectManager.java
================
package io.github.minemon.world.service;

import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.model.WorldObject;

import java.util.List;

public interface WorldObjectManager {
    void initialize();
    List<WorldObject> generateObjectsForChunk(int chunkX, int chunkY, int[][] tiles, Biome biome, long seed);
    List<WorldObject> getObjectsForChunk(int chunkX, int chunkY);
    void addObject(WorldObject object);
    void removeObject(String objectId);
    void loadObjectsForChunk(int chunkX, int chunkY, List<WorldObject> objects);
}

================
File: main/java/io.github.minemon/world/service/WorldService.java
================
package io.github.minemon.world.service;

import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.minemon.multiplayer.model.WorldObjectUpdate;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.world.model.ChunkData;
import io.github.minemon.world.model.WorldData;
import io.github.minemon.world.model.WorldObject;

import java.util.List;
import java.util.Map;

public interface WorldService {
    void clearWorldData();

    void initIfNeeded();

    void forceLoadChunksAt(float tileX, float tileY);

    default ChunkData loadOrGenerateChunk(int chunkX, int chunkY) {
        return null;
    }

    void update(float delta);

    void handleDisconnect();

    WorldData getWorldData();

    boolean isMultiplayerMode();

    void setMultiplayerMode(boolean multiplayer);

    void loadOrReplaceChunkData(int chunkX, int chunkY, int[][] tiles, List<WorldObject> objects);

    void updateWorldObjectState(WorldObjectUpdate update);

    TileManager getTileManager();

    boolean createWorld(String worldName, long seed);

    void loadWorld(String worldName);

    List<WorldObject> getVisibleObjects(Rectangle viewBounds);

    OrthographicCamera getCamera();

    void setCamera(OrthographicCamera camera);

    boolean isChunkLoaded(Vector2 chunkPos);

    void loadChunk(Vector2 chunkPos);

    Map<String, ChunkData> getVisibleChunks(Rectangle viewBounds);

    void saveWorldData();

    void loadWorldData();

    List<String> getAvailableWorlds();

    void deleteWorld(String worldName);


    void setPlayerData(PlayerData playerData);

    PlayerData getPlayerData(String username);


    int[][] getChunkTiles(int chunkX, int chunkY);

    void regenerateChunk(int chunkX, int chunkY);


    void generateWorldThumbnail(String worldName);

    void preloadChunksAroundPosition(float i, float i1);
}

================
File: main/java/io.github.minemon/world/SpawnPoint.java
================
package io.github.minemon.world;

import lombok.Data;

@Data
class SpawnPoint {
    private float x;
    private float y;
    private long timestamp;

    public SpawnPoint() {
        this(0, 0);
    }

    public SpawnPoint(float x, float y) {
        this.x = x;
        this.y = y;
        this.timestamp = System.currentTimeMillis();
    }
}

================
File: main/java/io.github.minemon/world/SpawnService.java
================
package io.github.minemon.world;

import com.badlogic.gdx.utils.Json;
import io.github.minemon.core.service.FileAccessService;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
@Slf4j
public class SpawnService {
    private static final String SPAWN_FILE = "spawn.json";
    private final FileAccessService fileAccessService;
    private final WorldService worldService;
    private SpawnPoint defaultSpawn;
    private final Json json;

    @Autowired
    public SpawnService(FileAccessService fileAccessService, WorldService worldService) {
        this.fileAccessService = fileAccessService;
        this.worldService = worldService;
        this.json = new Json();
        this.defaultSpawn = new SpawnPoint(0, 0);
        loadSpawn();
    }

    public void setSpawn(float x, float y) {
      SpawnPoint newSpawn = new SpawnPoint(x, y);

        if (worldService.isMultiplayerMode()) {
            // In multiplayer, we just update the local cache
            this.defaultSpawn = newSpawn;
        } else {
            // In singleplayer, persist to file
            this.defaultSpawn = newSpawn;
            saveSpawn();
        }
    }

    public SpawnPoint getSpawn() {
        return defaultSpawn;
    }

    private void loadSpawn() {
        try {
            String worldName = worldService.getWorldData().getWorldName();
            if (worldName == null) return;

            String path = "save/worlds/" + worldName + "/" + SPAWN_FILE;
            if (fileAccessService.exists(path)) {
                String content = fileAccessService.readFile(path);
                SpawnPoint loaded = json.fromJson(SpawnPoint.class, content);
                if (loaded != null) {
                    this.defaultSpawn = loaded;
                }
            }
        } catch (Exception e) {
            log.error("Failed to load spawn point: {}", e.getMessage());
        }
    }

    private void saveSpawn() {
        try {
            String worldName = worldService.getWorldData().getWorldName();
            if (worldName == null) return;

            String path = "save/worlds/" + worldName + "/" + SPAWN_FILE;
            String content = json.toJson(defaultSpawn);
            fileAccessService.writeFile(path, content);
        } catch (Exception e) {
            log.error("Failed to save spawn point: {}", e.getMessage());
        }
    }
}
