This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-01T11:28:02.375Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
io/github/minemon/server/AuthService.java
io/github/minemon/server/config/MultiplayerConfig.java
io/github/minemon/server/config/PersistenceConfig.java
io/github/minemon/server/config/ServerConnectionConfig.java
io/github/minemon/server/config/WorldObjectConfig.java
io/github/minemon/server/DeploymentHelper.java
io/github/minemon/server/model/User.java
io/github/minemon/server/repository/UserRepository.java
io/github/minemon/server/ServerApplication.java
io/github/minemon/server/ServerLauncher.java
io/github/minemon/server/service/impl/MultiplayerServerImpl.java
io/github/minemon/server/service/impl/MultiplayerServiceImpl.java
io/github/minemon/server/service/impl/ServerCleanupService.java
io/github/minemon/server/service/MultiplayerServer.java
io/github/minemon/server/service/MultiplayerService.java
io/github/minemon/server/world/ServerTileManagerImpl.java
io/github/minemon/server/world/ServerWorldObjectManagerImpl.java
io/github/minemon/server/world/ServerWorldServiceImpl.java

================================================================
Files
================================================================

================
File: io/github/minemon/server/AuthService.java
================
package io.github.minemon.server;

import io.github.minemon.server.model.User;
import io.github.minemon.server.repository.UserRepository;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;

@Service
public class AuthService {
    private final UserRepository userRepository;

    public AuthService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public boolean authenticate(String username, String password) {
        User user = userRepository.findByUsername(username);
        return user != null && BCrypt.checkpw(password, user.getPasswordHash());
    }

    public boolean createUser(String username, String rawPassword) {
        if (userRepository.findByUsername(username) != null) {
            return false;
        }
        String hashed = BCrypt.hashpw(rawPassword, BCrypt.gensalt());
        User newUser = new User(username, hashed);
        userRepository.save(newUser);
        return true;
    }
}

================
File: io/github/minemon/server/config/MultiplayerConfig.java
================
package io.github.minemon.server.config;

import io.github.minemon.core.service.FileAccessService;
import io.github.minemon.core.service.impl.LocalFileAccessService;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.server.service.MultiplayerServer;
import io.github.minemon.server.service.MultiplayerService;
import io.github.minemon.server.service.impl.MultiplayerServerImpl;
import io.github.minemon.server.service.impl.MultiplayerServiceImpl;
import io.github.minemon.world.service.WorldService;
import io.github.minemon.multiplayer.service.ServerConnectionService;
import io.github.minemon.multiplayer.service.impl.ServerConnectionServiceImpl;
import io.github.minemon.event.EventBus;
import io.github.minemon.server.AuthService;
import io.github.minemon.world.service.impl.JsonWorldDataService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;

@Configuration
public class MultiplayerConfig {

    @Bean
    public FileAccessService fileAccessService() {
        return new LocalFileAccessService();
    }

    @Bean
    public ServerConnectionService serverConnectionService(FileAccessService fileAccessService) {
        return new ServerConnectionServiceImpl(fileAccessService);
    }

    @Bean
    public MultiplayerService multiplayerService(WorldService worldService, PlayerService playerService, Environment env) {
        return new MultiplayerServiceImpl(worldService, env);
    }

    @Bean(name = "serverJsonWorldDataService")
    public JsonWorldDataService serverJsonWorldDataService() {
        return new JsonWorldDataService("save/worlds", true);
    }
    @Bean
    public MultiplayerServer multiplayerServer(MultiplayerService multiplayerService, EventBus eventBus, AuthService authService) {
        return new MultiplayerServerImpl(multiplayerService, eventBus, authService);
    }

}

================
File: io/github/minemon/server/config/PersistenceConfig.java
================
package io.github.minemon.server.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.sql.DataSource;
import java.util.Properties;

@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(basePackages = "io.github.minemon.server.repository")
public class PersistenceConfig {

    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("org.h2.Driver");
        dataSource.setUrl("jdbc:h2:file:./data/serverdb;DB_CLOSE_ON_EXIT=FALSE");
        dataSource.setUsername("sa");
        dataSource.setPassword("");
        return dataSource;
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource());
        em.setPackagesToScan("io.github.minemon.server.model");

        HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
        em.setJpaVendorAdapter(vendorAdapter);

        Properties properties = new Properties();
        properties.setProperty("hibernate.hbm2ddl.auto", "update");
        properties.setProperty("hibernate.dialect", "org.hibernate.dialect.H2Dialect");
        properties.setProperty("hibernate.show_sql", "true");
        em.setJpaProperties(properties);

        return em;
    }

    @Bean
    public PlatformTransactionManager transactionManager() {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(entityManagerFactory().getObject());
        return transactionManager;
    }
}

================
File: io/github/minemon/server/config/ServerConnectionConfig.java
================
package io.github.minemon.server.config;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class ServerConnectionConfig {
    private String serverIP = "127.0.0.1";
    private int tcpPort = 54555;
    private int udpPort = 54777;
    private int maxPlayers = 20;
    private String iconPath = "";
    private String motd = "";
    private String serverName = "Default Server";
    private String version = "1.0";
    private String dataDirectory = "worlds";
    private boolean isDefault = false;
    private int currentPlayers = 0;


    private boolean rememberMe = false;
    private String savedUsername = "";
    private String savedPassword = "";

    @Override
    public String toString() {
        return serverName + " (" + serverIP + ":" + tcpPort + ")";
    }
}

================
File: io/github/minemon/server/config/WorldObjectConfig.java
================
package main.java.io.github.minemon.server.config;

import io.github.minemon.world.service.WorldObjectManager;
import io.github.minemon.server.world.ServerWorldObjectManagerImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class WorldObjectConfig {

    @Bean
    public WorldObjectManager serverWorldObjectManager() {
        return new ServerWorldObjectManagerImpl();
    }
}

================
File: io/github/minemon/server/DeploymentHelper.java
================
package io.github.minemon.server;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.logging.Logger;

public class DeploymentHelper {
    private static final Logger logger = Logger.getLogger(DeploymentHelper.class.getName());


    public static void createServerDeployment(Path baseDir) throws IOException {

        Path runScript = baseDir.resolve("run.sh");
        if (Files.exists(runScript)) {
            logger.info("Deployment structure already set up at " + baseDir.toAbsolutePath());
            return;
        }


        createDirIfNotExists(baseDir, "config");
        createDirIfNotExists(baseDir, "logs");
        createDirIfNotExists(baseDir, "data");
        createDirIfNotExists(baseDir, "plugins");


        Path propertiesFile = baseDir.resolve("config").resolve("application.properties");
        if (Files.notExists(propertiesFile)) {
            String defaultConfig = """
                    # Default server configuration
                    server.motd=Welcome to PokeMeetup!
                    server.maxPlayers=20
                    # Add more server configs as needed
                    """;
            Files.writeString(propertiesFile, defaultConfig, StandardOpenOption.CREATE_NEW);
            logger.info("Created default application.properties at " + propertiesFile);
        }


        if (Files.notExists(runScript)) {
            String script = """
                    #!/bin/bash
                    # Simple startup script
                    # Assuming the jar is in the same directory as this script
                    java -jar pokemeetup-0.0.1-SNAPSHOT-server.jar 54555 54777
                    """;
            Files.writeString(runScript, script, StandardOpenOption.CREATE_NEW);
            runScript.toFile().setExecutable(true);
            logger.info("Created run.sh at " + runScript);
        }

        logger.info("Server deployment structure ensured at " + baseDir.toAbsolutePath());
    }

    private static void createDirIfNotExists(Path base, String name) throws IOException {
        Path dir = base.resolve(name);
        if (Files.notExists(dir)) {
            Files.createDirectories(dir);
        }
    }
}

================
File: io/github/minemon/server/model/User.java
================
package io.github.minemon.server.model;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

@Entity
@Data
@Table(name = "app_user")
public class User {

    @Id
    private String username;

    private String passwordHash;

    public User() {}

    public User(String username, String passwordHash) {
        this.username = username;
        this.passwordHash = passwordHash;
    }
}

================
File: io/github/minemon/server/repository/UserRepository.java
================
package io.github.minemon.server.repository;

import io.github.minemon.server.model.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, String> {
    User findByUsername(String username);
}

================
File: io/github/minemon/server/ServerApplication.java
================
package io.github.minemon.server;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServerApplication.class, args);
    }
}

================
File: io/github/minemon/server/ServerLauncher.java
================
package io.github.minemon.server;

import io.github.minemon.lwjgl3.PokemeetupApplication;
import io.github.minemon.multiplayer.model.ServerConnectionConfig;
import io.github.minemon.multiplayer.service.ServerConnectionService;
import io.github.minemon.plugin.PluginManager;
import io.github.minemon.server.service.MultiplayerServer;
import io.github.minemon.world.service.WorldService;  // <-- Assuming your world service is here
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.Banner;
import org.springframework.boot.SpringApplication;
import org.springframework.context.ConfigurableApplicationContext;

import java.nio.file.Path;
import java.nio.file.Paths;

@Slf4j
public class ServerLauncher {

    public static void main(String[] args) {

        int tcpPort = 54555;
        int udpPort = 54777;

        if (args.length > 0) {
            try {
                tcpPort = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                log.warn("Invalid TCP port argument, using default: {}", tcpPort);
            }
        }

        if (args.length > 1) {
            try {
                udpPort = Integer.parseInt(args[1]);
            } catch (NumberFormatException e) {
                log.warn("Invalid UDP port argument, using default: {}", udpPort);
            }
        }

        Path baseDir = Paths.get("").toAbsolutePath();
        log.info("Base directory: {}", baseDir);

        try {
            DeploymentHelper.createServerDeployment(baseDir);
        } catch (Exception e) {
            log.error("Failed to create server deployment: {}", e.getMessage());
            System.exit(1);
        }

        SpringApplication app = new SpringApplication(PokemeetupApplication.class);
        app.setBannerMode(Banner.Mode.OFF);
        app.setAdditionalProfiles("server");
        ConfigurableApplicationContext context = app.run(args);

        // NEW CALL: ensure the server's default world is created or loaded
        onServerStart(context);

        MultiplayerServer server = context.getBean(MultiplayerServer.class);
        ServerConnectionService connectionService = context.getBean(ServerConnectionService.class);
        PluginManager pluginManager = context.getBean(PluginManager.class);

        ServerConnectionConfig config = connectionService.loadConfig();
        if (config.getServerIP() == null) {
            config.setServerName("PokeMeetupServer");
            config.setServerIP("0.0.0.0");
            config.setTcpPort(tcpPort);
            config.setUdpPort(udpPort);
            config.setMotd("Welcome to PokeMeetup!");
            config.setMaxPlayers(20);
            connectionService.saveConfig(config);
        }

        server.startServer(config.getTcpPort(), config.getUdpPort());
        log.info("Server started on TCP: {}, UDP: {}", config.getTcpPort(), config.getUdpPort());

        Path pluginsDir = baseDir.resolve("plugins");
        pluginManager.loadPlugins(pluginsDir);

        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            log.info("Shutting down server...");
            pluginManager.unloadAll();
            server.stopServer();
        }));

        final int TICKS_PER_SECOND = 20;
        final long OPTIMAL_TIME = 1_000_000_000 / TICKS_PER_SECOND;
        long lastLoopTime = System.nanoTime();

        while (context.isActive()) {
            long now = System.nanoTime();
            long updateLength = now - lastLoopTime;
            lastLoopTime = now;

            float deltaSeconds = updateLength / 1_000_000_000f;
            server.processMessages(deltaSeconds);

            long sleepTime = (OPTIMAL_TIME - (System.nanoTime() - lastLoopTime)) / 1_000_000;
            if (sleepTime > 0) {
                try {
                    Thread.sleep(sleepTime);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    log.warn("Main loop interrupted: {}", e.getMessage());
                }
            }
        }

        pluginManager.unloadAll();
        server.stopServer();
        log.info("Server Stopped.");
    }

    /**
     * Called once the Spring context is up, before the main game loop starts.
     * Ensures we have a default server world created or loaded, so paths are valid.
     */
    private static void onServerStart(ConfigurableApplicationContext context) {
        // Example: we fetch the service needed to manage the server world:
        WorldService worldService = context.getBean(WorldService.class);

        // The default server world name
        String defaultServerWorldName = "serverWorld";

        // If the world doesn't exist, create it
        if (!worldService.getAvailableWorlds().contains(defaultServerWorldName)) {
            log.info("World '{}' does not exist. Creating it now...", defaultServerWorldName);
            boolean created = worldService.createWorld(defaultServerWorldName, 12345L);
            if (created) {
                log.info("Successfully created new default server world '{}'.", defaultServerWorldName);
            } else {
                log.warn("Failed to create world '{}'. Possibly it exists or there's an error.", defaultServerWorldName);
            }
        } else {
            // Otherwise, load it
            log.info("Loading existing server world '{}'.", defaultServerWorldName);
            worldService.loadWorld(defaultServerWorldName);
        }

        // Possibly call initIfNeeded (which might do chunk loading, etc.)
        worldService.initIfNeeded();
        log.info("Server world initialization complete.");
    }
}

================
File: io/github/minemon/server/service/impl/MultiplayerServerImpl.java
================
package io.github.minemon.server.service.impl;

import com.badlogic.gdx.math.Vector2;
import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.Listener;
import com.esotericsoftware.kryonet.Server;
import io.github.minemon.NetworkProtocol;
import io.github.minemon.event.EventBus;
import io.github.minemon.player.event.PlayerJoinEvent;
import io.github.minemon.player.event.PlayerLeaveEvent;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.multiplayer.model.ChunkUpdate;
import io.github.minemon.multiplayer.model.PlayerSyncData;
import io.github.minemon.server.service.MultiplayerServer;
import io.github.minemon.server.service.MultiplayerService;
import io.github.minemon.world.service.WorldService;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import io.github.minemon.server.AuthService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Slf4j
@Primary
@Service
public class MultiplayerServerImpl implements MultiplayerServer {

    private final MultiplayerService multiplayerService;
    private final EventBus eventBus;
    private final AuthService authService;
    private final Map<Integer, String> connectionUserMap = new ConcurrentHashMap<>();

    private Server server;
    private final Map<String, Map<ChunkKey, Long>> clientChunkCache = new ConcurrentHashMap<>();
    private final ScheduledExecutorService cacheCleanupExecutor =
            Executors.newSingleThreadScheduledExecutor();
    @Getter
    private final Set<ChunkKey> pendingChunkRequests = ConcurrentHashMap.newKeySet();

    @Data
    @AllArgsConstructor
    private static class ChunkKey {
        private final int x;
        private final int y;
    }

    private final Map<String, Long> chunkRequestTimes = new ConcurrentHashMap<>();
    private volatile boolean running = false;
    @Autowired
    private WorldService worldService;

    public MultiplayerServerImpl(MultiplayerService multiplayerService,
                                 EventBus eventBus,
                                 AuthService authService) {
        this.multiplayerService = multiplayerService;
        this.eventBus = eventBus;
        this.authService = authService;
    }

    @Override
    public void startServer(int tcpPort, int udpPort) {
        if (running) {
            log.warn("Server already running.");
            return;
        }

        server = new Server();
        NetworkProtocol.registerClasses(server.getKryo());

        server.addListener(new Listener() {
            @Override
            public void connected(Connection connection) {
                log.info("New connection: {}", connection.getRemoteAddressTCP());
            }

            @Override
            public void disconnected(Connection connection) {
                handleDisconnection(connection);
            }

            @Override
            public void received(Connection connection, Object object) {
                handleMessage(connection, object);
            }
        });

        try {
            server.start();
            server.bind(tcpPort, udpPort);
            running = true;
            log.info("Multiplayer server started on TCP:{} UDP:{}", tcpPort, udpPort);
        } catch (IOException e) {
            log.error("Failed to start server: {}", e.getMessage(), e);
        }
    }

    private void handleDisconnection(Connection connection) {
        String username = connectionUserMap.remove(connection.getID());
        if (username != null) {
            multiplayerService.playerDisconnected(username);
            eventBus.fireEvent(new PlayerLeaveEvent(username));
            log.info("Player {} disconnected", username);
            broadcastPlayerStates();
        } else {
            log.info("Connection {} disconnected without a known user.", connection.getID());
        }
    }

    private void handleMessage(Connection connection, Object object) {
        if (object.getClass().getName().startsWith("com.esotericsoftware.kryonet.FrameworkMessage")) {
            return;
        }
        if (object instanceof NetworkProtocol.LoginRequest req) {
            handleLogin(connection, req);
        } else if (object instanceof NetworkProtocol.CreateUserRequest createReq) {
            handleCreateUser(connection, createReq);
        } else if (object instanceof NetworkProtocol.PlayerMoveRequest moveReq) {
            handlePlayerMove(connection, moveReq);
        } else if (object instanceof NetworkProtocol.ChunkRequest chunkReq) {
            handleChunkRequest(connection, chunkReq);
        } else if (object instanceof io.github.minemon.chat.model.ChatMessage chatMsg) {
            handleChatMessage(connection, chatMsg);
        } else {
            log.warn("Unknown message type received: {}", object.getClass());
        }
    }

    private void handleChatMessage(Connection connection, io.github.minemon.chat.model.ChatMessage msg) {
        String sender = connectionUserMap.get(connection.getID());
        if (sender == null) {
            log.warn("ChatMessage received from unregistered connection: {}", connection.getID());
            return;
        }
        msg.setSender(sender);

        log.info("Received ChatMessage from {}: {}", sender, msg.getContent());
        server.sendToAllExceptTCP(connection.getID(), msg);

    }

    private void handleLogin(Connection connection, NetworkProtocol.LoginRequest req) {
        boolean authSuccess = authService.authenticate(req.getUsername(), req.getPassword());
        NetworkProtocol.LoginResponse resp = new NetworkProtocol.LoginResponse();

        if (!authSuccess) {
            resp.setSuccess(false);
            resp.setMessage("Invalid username or password.");
            connection.sendTCP(resp);
            log.info("Authentication failed for user: {}", req.getUsername());
            return;
        }

        connectionUserMap.put(connection.getID(), req.getUsername());
        multiplayerService.playerConnected(req.getUsername());

        eventBus.fireEvent(new PlayerJoinEvent(req.getUsername()));
        PlayerData pd = multiplayerService.getPlayerData(req.getUsername());

        resp.setSuccess(true);
        resp.setUsername(req.getUsername());
        resp.setX((int) pd.getX());
        resp.setY((int) pd.getY());

        connection.sendTCP(resp);
        log.info("User '{}' logged in successfully from {}", req.getUsername(), connection.getRemoteAddressTCP());

        broadcastPlayerStates();
        sendInitialChunks(connection, pd);
    }

    private void handleCreateUser(Connection connection, NetworkProtocol.CreateUserRequest req) {
        NetworkProtocol.CreateUserResponse resp = new NetworkProtocol.CreateUserResponse();
        boolean success = authService.createUser(req.getUsername(), req.getPassword());
        if (success) {
            resp.setSuccess(true);
            resp.setMessage("User created successfully. You can now log in.");
        } else {
            resp.setSuccess(false);
            resp.setMessage("Username already exists or invalid input.");
        }
        connection.sendTCP(resp);
        log.info("User creation attempt for '{}': {}", req.getUsername(), success ? "SUCCESS" : "FAILURE");
    }

    private void handlePlayerMove(Connection connection, NetworkProtocol.PlayerMoveRequest moveReq) {
        String username = connectionUserMap.get(connection.getID());
        if (username == null) {
            log.warn("No user for this connection.");
            return;
        }

        PlayerData pd = worldService.getPlayerData(username);
        if (pd == null) return;

        try {
            pd.setDirection(io.github.minemon.player.model.PlayerDirection.valueOf(
                    moveReq.getDirection().toUpperCase()
            ));
        } catch (IllegalArgumentException e) {
            log.error("Invalid direction '{}'", moveReq.getDirection());
        }

        boolean positionChanged = (pd.getX() != moveReq.getX() || pd.getY() != moveReq.getY());

        pd.setX(moveReq.getX());
        pd.setY(moveReq.getY());
        pd.setWantsToRun(moveReq.isRunning());
        pd.setMoving(positionChanged);

        worldService.setPlayerData(pd);

        broadcastPlayerStates();
    }


    private void broadcastPlayerStates() {
        Map<String, PlayerSyncData> states = multiplayerService.getAllPlayerStates();
        NetworkProtocol.PlayerStatesUpdate update = new NetworkProtocol.PlayerStatesUpdate();
        update.setPlayers(states);
        broadcast(update);
    }

    private void handleChunkRequest(Connection connection, NetworkProtocol.ChunkRequest req) {
        // Rate limit chunk requests per connection
        String clientId = connection.getID() + "";
        long now = System.currentTimeMillis();

        chunkRequestTimes.put(clientId, now);

        ChunkUpdate chunk = multiplayerService.getChunkData(req.getChunkX(), req.getChunkY());
        if (chunk == null) {
            // Generate chunk if it doesn't exist
            worldService.loadChunk(new Vector2(req.getChunkX(), req.getChunkY()));
            chunk = multiplayerService.getChunkData(req.getChunkX(), req.getChunkY());
            if (chunk == null) {
                log.error("Failed to generate chunk ({}, {})", req.getChunkX(), req.getChunkY());
                return;
            }
        } else {

            NetworkProtocol.ChunkData cd = new NetworkProtocol.ChunkData();
            cd.setChunkX(req.getChunkX());
            cd.setChunkY(req.getChunkY());
            cd.setTiles(chunk.getTiles());
            cd.setObjects(chunk.getObjects());
            connection.sendTCP(cd);
        }
    }

    private void sendInitialChunks(Connection connection, PlayerData pd) {
        int px = (int) pd.getX();
        int py = (int) pd.getY();
        int radius = 2;
        int startX = px / 16 - radius;
        int endX = px / 16 + radius;
        int startY = py / 16 - radius;
        int endY = py / 16 + radius;

        for (int cx = startX; cx <= endX; cx++) {
            for (int cy = startY; cy <= endY; cy++) {
                ChunkUpdate chunk = multiplayerService.getChunkData(cx, cy);
                if (chunk == null) continue;

                NetworkProtocol.ChunkData cd = new NetworkProtocol.ChunkData();
                cd.setChunkX(cx);
                cd.setChunkY(cy);
                cd.setTiles(chunk.getTiles());
                cd.setObjects(chunk.getObjects());
                connection.sendTCP(cd);
            }
        }
    }


    @Override
    public void broadcast(Object message) {
        if (server != null && running) {
            server.sendToAllTCP(message);
        } else {
            log.warn("Cannot broadcast message, server not running.");
        }
    }

    @Override
    public synchronized void stopServer() {
        if (!running) {
            log.warn("Attempt to stop server that is not running.");
            return;
        }

        log.info("Beginning server shutdown sequence...");
        running = false;

        try {
            // 1. Notify clients of shutdown
            log.info("Notifying connected clients of shutdown...");
            NetworkProtocol.ServerShutdownNotice notice = new NetworkProtocol.ServerShutdownNotice();
            notice.setMessage("Server is shutting down...");
            broadcast(notice);

            // 2. Trigger disconnect events
            for (String username : connectionUserMap.values()) {
                eventBus.fireEvent(new PlayerLeaveEvent(username));
            }

            // 3. Save world state
            log.info("Saving world state...");
            worldService.saveWorldData();

            // 4. Wait briefly for clients to process shutdown
            Thread.sleep(1000);

            // 5. Clean up network resources
            if (server != null) {
                log.info("Stopping network server...");
                try {
                    server.close();
                } catch (Exception e) {
                    log.error("Error closing server: {}", e.getMessage());
                } finally {
                    server.stop();
                }
            }

            // 6. Clean up caches and executors
            log.info("Cleaning up resources...");
            if (cacheCleanupExecutor != null) {
                cacheCleanupExecutor.shutdown();
                if (!cacheCleanupExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                    cacheCleanupExecutor.shutdownNow();
                }
            }

            // 7. Clear all maps and collections
            chunkRequestTimes.clear();
            pendingChunkRequests.clear();
            clientChunkCache.clear();
            connectionUserMap.clear();

            log.info("Server shutdown completed successfully");

        } catch (Exception e) {
            log.error("Error during server shutdown: {}", e.getMessage(), e);
        } finally {
            server = null;
        }
    }
    @Override
    public void processMessages(float delta) {
        multiplayerService.tick(delta);
        var objectUpdates = multiplayerService.getAllWorldObjectUpdates();
        if (!objectUpdates.isEmpty()) {
            NetworkProtocol.WorldObjectsUpdate wUpdate = new NetworkProtocol.WorldObjectsUpdate();
            wUpdate.setObjects(objectUpdates);
            broadcast(wUpdate);
        }
    }
}

================
File: io/github/minemon/server/service/impl/MultiplayerServiceImpl.java
================
package io.github.minemon.server.service.impl;

import io.github.minemon.multiplayer.model.ChunkUpdate;
import io.github.minemon.multiplayer.model.PlayerSyncData;
import io.github.minemon.multiplayer.model.WorldObjectUpdate;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.server.service.MultiplayerService;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.world.service.WorldService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.*;

import org.springframework.core.env.Environment;

@Service
@Slf4j
public class MultiplayerServiceImpl implements MultiplayerService {

    private final WorldService worldService;


    private final boolean isServer;
    private final Set<String> connectedPlayers = Collections.synchronizedSet(new HashSet<>());


    private final List<WorldObjectUpdate> pendingObjectUpdates = Collections.synchronizedList(new ArrayList<>());

    @Autowired
    public MultiplayerServiceImpl(WorldService worldService,
                                  Environment env ) {
        this.worldService = worldService;
        this.isServer = true;
    }

    @Override
    public void playerConnected(String username) {
        if (!isServer) {
            log.warn("Client attempted to handle player connection - ignoring");
            return;
        }
        worldService.initIfNeeded();
        PlayerData pd = worldService.getPlayerData(username);
        if (pd == null) {
            pd = new PlayerData(username, 0, 0);
            worldService.setPlayerData(pd);
        }
        connectedPlayers.add(username);
    }

    @Override
    public void playerDisconnected(String username) {
        if (!isServer) {
            log.warn("Client attempted to handle player disconnection - ignoring");
            return;
        }
        connectedPlayers.remove(username);
    }

    @Override
    public PlayerData getPlayerData(String username) {
        return worldService.getPlayerData(username);
    }

    @Override
    public void updatePlayerData(PlayerData data) {
        if (!isServer) {
            log.warn("Client attempted to update player data - ignoring");
            return;
        }


        worldService.setPlayerData(data);
    }

    @Override
    public ChunkUpdate getChunkData(int chunkX, int chunkY) {
        if (!isServer) {
            log.warn("Client attempted to handle player disconnection - ignoring");
            return null;
        }
        int[][] tiles = worldService.getChunkTiles(chunkX, chunkY);
        if (tiles == null) return null;

        var wd = worldService.getWorldData();
        if (wd == null) return null;

        String key = chunkX + "," + chunkY;
        var chunkData = wd.getChunks().get(key);
        if (chunkData == null) return null;

        List<WorldObject> objs = chunkData.getObjects();

        ChunkUpdate update = new ChunkUpdate();
        update.setChunkX(chunkX);
        update.setChunkY(chunkY);
        update.setTiles(tiles);
        update.setObjects(objs);
        return update;
    }

    @Override
    public Map<String, PlayerSyncData> getAllPlayerStates() {
        if (!isServer) {
            log.warn("Client attempted to get all player states - ignoring");
            return Collections.emptyMap();
        }
        Map<String, PlayerSyncData> states = new HashMap<>();
        for (String user : connectedPlayers) {
            PlayerData pd = worldService.getPlayerData(user);
            if (pd != null) {
                states.put(user, PlayerSyncData.fromPlayerData(pd));
            }
        }
        return states;
    }

    @Override
    public List<WorldObjectUpdate> getAllWorldObjectUpdates() {
        List<WorldObjectUpdate> snapshot;
        synchronized (pendingObjectUpdates) {
            snapshot = new ArrayList<>(pendingObjectUpdates);
            pendingObjectUpdates.clear();
        }
        return snapshot;
    }

    @Override
    public void broadcastPlayerState(PlayerData data) {


    }

    @Override
    public void broadcastChunkUpdate(ChunkUpdate chunk) {

    }

    @Override
    public void broadcastWorldObjectUpdate(WorldObjectUpdate objUpdate) {
        if (!isServer) {
            log.warn("Client attempted to broadcast world object update - ignoring");
            return;
        }
        synchronized (pendingObjectUpdates) {
            pendingObjectUpdates.add(objUpdate);
        }
    }

    @Override
    public void tick(float delta) {

    }
}

================
File: io/github/minemon/server/service/impl/ServerCleanupService.java
================
package io.github.minemon.server.service.impl;

import jakarta.annotation.PreDestroy;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;

@Service
@Slf4j
public class ServerCleanupService {
    private static final long SHUTDOWN_TIMEOUT_SECONDS = 5;

    public void cleanupExecutor(ExecutorService executor, String executorName) {
        log.info("Shutting down {} executor service...", executorName);
        executor.shutdown();
        try {
            if (!executor.awaitTermination(SHUTDOWN_TIMEOUT_SECONDS, TimeUnit.SECONDS)) {
                log.warn("{} executor did not terminate in {} seconds, forcing shutdown...",
                        executorName, SHUTDOWN_TIMEOUT_SECONDS);
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            log.error("{} executor shutdown interrupted", executorName);
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    @PreDestroy
    public void preDestroy() {
        log.info("ServerCleanupService shutting down...");
    }
}

================
File: io/github/minemon/server/service/MultiplayerServer.java
================
package io.github.minemon.server.service;

public interface MultiplayerServer {
    void startServer(int tcpPort, int udpPort);
    void stopServer();
    void broadcast(Object message);
    void processMessages(float delta);
}

================
File: io/github/minemon/server/service/MultiplayerService.java
================
package io.github.minemon.server.service;

import io.github.minemon.player.model.PlayerData;
import io.github.minemon.multiplayer.model.ChunkUpdate;
import io.github.minemon.multiplayer.model.PlayerSyncData;
import io.github.minemon.multiplayer.model.WorldObjectUpdate;

import java.util.List;
import java.util.Map;

public interface MultiplayerService {
    void playerConnected(String username);
    void playerDisconnected(String username);

    PlayerData getPlayerData(String username);
    void updatePlayerData(PlayerData data);

    ChunkUpdate getChunkData(int chunkX, int chunkY);
    Map<String, PlayerSyncData> getAllPlayerStates();
    List<WorldObjectUpdate> getAllWorldObjectUpdates();

    void broadcastPlayerState(PlayerData data);
    void broadcastChunkUpdate(ChunkUpdate chunk);
    void broadcastWorldObjectUpdate(WorldObjectUpdate objUpdate);
    void tick(float delta);
}

================
File: io/github/minemon/server/world/ServerTileManagerImpl.java
================
package io.github.minemon.server.world;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.minemon.world.service.TileManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Component;

@Component
@Slf4j
@Primary
@Qualifier("serverTileManagerImpl")
public class ServerTileManagerImpl implements TileManager {

    @Override
    public void initIfNeeded() {
        log.info("ServerTileManagerImpl initialized (no-op).");
    }

    @Override
    public TextureRegion getRegionForTile(int tileId) {
        return null;
    }

    @Override
    public boolean isPassable(int tileId) {
        return true;
    }

    @Override
    public String getTileName(int tileId) {
        return "unknown";
    }
}

================
File: io/github/minemon/server/world/ServerWorldObjectManagerImpl.java
================
package io.github.minemon.server.world;

import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.model.ObjectType;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.world.service.WorldObjectManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
@Service
@Primary
@Slf4j
public class ServerWorldObjectManagerImpl implements WorldObjectManager {

    private final Map<String, List<WorldObject>> objectsByChunk = new ConcurrentHashMap<>();

    @Override
    public void initialize() {
        log.info("ServerWorldObjectManagerImpl initialized (no-op).");
    }

    @Override
    public List<WorldObject> getObjectsForChunk(int chunkX, int chunkY) {
        String key = chunkX + "," + chunkY;
        return objectsByChunk.getOrDefault(key, Collections.emptyList());
    }

    @Override
    public List<WorldObject> generateObjectsForChunk(int chunkX, int chunkY, int[][] tiles, Biome biome, long seed) {
        List<WorldObject> objects = new CopyOnWriteArrayList<>();
        if (biome == null || tiles == null) {
            log.warn("Cannot generate objects - missing biome or tiles for chunk {},{}", chunkX, chunkY);
            return objects;
        }

        // Generate a chunk-specific seed
        long chunkSeed = seed + chunkX * 341873128712L + chunkY * 132897987541L;
        Random random = new Random(chunkSeed);

        // Get chunk size from tiles array
        int chunkSize = tiles.length;

        // Calculate object placement
        for (String objTypeName : biome.getSpawnableObjects()) {
            ObjectType type;
            try {
                type = ObjectType.valueOf(objTypeName);
            } catch (IllegalArgumentException e) {
                log.warn("Invalid object type {} in biome {}", objTypeName, biome.getName());
                continue;
            }

            double spawnChance = biome.getSpawnChanceForObject(type);
            int maxAttempts = (int)(spawnChance * (chunkSize * chunkSize));

            for (int attempt = 0; attempt < maxAttempts; attempt++) {
                int localX = random.nextInt(chunkSize);
                int localY = random.nextInt(chunkSize);

                // Check if tile type is valid for this object
                int tileId = tiles[localX][localY];
                if (!biome.getAllowedTileTypes().contains(tileId)) {
                    continue;
                }

                // Convert to world coordinates
                int worldX = chunkX * chunkSize + localX;
                int worldY = chunkY * chunkSize + localY;

                // Check spacing requirements
                if (canPlaceObject(objects, worldX, worldY, type)) {
                    WorldObject obj = new WorldObject(worldX, worldY, type, type.isCollidable());
                    objects.add(obj);
                    log.debug("Added {} at {},{} in chunk {},{}",
                        type, worldX, worldY, chunkX, chunkY);
                }
            }
        }

        log.info("Generated {} objects for chunk {},{}", objects.size(), chunkX, chunkY);
        return objects;
    }

    private boolean canPlaceObject(List<WorldObject> existingObjects, int x, int y, ObjectType type) {
        // Define minimum spacing based on object type
        int minSpacing = type.name().contains("TREE") ? 3 : 2;

        for (WorldObject existing : existingObjects) {
            int dx = existing.getTileX() - x;
            int dy = existing.getTileY() - y;
            double distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < minSpacing) {
                return false;
            }
        }
        return true;
    }

    private boolean noTreeNearby(List<WorldObject> objects, int x, int y, int minDistance) {
        for (WorldObject obj : objects) {
            if (obj.getType().name().startsWith("TREE")) {
                int dx = obj.getTileX() - x;
                int dy = obj.getTileY() - y;
                if (dx * dx + dy * dy < minDistance * minDistance) {
                    return false;
                }
            }
        }
        return true;
    }

    @Override
    public void loadObjectsForChunk(int chunkX, int chunkY, List<WorldObject> objects) {
        String key = chunkX + "," + chunkY;
        objectsByChunk.put(key, objects);
    }

    @Override
    public void addObject(WorldObject object) {
        int chunkX = object.getTileX() / 16;
        int chunkY = object.getTileY() / 16;
        String key = chunkX + "," + chunkY;
        objectsByChunk.computeIfAbsent(key, k -> new CopyOnWriteArrayList<>()).add(object);
    }

    @Override
    public void removeObject(String objectId) {
        for (List<WorldObject> objs : objectsByChunk.values()) {
            objs.removeIf(o -> o.getId().equals(objectId));
        }
    }
}

================
File: io/github/minemon/server/world/ServerWorldServiceImpl.java
================
package io.github.minemon.server.world;


import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.minemon.multiplayer.model.WorldObjectUpdate;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.world.biome.config.BiomeConfigurationLoader;
import io.github.minemon.world.biome.model.Biome;
import io.github.minemon.world.biome.model.BiomeType;
import io.github.minemon.world.biome.service.BiomeService;
import io.github.minemon.world.model.ChunkData;
import io.github.minemon.world.model.ObjectType;
import io.github.minemon.world.model.WorldData;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.world.service.TileManager;
import io.github.minemon.world.service.WorldGenerator;
import io.github.minemon.world.service.WorldObjectManager;
import io.github.minemon.world.service.WorldService;
import io.github.minemon.world.service.impl.BaseWorldServiceImpl;
import io.github.minemon.world.service.impl.JsonWorldDataService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Service
@Slf4j
@Primary
public class ServerWorldServiceImpl extends BaseWorldServiceImpl implements WorldService {
    private static final int TILE_SIZE = 32;
    private static final int CHUNK_SIZE = 16;

    private final WorldGenerator worldGenerator;
    private final WorldObjectManager worldObjectManager;
    private final TileManager tileManager;
    private final BiomeConfigurationLoader biomeLoader;
    private final BiomeService biomeService;
    private final JsonWorldDataService jsonWorldDataService;

    private final WorldData worldData = new WorldData();
    private final Map<String, WorldData> loadedWorlds = new ConcurrentHashMap<>();
    private boolean initialized = false;
    @Value("${world.defaultName:defaultWorld}")
    private String defaultWorldName;

    private OrthographicCamera camera = null;

    public ServerWorldServiceImpl(
        WorldGenerator worldGenerator,
        WorldObjectManager worldObjectManager,
        TileManager tileManager,
        BiomeConfigurationLoader biomeLoader, BiomeService biomeService,
        @Qualifier("serverJsonWorldDataService") JsonWorldDataService jsonWorldDataService
    ) {
        this.worldGenerator = worldGenerator;
        this.biomeService = biomeService;
        this.worldObjectManager = worldObjectManager;
        this.tileManager = tileManager;
        this.biomeLoader = biomeLoader;
        this.jsonWorldDataService = jsonWorldDataService;
    }

    @Override
    public void initIfNeeded() {
        if (initialized) {
            return;
        }

        // Initialize biome configuration first
        Map<BiomeType, Biome> biomes = biomeLoader.loadBiomes("config/biomes.json");
        if (biomes.isEmpty()) {
            log.error("Failed to load biome configurations");
            return;
        }

        // Set seed and biomes for world generator
        if (!loadedWorlds.containsKey("serverWorld")) {
            try {
                WorldData wd = new WorldData();
                jsonWorldDataService.loadWorld("serverWorld", wd);
                loadedWorlds.put("serverWorld", wd);
                worldGenerator.setSeedAndBiomes(wd.getSeed(), biomes);
                biomeService.initWithSeed(wd.getSeed());
            } catch (IOException e) {
                // Create new world if none exists
                WorldData newWorld = new WorldData();
                newWorld.setWorldName("serverWorld");
                newWorld.setSeed(new Random().nextLong()); // Generate new seed
                try {
                    jsonWorldDataService.saveWorld(newWorld);
                    worldGenerator.setSeedAndBiomes(newWorld.getSeed(), biomes);
                    biomeService.initWithSeed(newWorld.getSeed());
                } catch (IOException ex) {
                    log.error("Failed to save new server world", ex);
                }
                loadedWorlds.put("serverWorld", newWorld);
            }
        }

        initialized = true;
        log.info("ServerWorldService initialized with seed {}",
            loadedWorlds.get("serverWorld").getSeed());
    }

    @Override
    public WorldData getWorldData() {
        return worldData;
    }

    @Override
    public boolean isMultiplayerMode() {
        return true;
    }

    @Override
    public void setMultiplayerMode(boolean multiplayer) {

    }

    @Override
    public TileManager getTileManager() {
        return tileManager;
    }

    // ------------------------------
    // Saving and Loading from JSON
    // ------------------------------
    @Override
    public void loadWorldData() {
        try {
            jsonWorldDataService.loadWorld(defaultWorldName, worldData);
            initIfNeeded();
            log.info("Loaded default world data for '{}' from JSON (server)", defaultWorldName);
        } catch (IOException e) {
            log.warn("Failed to load default world '{}': {}", defaultWorldName, e.getMessage());
        }
    }

    @Override
    public boolean createWorld(String worldName, long seed) {
        // We simply set in-memory and call save
        if (jsonWorldDataService.worldExists(worldName)) {
            log.warn("World '{}' already exists, cannot create", worldName);
            return false;
        }

        long now = System.currentTimeMillis();
        worldData.setWorldName(worldName);
        worldData.setSeed(seed);
        worldData.setCreatedDate(now);
        worldData.setLastPlayed(now);
        worldData.setPlayedTime(0);

        try {
            jsonWorldDataService.saveWorld(worldData);
        } catch (IOException e) {
            log.error("Failed to create new world '{}': {}", worldName, e.getMessage());
            return false;
        }
        log.info("Created new world '{}' with seed {} in JSON (server)", worldName, seed);
        return true;
    }

    @Override
    public void saveWorldData() {
        WorldData wd = loadedWorlds.get("serverWorld");
        if (wd != null) {
            try {
                jsonWorldDataService.saveWorld(wd);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public void loadWorld(String worldName) {
        try {
            jsonWorldDataService.loadWorld(worldName, worldData);
            initIfNeeded();
            log.info("Loaded world data for '{}' from JSON (server)", worldName);
        } catch (IOException e) {
            log.warn("World '{}' does not exist in JSON or failed to load: {}", worldName, e.getMessage());
        }
    }


    @Override
    public int[][] getChunkTiles(int chunkX, int chunkY) {
        WorldData wd = loadedWorlds.get("serverWorld");
        if (wd == null) return null;

        String key = chunkX + "," + chunkY;
        ChunkData chunkData = wd.getChunks().get(key);

        if (chunkData == null) {
            loadOrGenerateChunk(chunkX, chunkY);
            chunkData = wd.getChunks().get(key);
        }

        return chunkData != null ? chunkData.getTiles() : null;
    }
    private void generateChunk(int chunkX, int chunkY) {
        int[][] tiles = worldGenerator.generateChunk(chunkX, chunkY);
        ChunkData chunkData = new ChunkData();
        chunkData.setChunkX(chunkX);
        chunkData.setChunkY(chunkY);
        chunkData.setTiles(tiles);

        // Get biome and generate objects
        Biome biome = worldGenerator.getBiomeForChunk(chunkX, chunkY);
        List<WorldObject> objects = worldObjectManager.generateObjectsForChunk(
            chunkX, chunkY, tiles, biome, worldData.getSeed());
        chunkData.setObjects(objects);

        String key = chunkX + "," + chunkY;
        worldData.getChunks().put(key, chunkData);

        // Save the chunk
        try {
            jsonWorldDataService.saveChunk(worldData.getWorldName(), chunkData);
            log.info("Generated and saved new chunk at {},{}", chunkX, chunkY);
        } catch (IOException e) {
            log.error("Failed to save generated chunk: {}", e.getMessage());
        }
    }


    private void loadOrGenerateChunk(int chunkX, int chunkY) {
        String key = chunkX + "," + chunkY;

        // Try to load existing chunk
        try {
            ChunkData loaded = jsonWorldDataService.loadChunk("serverWorld", chunkX, chunkY);
            if (loaded != null) {
                worldObjectManager.loadObjectsForChunk(chunkX, chunkY, loaded.getObjects());
                worldData.getChunks().put(key, loaded);
                return;
            }
        } catch (IOException e) {
            log.warn("Failed to load chunk {}: {}", key, e.getMessage());
        }

        // Generate new chunk if not found
        int[][] tiles = worldGenerator.generateChunk(chunkX, chunkY);
        if (tiles == null) {
            log.error("Failed to generate tiles for chunk {}", key);
            return;
        }

        ChunkData chunkData = new ChunkData();
        chunkData.setChunkX(chunkX);
        chunkData.setChunkY(chunkY);
        chunkData.setTiles(tiles);

        // Get biome and generate objects
        Biome biome = worldGenerator.getBiomeForChunk(chunkX, chunkY);
        if (biome == null) {
            log.error("Failed to get biome for chunk {}", key);
            return;
        }

        List<WorldObject> objects = worldObjectManager.generateObjectsForChunk(
            chunkX, chunkY, tiles, biome, worldData.getSeed());
        chunkData.setObjects(objects);

        // Save the chunk
        worldData.getChunks().put(key, chunkData);
        try {
            jsonWorldDataService.saveChunk("serverWorld", chunkData);
            log.info("Generated and saved new chunk {} with {} objects",
                key, objects.size());
        } catch (IOException e) {
            log.error("Failed to save generated chunk {}: {}", key, e.getMessage());
        }
    }
    @Override
    public boolean isChunkLoaded(Vector2 chunkPos) {
        String key = String.format("%d,%d", (int) chunkPos.x, (int) chunkPos.y);
        return worldData.getChunks().containsKey(key);
    }

    @Override
    public void loadChunk(Vector2 chunkPos) {
        loadOrGenerateChunk((int) chunkPos.x, (int) chunkPos.y);
    }

    @Override
    public List<WorldObject> getVisibleObjects(Rectangle viewBounds) {
        // Implementation unchanged, except no DB call
        List<WorldObject> visibleObjects = new ArrayList<>();
        Map<String, ChunkData> visibleChunks = getVisibleChunks(viewBounds);
        for (ChunkData chunk : visibleChunks.values()) {
            if (chunk.getObjects() != null) {
                visibleObjects.addAll(chunk.getObjects());
            }
        }
        return visibleObjects;
    }

    @Override
    public Map<String, ChunkData> getVisibleChunks(Rectangle viewBounds) {
        // Implementation is basically the same
        Map<String, ChunkData> visibleChunks = new HashMap<>();

        int startChunkX = (int) Math.floor(viewBounds.x / (CHUNK_SIZE * TILE_SIZE));
        int startChunkY = (int) Math.floor(viewBounds.y / (CHUNK_SIZE * TILE_SIZE));
        int endChunkX = (int) Math.ceil((viewBounds.x + viewBounds.width) / (CHUNK_SIZE * TILE_SIZE));
        int endChunkY = (int) Math.ceil((viewBounds.y + viewBounds.height) / (CHUNK_SIZE * TILE_SIZE));

        for (int x = startChunkX; x <= endChunkX; x++) {
            for (int y = startChunkY; y <= endChunkY; y++) {
                String key = x + "," + y;
                if (!worldData.getChunks().containsKey(key)) {
                    loadOrGenerateChunk(x, y);
                }
                ChunkData chunk = worldData.getChunks().get(key);
                if (chunk != null) {
                    visibleChunks.put(key, chunk);
                }
            }
        }

        return visibleChunks;
    }

    @Override
    public void setPlayerData(PlayerData pd) {
        WorldData wd = loadedWorlds.get("serverWorld");
        if (wd == null) return;
        wd.getPlayers().put(pd.getUsername(), pd);
        try {
            jsonWorldDataService.savePlayerData("serverWorld", pd);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    @Override
    public PlayerData getPlayerData(String username) {
        WorldData wd = loadedWorlds.get("serverWorld");
        if (wd == null) return null;
        PlayerData existing = wd.getPlayers().get(username);
        if (existing != null) return existing;
        try {
            PlayerData pd = jsonWorldDataService.loadPlayerData("serverWorld", username);
            if (pd != null) {
                wd.getPlayers().put(username, pd);
            }
            return pd;
        } catch (IOException e) {
            return null;
        }
    }


    @Override
    public List<String> getAvailableWorlds() {
        return jsonWorldDataService.listAllWorlds();
    }

    @Override
    public void deleteWorld(String worldName) {
        if (!jsonWorldDataService.worldExists(worldName)) {
            log.warn("World '{}' does not exist in JSON, cannot delete (server)", worldName);
            return;
        }

        jsonWorldDataService.deleteWorld(worldName);

        // If its the currently loaded world, clear it
        if (worldData.getWorldName() != null && worldData.getWorldName().equals(worldName)) {
            worldData.setWorldName(null);
            worldData.setSeed(0);
            worldData.getPlayers().clear();
            worldData.getChunks().clear();
            worldData.setCreatedDate(0);
            worldData.setLastPlayed(0);
            worldData.setPlayedTime(0);
            log.info("Cleared current loaded world data because it was deleted (server).");
        }
        log.info("Deleted world '{}' from JSON (server)", worldName);
    }

    @Override
    public void regenerateChunk(int chunkX, int chunkY) {
        String key = chunkX + "," + chunkY;
        worldData.getChunks().remove(key);
        // Also delete chunk JSON if present
        jsonWorldDataService.deleteChunk(worldData.getWorldName(), chunkX, chunkY);
        loadOrGenerateChunk(chunkX, chunkY);
    }

    @Override
    public void generateWorldThumbnail(String worldName) {
        log.info("Skipping world thumbnail generation on server.");
    }


    @Override
    public void loadOrReplaceChunkData(int chunkX, int chunkY, int[][] tiles, List<WorldObject> objects) {
        // Server should generate its own chunks, not accept them from clients
        log.warn("Client attempted to send chunk data to server - ignoring");

    }

    @Override
    public void updateWorldObjectState(WorldObjectUpdate update) {
        // Example: move or remove an object in the chunk
        WorldData wd = loadedWorlds.get("serverWorld");
        if (wd == null) return;
        String chunkKey = (update.getTileX() / 16) + "," + (update.getTileY() / 16);

        var chunkData = wd.getChunks().get(chunkKey);
        if (chunkData != null) {
            if (update.isRemoved()) {
                chunkData.getObjects().removeIf(o -> o.getId().equals(update.getObjectId()));
            } else {
                // Possibly find or create
                var existing = chunkData.getObjects().stream()
                    .filter(o -> o.getId().equals(update.getObjectId()))
                    .findFirst();
                if (existing.isPresent()) {
                    // update position
                    var wo = existing.get();
                    wo.setTileX(update.getTileX());
                    wo.setTileY(update.getTileY());
                } else {
                    // create new
                    WorldObject obj = new WorldObject(
                        update.getTileX(),
                        update.getTileY(),
                        // parse from update.getType()
                        ObjectType.valueOf(update.getType()),
                        true // or read from config
                    );
                    obj.setId(update.getObjectId());
                    chunkData.getObjects().add(obj);
                }
            }
        }
        // Optionally save chunk to disk
        try {
            jsonWorldDataService.saveChunk("serverWorld", chunkData);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public OrthographicCamera getCamera() {
        return camera;
    }

    @Override
    public void setCamera(OrthographicCamera camera) {
        this.camera = camera;
    }
}
