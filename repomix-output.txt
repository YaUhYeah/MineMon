This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-09T01:32:57.006Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
InputConfiguration.java
InputService.java

================================================================
Files
================================================================

================
File: InputConfiguration.java
================
package io.github.minemon.input;

import com.badlogic.gdx.Input;
import io.github.minemon.player.model.PlayerDirection;
import lombok.Getter;
import lombok.Setter;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

@Setter
@Getter
@Component
public class InputConfiguration {
    private Map<Integer, PlayerDirection> movementKeys = new HashMap<>();
    private Map<String, Integer> actionKeys = new HashMap<>();
    private int runKey = Input.Keys.Z;

    public InputConfiguration() {

        movementKeys.put(Input.Keys.W, PlayerDirection.UP);
        movementKeys.put(Input.Keys.UP, PlayerDirection.UP);
        movementKeys.put(Input.Keys.S, PlayerDirection.DOWN);
        movementKeys.put(Input.Keys.DOWN, PlayerDirection.DOWN);
        movementKeys.put(Input.Keys.A, PlayerDirection.LEFT);
        movementKeys.put(Input.Keys.LEFT, PlayerDirection.LEFT);
        movementKeys.put(Input.Keys.D, PlayerDirection.RIGHT);
        movementKeys.put(Input.Keys.RIGHT, PlayerDirection.RIGHT);
        actionKeys.put("PICKUP", Input.Keys.X);


        actionKeys.put("INVENTORY", Input.Keys.E);
    }

    public PlayerDirection getDirectionForKey(int keyCode) {
        return movementKeys.get(keyCode);
    }

    public void updateActionKey(String action, int keycode) {
        actionKeys.put(action, keycode);
    }

    public int getActionKey(String action) {
        return actionKeys.getOrDefault(action, Input.Keys.UNKNOWN);
    }
}

================
File: InputService.java
================
package io.github.minemon.input;

import com.badlogic.gdx.InputAdapter;
import com.badlogic.gdx.math.Rectangle;
import io.github.minemon.chat.service.ChatService;
import io.github.minemon.core.screen.InventoryScreen;
import io.github.minemon.inventory.service.InventoryService;
import io.github.minemon.multiplayer.service.MultiplayerClient;
import io.github.minemon.player.model.PlayerData;
import io.github.minemon.player.model.PlayerDirection;
import io.github.minemon.player.service.PlayerService;
import io.github.minemon.world.model.ObjectType;
import io.github.minemon.world.model.WorldObject;
import io.github.minemon.world.service.WorldObjectManager;
import io.github.minemon.world.service.WorldService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Random;

@Service
@Slf4j
@RequiredArgsConstructor
public class InputService extends InputAdapter {
    private final InputConfiguration inputConfig;
    private boolean upPressed, downPressed, leftPressed, rightPressed;
    private boolean runPressed;
    private PlayerDirection lastPressedDirection = null;
    private boolean isActive = false;
    private static final float TILE_SIZE = 32f;

    @Autowired @Lazy private ChatService chatService;
    @Autowired @Lazy private MultiplayerClient multiplayerClient;
    @Autowired @Lazy private PlayerService playerService;
    @Autowired @Lazy private InventoryScreen inventoryScreen;
    @Autowired @Lazy private WorldService worldService;
    @Autowired @Lazy private WorldObjectManager worldObjectManager;
    @Autowired @Lazy private InventoryService inventoryService;

    public void activate() {
        isActive = true;
        resetKeys();
    }

    public void deactivate() {
        isActive = false;
        resetKeys();
    }

    public PlayerDirection getCurrentDirection() {

        if (!isActive || inventoryScreen.isVisible()) {
            return null;
        }

        if (lastPressedDirection != null) {
            switch (lastPressedDirection) {
                case UP -> { if (upPressed) return PlayerDirection.UP; }
                case DOWN -> { if (downPressed) return PlayerDirection.DOWN; }
                case LEFT -> { if (leftPressed) return PlayerDirection.LEFT; }
                case RIGHT -> { if (rightPressed) return PlayerDirection.RIGHT; }
            }
        }
        if (upPressed) return PlayerDirection.UP;
        if (downPressed) return PlayerDirection.DOWN;
        if (leftPressed) return PlayerDirection.LEFT;
        if (rightPressed) return PlayerDirection.RIGHT;
        return null;
    }

    public boolean isRunning() {

        return isActive && !inventoryScreen.isVisible() && runPressed;
    }

    public void resetKeys() {
        upPressed = false;
        downPressed = false;
        leftPressed = false;
        rightPressed = false;
        runPressed = false;
        lastPressedDirection = null;
    }

    private void attemptPickup() {
        PlayerData pd = playerService.getPlayerData();
        if (pd == null) return;

        // Get player position
        float playerX = pd.getX() * TILE_SIZE;
        float playerY = pd.getY() * TILE_SIZE;

        // Search for nearby pickable items
        Rectangle searchArea = new Rectangle(
            playerX - TILE_SIZE,
            playerY - TILE_SIZE,
            TILE_SIZE * 3,
            TILE_SIZE * 3
        );

        List<WorldObject> nearbyObjects = worldService.getVisibleObjects(searchArea);
        for (WorldObject obj : nearbyObjects) {
            if (obj.getType() == ObjectType.POKEBALL) {
                // Remove object
                worldObjectManager.removeObject(obj.getId());

                // Add random item
                String[] possibleItems = {"pokeball", "potion", "stick"};
                String randomItem = possibleItems[new Random().nextInt(possibleItems.length)];
                inventoryService.addItem(randomItem, 1);


                break;
            }
        }
    }
    @Override
    public boolean keyDown(int keycode) {
        if (!isActive || chatService.isActive()) {
            return false;
        }
        if (keycode == inputConfig.getActionKey("PICKUP")) {
            attemptPickup();
            return true;
        }

        if (keycode == inputConfig.getActionKey("INVENTORY")) {

            inventoryScreen.toggleVisibility();

            if (inventoryScreen.isVisible()) {
                resetKeys();
            }
            return true;
        }


        if (inventoryScreen.isVisible()) {
            return false;
        }

        PlayerDirection dir = inputConfig.getDirectionForKey(keycode);
        if (dir != null) {
            switch (dir) {
                case UP -> upPressed = true;
                case DOWN -> downPressed = true;
                case LEFT -> leftPressed = true;
                case RIGHT -> rightPressed = true;
            }
            lastPressedDirection = dir;
            return true;
        }

        if (keycode == inputConfig.getRunKey()) {
            runPressed = true;
            return true;
        }

        return false;
    }

    @Override
    public boolean keyUp(int keycode) {
        if (!isActive) return false;


        PlayerDirection dir = inputConfig.getDirectionForKey(keycode);
        if (dir != null) {
            switch (dir) {
                case UP -> upPressed = false;
                case DOWN -> downPressed = false;
                case LEFT -> leftPressed = false;
                case RIGHT -> rightPressed = false;
            }
            lastPressedDirection = null;
        }

        if (keycode == inputConfig.getRunKey()) {
            runPressed = false;
        }


        if (!upPressed && !downPressed && !leftPressed && !rightPressed) {
            PlayerData pd = playerService.getPlayerData();
            if (pd != null) {
                float x = pd.getX();
                float y = pd.getY();
                String dirName = pd.getDirection().name().toLowerCase();
                multiplayerClient.sendPlayerMove(x, y, false, false, dirName);
            }
        }

        return true;
    }
}
